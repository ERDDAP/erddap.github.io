---
sidebar_position: 3
---
# साथ काम करना datasets.xml फ़ाइल

 \\[ यह वेब पेज केवल ब्याज का ही होगा ERDDAP™ व्यवस्थापक। \\] 

उसके बाद ERDDAP™   [स्थापना निर्देश](/docs/server-admin/deploy-install) , आप संपादित करना चाहिए datasets.xml फाइल *tomcat* अपने डेटासेट का वर्णन करने के लिए /content/erddap/ ERDDAP™ स्थापना की जाएगी।

आप एक उदाहरण देख सकते हैं [ datasets.xml GitHub](https://github.com/ERDDAP/erddap/blob/main/development/jetty/config/datasets.xml) ।

- -

##  [परिचय](#introduction)  {#introduction} 

### कुछ आवश्यक विधानसभा{#some-assembly-required} 
डेटासेट स्थापित करना ERDDAP™ केवल डेटासेट की निर्देशिका या यूआरएल को इंगित करने का कोई मामला नहीं है। आपको XML का एक हिस्सा लिखना होगा datasets.xml जो डेटासेट का वर्णन करता है।

* ग्रिड डेटासेट के लिए, डेटासेट बनाने के लिए ERDDAP ग्रिड डेटा के लिए डेटा संरचना, आपको डेटासेट के चर की एक सबसेट की पहचान करना होगा जो समान आयामों को साझा करता है। ( [क्यों?](#why-just-two-basic-data-structures)   [कैसे?](#dimensions) ) 
* डेटासेट का वर्तमान मेटाडाटा स्वचालित रूप से आयात किया जाता है। लेकिन अगर आप उस मेटाडाटा को संशोधित करना चाहते हैं या अन्य मेटाडाटा जोड़ते हैं, तो आपको इसे निर्दिष्ट करना होगा datasets.xml । और ERDDAP™ अन्य मेटाडाटा की जरूरत है, जिसमें शामिल हैं [वैश्विक गुण](#global-attributes)   (जैसे infoUrl संस्थान sourceUrl सारांश और शीर्षक) और [चर गुण](#variable-addattributes)   (जैसे long\\_name इकाई) । जैसा कि वर्तमान में डेटासेट में मौजूद मेटाडाटा डेटासेट में वर्णनात्मक जानकारी जोड़ता है, मेटाडाटा द्वारा अनुरोध किया गया है ERDDAP™ डेटासेट में वर्णनात्मक जानकारी जोड़ता है। अतिरिक्त मेटाडाटा आपके डेटासेट के लिए एक अच्छा जोड़ है और मदद करता है ERDDAP™ अपने डेटा को उपयोगकर्ताओं के लिए प्रस्तुत करने का बेहतर काम करते हैं जो इससे परिचित नहीं हैं।
*    ERDDAP™ आपको विशेष काम करने की आवश्यकता है [अक्षांश, ऊंचाई (या गहराई) , और समय चर](#destinationname) ।

यदि आप इन विचारों को खरीदते हैं और XML बनाने के प्रयास को खर्च करते हैं datasets.xml , आपको सभी लाभ मिलते हैं ERDDAP™ सहित:

* डेटासेट के लिए पूर्ण पाठ खोज
* श्रेणी द्वारा डेटासेट के लिए खोजें
* डाटा एक्सेस फॉर्म ( * datasetID * एचटीएमएल) इसलिए आप विभिन्न फ़ाइल प्रारूपों में डेटा की एक सबसेट का अनुरोध कर सकते हैं
* ग्राफ और मैप्स का अनुरोध करने के लिए फॉर्म ( * datasetID * ग्राफ़) 
* वेब मानचित्र सेवा ( WMS ) ग्रिड डेटासेट के लिए
*    RESTful अपने डेटा तक पहुंच

बनाना datasets.xml पहले कुछ डेटासेट के लिए काफी प्रयास करता है, लेकिन **यह आसान हो जाता है** । पहले डेटासेट के बाद, आप अक्सर अगले डेटासेट के लिए अपने काम का उपयोग कर सकते हैं। सौभाग्य से, ERDDAP™ दो के साथ आता है [उपकरण](#tools) आपको प्रत्येक डेटासेट के लिए XML बनाने में मदद करने के लिए datasets.xml ।
यदि आप अटक जाते हैं, तो हमें देखें [अतिरिक्त समर्थन प्राप्त करने पर अनुभाग](/docs/intro#support) ।

### में चर datasets.xml  {#varaibles-in-datasetsxml} 

जैसा ERDDAP™ संस्करण 2.29.0, datasets.xml अब है (वैकल्पिक) द्वारा संसाधित [स्ट्रिंगSubstitutor](https://commons.apache.org/proper/commons-text/apidocs/org/apache/commons/text/StringSubstitutor.html) । इसमें निजी मूल्यों की स्थापना सहित कई उपयोग हैं (पासवर्ड की तरह) पर्यावरण चर का उपयोग करना। इसे स्थापित करके अक्षम किया जा सकता हैEnvParsing को सेटअप.xml में झूठी करने के लिए।

### डेटा प्रदाता फॉर्म{#data-provider-form} 
जब कोई डेटा प्रदाता आपको अपने डेटा को जोड़ने की उम्मीद करता है ERDDAP , यह मुश्किल और समय लेने के लिए सभी मेटाडाटा इकट्ठा करने के लिए (डेटासेट के बारे में जानकारी) डेटासेट को जोड़ने के लिए आवश्यक है ERDDAP । कई डेटा स्रोत (उदाहरण के लिए, .csv फ़ाइलें, एक्सेल फाइलें, डेटाबेस) कोई आंतरिक मेटाडाटा नहीं है, इसलिए ERDDAP™ एक डेटा प्रदाता फॉर्म है जो डेटा प्रदाता से मेटाडाटा इकट्ठा करता है और डेटा प्रदाता को कुछ अन्य मार्गदर्शन देता है, जिसमें व्यापक मार्गदर्शन शामिल है। [डेटाबेस में डेटा](https://coastwatch.pfeg.noaa.gov/erddap/dataProviderForm1.html#databases) । प्रस्तुत की गई जानकारी को परिवर्तित कर दिया गया है। datasets.xml प्रारूप और फिर ईमेल करने के लिए ERDDAP™ व्यवस्थापक (आप) और लिखा (परिशिष्ट) to *बड़ाParentDirectory* /logs/dataProviderForm.log. इस प्रकार, फॉर्म अर्ध स्वचालित रूप से डेटासेट प्राप्त करने की प्रक्रिया को स्वचालित करता है ERDDAP लेकिन ERDDAP™ प्रशासक को अभी भी पूरा करना है datasets.xml डेटा फ़ाइल प्राप्त करने के साथ भाग और सौदा (s) प्रदाता से या डेटाबेस से जुड़ना।

बाह्य स्रोतों से वास्तविक डेटा फ़ाइलों को जमा करना एक भारी सुरक्षा जोखिम है, इसलिए ERDDAP™ इसके साथ सौदा नहीं करता है। उदाहरण के लिए, आपको एक ऐसे समाधान का पता लगाना होगा जो आपके और डेटा प्रदाता के लिए काम करता है, उदाहरण के लिए, ईमेल (छोटी फ़ाइलों के लिए) , बादल से खींचो (उदाहरण के लिए, ड्रॉपबॉक्स या गूगल ड्राइव) , एक sftp साइट (पासवर्ड के साथ) , या स्नीकर नेट (यूएसबी अंगूठे ड्राइव या बाहरी हार्ड ड्राइव) । आपको शायद केवल उन लोगों से फ़ाइलों को स्वीकार करना चाहिए जिन्हें आप जानते हैं। आपको वायरस के लिए फ़ाइलों को स्कैन करने और अन्य सुरक्षा सावधानियों को लेने की आवश्यकता होगी।

इसमें कोई लिंक नहीं है ERDDAP™ डेटा प्रदाता फॉर्म (उदाहरण के लिए, पर ERDDAP™ होम पेज) । इसके बजाय, जब कोई आपको बताता है कि वे अपने डेटा को आपके द्वारा सेवा प्रदान करना चाहते हैं ERDDAP , आप उन्हें कुछ ऐसा कह सकते हैं:
हां, हम आपके डेटा को आपके डेटा में बदल सकते हैं ERDDAP । शुरू करने के लिए, कृपया फॉर्म भरेंhttps://*yourUrl*/erddap/dataProviderForm.html  (या http:// अगर https:// सक्षम नहीं है) ।
समाप्त होने के बाद, मैं आपसे अंतिम विवरण देने के लिए संपर्क करूँगा।
यदि आप सिर्फ फॉर्म देखना चाहते हैं (इसे भरने के बिना) , आप फॉर्म को देख सकते हैं ERD ' ERDDAP : [परिचय](https://coastwatch.pfeg.noaa.gov/erddap/dataProviderForm.html) , [भाग 1](https://coastwatch.pfeg.noaa.gov/erddap/dataProviderForm1.html) , [भाग 2](https://coastwatch.pfeg.noaa.gov/erddap/dataProviderForm2.html) , [भाग 3](https://coastwatch.pfeg.noaa.gov/erddap/dataProviderForm3.html) , और [भाग 4](https://coastwatch.pfeg.noaa.gov/erddap/dataProviderForm4.html) । ये लिंक ERD   ERDDAP™ मुझे जानकारी भेजें, न कि आप, इसलिए उन लोगों के साथ जानकारी प्रस्तुत न करें जब तक कि आप वास्तव में डेटा जोड़ना चाहते हैं। ERD   ERDDAP ।

यदि आप अपने डेटा प्रदाता फॉर्म को अपने आप से हटाना चाहते हैं ERDDAP™ , रखना
```
<dataProviderFormActive>false</dataProviderFormActive>  
```
अपने सेटअप.xml फ़ाइल में।

इसके लिए impetus था NOAA 2014 [अनुसंधान परिणाम (PARR) निर्देश](https://www.glerl.noaa.gov/review2016/reviewer_docs/NOAA_PARR_Plan_v5.04.pdf) , जिसके लिए सभी की आवश्यकता है NOAA करदाता डॉलर के माध्यम से वित्त पोषित पर्यावरण डेटा डेटा सेवा के माध्यम से उपलब्ध कराया जा सकता है (न सिर्फ़ फाइल) निर्माण के 12 महीनों के भीतर। इसलिए उपयोग में रुचि बढ़ जाती है ERDDAP™ एक सेवा ASAP के माध्यम से उपलब्ध डेटासेट बनाने के लिए। हमें बड़ी संख्या में डेटा प्रदाताओं से निपटने के लिए अधिक कुशल तरीके की आवश्यकता है।

प्रतिक्रिया / सुझाव? यह फॉर्म नया है, इसलिए कृपया ईमेल करें erd dot data at noaa dot gov यदि आपके पास इस सुधार के लिए कोई प्रतिक्रिया या सुझाव है।

### उपकरण{#tools} 
 ERDDAP™ दो कमांड लाइन प्रोग्राम के साथ आता है जो टूल हैं जो आपको प्रत्येक डेटासेट के लिए XML बनाने में मदद करता है जिसे आप चाहते हैं कि आपका XML ERDDAP™ सेवा एक बार जब आपने स्थापित किया है ERDDAP™ इसे चलाने के लिए (कम से कम एक बार) , आप इन कार्यक्रमों को पा सकते हैं और उपयोग कर सकते हैं *tomcat* /webapps/erddap/WEB-INF निर्देशिका। लिनक्स / यूनिक्स शेल स्क्रिप्ट हैं (एक्सटेंशन .sh साथ) Windows स्क्रिप्ट (एक्सटेंशन .bat के साथ) प्रत्येक कार्यक्रम के लिए। \\[ लिनक्स पर, इन उपकरणों को उसी उपयोगकर्ता के रूप में चलाएं (Tomcat?) वह टॉमकैट चला जाएगा। \\] जब आप प्रत्येक कार्यक्रम को चलाते हैं, तो यह आपको सवाल पूछेगा। प्रत्येक प्रश्न के लिए, एक प्रतिक्रिया टाइप करें, फिर एंटर दबाएँ। या किसी भी समय एक कार्यक्रम से बाहर निकलने के लिए ^C दबाएँ।

#### कार्यक्रम नहीं चलेगा?{#program-wont-run} 

* यदि आप अज्ञात प्रोग्राम प्राप्त करते हैं (समान) त्रुटि संदेश, समस्या यह है कि ऑपरेटिंग सिस्टम को नहीं मिल सका Java । आपको यह पता लगाने की आवश्यकता है कि आपको कहाँ देखना है Java अपने कंप्यूटर पर है, फिर आप उपयोग करने की कोशिश कर रहे हैं कि .bat या .sh फ़ाइल में जावा संदर्भ संपादित करें।
* यदि आप एक जार फ़ाइल प्राप्त करते हैं, तो त्रुटि संदेश नहीं मिला या वर्ग नहीं मिला है, तो फिर Java आप उपयोग करने की कोशिश कर रहे हैं .bat या .sh फ़ाइल में सूचीबद्ध वर्गों में से एक नहीं मिल सका। समाधान यह जानने के लिए है कि .jar फ़ाइल कहाँ है, और .bat या .sh फ़ाइल में जावा संदर्भ को संपादित करें।
* यदि आप एक संस्करण का उपयोग कर रहे हैं Java कि एक कार्यक्रम के लिए बहुत पुराना है, कार्यक्रम चला नहीं जाएगा और आप की तरह एक त्रुटि संदेश देखेंगे
थ्रेड "मुख्य" java.lang.UnsupportedClassVersionError:
     *कुछ/वर्ग/नाम* Unsupported major.minor version *कुछ*   
समाधान के हाल के संस्करण को अद्यतन करना है Java और सुनिश्चित करें कि कार्यक्रम के लिए .sh या .bat फ़ाइल इसका उपयोग कर रही है।

#### उपकरण विभिन्न नैदानिक संदेशों को प्रिंट करते हैं:{#the-tools-print-various-diagnostic-messages} 

* "ERROR" शब्द का उपयोग तब किया जाता है जब कुछ गलत हो गया कि प्रक्रिया पूरी होने में विफल रही। हालांकि यह एक त्रुटि प्राप्त करने के लिए कष्टप्रद है, त्रुटि आपको समस्या से निपटने के लिए मजबूर करती है।
* "WARNING" शब्द का उपयोग तब किया जाता है जब कुछ गलत हो गया था, लेकिन प्रक्रिया पूरी हो गई थी। ये बहुत दुर्लभ हैं।
* कुछ और सिर्फ एक अनौपचारिक संदेश है। आप \\verbose जोड़ सकते हैं [जनरेट DatasetXml](#generatedatasetsxml) या [दास](#dasdds) अतिरिक्त जानकारी प्राप्त करने के लिए कमांड लाइन, जो कभी-कभी समस्याओं को हल करने में मदद करती है।

दो उपकरण एक बड़ी मदद हैं, लेकिन आपको अभी भी इस पृष्ठ पर इन सभी निर्देशों को ध्यानपूर्वक पढ़ना होगा और अपने आप को महत्वपूर्ण निर्णय लेना होगा।

### जनरेट DatasetXml{#generatedatasetsxml} 
*    **जनरेट DatasetXml** एक कमांड लाइन प्रोग्राम है जो लगभग किसी भी प्रकार के डेटासेट के लिए डेटासेट XML का एक मोटे ड्राफ्ट उत्पन्न कर सकता है।
    
हम नियमित रूप से अनुशंसा करते हैं कि आप जनरेटडाटासेट का उपयोग करें Xml के बजाय टाइल बनाने के लिए datasets.xml क्योंकि हाथ से:
    
    * जनगणना Xml सेकंड में काम करता है। इसे हाथ से करना कम से कम एक घंटे का काम है, यहां तक कि जब आप जानते हैं कि आप क्या कर रहे हैं।
    * जनगणना Xml बेहतर काम करता है। इसे हाथ से करने के लिए व्यापक ज्ञान की आवश्यकता है कि कैसे ERDDAP™ कार्य यह संभावना नहीं है कि आप हाथ से बेहतर काम करेंगे। (बॉब सिमोन हमेशा जेनरेटडाटासेट का उपयोग करता है पहले ड्राफ्ट के लिए Xml, और उन्होंने लिखा ERDDAP ।) 
    * जनगणना Xml हमेशा का एक वैध हिस्सा उत्पन्न करता है datasets.xml । का कोई भी हिस्सा datasets.xml यदि आप लिखते हैं तो शायद कम से कम कुछ त्रुटियां होंगी जो रोकती हैं ERDDAP™ डेटासेट लोड करने से। अक्सर इन समस्याओं का निदान करने के लिए लोगों को घंटे लगते हैं। अपना समय बर्बाद मत करो। जनरेट करना डेटासेट Xml कड़ी मेहनत करते हैं। फिर अगर आप चाहते हैं तो आप हाथ से .xml को परिष्कृत कर सकते हैं।
    
जब आप GenerateDatasets का उपयोग करते हैं Xml कार्यक्रम:
    
    * विंडोज पर, पहली बार जब आप GenerateDatasetsXml चलाते हैं, तो आपको जावा के रास्ते को बदलने के लिए टेक्स्ट एडिटर के साथ GenerateDatasetsXml.bat फ़ाइल को संपादित करना होगा। इसलिए विंडोज को मिल सकता है Java ।
    * जनगणना Xml पहले आपको EDDtype निर्दिष्ट करने के लिए कहता है (Erd Dap Dataset प्रकार) डेटासेट का। देखें [डेटासेट प्रकार की सूची](#list-of-types-datasets)   (इस दस्तावेज़ में) यह पता लगाने के लिए कि आप किस डेटासेट के लिए उपयुक्त हैं। नियमित EDDtypes के अलावा, कुछ भी हैं [विशेष/Pseudo Dataset प्रकार](#specialpseudo-dataset-types)   (उदाहरण के लिए, जो एक THREDDS कैटलॉग को क्रॉल करता है, का एक हिस्सा उत्पन्न करने के लिए datasets.xml कैटलॉग में प्रत्येक डेटासेट के लिए) ।
    * जनगणना तब Xml आपको उस EDDtype के लिए विशिष्ट प्रश्नों की एक श्रृंखला पूछता है। प्रश्नों के लिए आवश्यक जानकारी इकट्ठा ERDDAP™ डेटासेट के स्रोत तक पहुंचने के लिए। क्या समझने के लिए ERDDAP™ इसके लिए पूछ रहा है, EDDtype के लिए प्रलेखन देखें जिसे आप उसी डेटासेट प्रकार पर क्लिक करके निर्दिष्ट करते हैं। [डेटासेट प्रकार की सूची](#list-of-types-datasets) ।
        
यदि आपको विशेष वर्णों के साथ स्ट्रिंग में प्रवेश करने की आवश्यकता है (उदाहरण के लिए, शुरुआत या अंत में व्हाइटस्पेस वर्ण, गैर-ASCII वर्ण) , दर्ज करें [JSON-style स्ट्रिंग](https://www.json.org/json-en.html)   (विशेष पात्रों के साथ बच) । उदाहरण के लिए, सिर्फ एक टैब चरित्र में प्रवेश करने के लिए, "\t" (बाद के डबल उद्धरणों के साथ, जो बताते हैं) में प्रवेश करें ERDDAP™ यह एक JSON-शैली स्ट्रिंग है।
        
    * अक्सर, आपके उत्तरों में से एक यह नहीं होगा कि क्या GenerateDatasetsXml की जरूरत है। फिर आप फिर से कोशिश कर सकते हैं, प्रश्नों के संशोधित उत्तर के साथ, जब तक GenerateDatasets XML सफलतापूर्वक स्रोत डेटा को ढूंढ सकता है और समझ सकता है।
    * यदि आप प्रश्नों का सही उत्तर देते हैं (सही ढंग से) जेनरेट डाटासेट Xml डेटासेट के स्रोत से जुड़ जाएगा और बुनियादी जानकारी इकट्ठा करेगा (उदाहरण के लिए, चर नाम और मेटाडाटा) ।
डेटासेट के लिए जो स्थानीय से हैं NetCDF   .nc संबंधित फाइलें, जनरेटडाटासेट Xml अक्सर फ़ाइल की ncdump-like संरचना को प्रिंट करेगा जब यह पहली बार फ़ाइल पढ़ता है। यह आपको जेनरेटडासेटएक्सएमएल के माध्यम से बाद के लूप पर बेहतर सवालों का जवाब देने के लिए जानकारी दे सकता है।
    * जनगणना इसके बाद XML उस डेटासेट के लिए डेटासेट XML का एक मोटे ड्राफ्ट उत्पन्न करेगा।
    * नैदानिक जानकारी और डेटासेट XML के मोटे ड्राफ्ट को लिखा जाएगा *बड़ाParentDirectory* /logs/GenerateDatasetsXml.log.
    * Dataset XML के मोटे ड्राफ्ट को लिखा जाएगा *बड़ाParentDirectory* /logs/GenerateDatasetsXml.out.
#### "0 फाइलें" त्रुटि संदेश{#0-files-error-message} 
यदि आप जेनरेटडेटासेट चलाते हैं Xml [दास](#dasdds) , या यदि आप लोड करने की कोशिश करते हैं EDDGrid from...Files or EDDTableFrom. में फ़ाइलें डेटासेट ERDDAP™ , और आपको "0 फाइलें" त्रुटि संदेश मिलता है जो दर्शाता है कि ERDDAP™ निर्देशिका में 0 मिलान फ़ाइलों को पाया (जब आपको लगता है कि उस निर्देशिका में फ़ाइलों को मिलान करना है) :
* जाँच करें कि आपने निर्देशिका का पूरा नाम निर्दिष्ट किया है। यदि आपने नमूना फ़ाइल नाम निर्दिष्ट किया है, तो सुनिश्चित करें कि आपने फ़ाइल का पूरा नाम निर्दिष्ट किया है, जिसमें पूर्ण निर्देशिका नाम शामिल है।
* जाँच करें कि वास्तव में फ़ाइलें उस निर्देशिका में हैं।
* निर्देशिका नाम की वर्तनी की जाँच करें।
* फ़ाइल NameRegex की जाँच करें। वास्तव में, वास्तव में regexes के साथ गलतियों को करना आसान है। परीक्षण प्रयोजनों के लिए, रेगेक्स की कोशिश करें। (इसे देखें [रेगेक्स प्रलेखन](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html) और [Regex ट्यूटोरियल](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html) ।) 
* जांचें कि वह उपयोगकर्ता जो प्रोग्राम चला रहा है (उदाहरण के लिए, उपयोगकर्ता=tomcat (?) टॉमकैट के लिए ERDDAP ) उन फ़ाइलों के लिए 'रीड' अनुमति है।
* कुछ ऑपरेटिंग सिस्टम में (उदाहरण के लिए, SELinux) और सिस्टम सेटिंग्स के आधार पर, जो उपयोगकर्ता ने कार्यक्रम को चलाने के लिए फ़ाइलों की निर्देशिका के लिए अग्रणी डायरेक्टरी की पूरी श्रृंखला के लिए 'रीड' अनुमति होनी चाहिए।


* यदि आपको कोई समस्या है तो आप हल नहीं कर सकते, [अनुरोध समर्थन](/docs/intro#support) जितना संभव हो उतना जानकारी के साथ। इसी तरह, अगर ऐसा लगता है कि किसी दिए गए डेटासेट के लिए उपयुक्त EDDटाइप उस डेटासेट के साथ काम नहीं करता है, या यदि कोई उपयुक्त EDD टाइप नहीं है, तो कृपया फ़ाइल करें [गिटहब पर जारी](https://github.com/ERDDAP/erddap/issues) विवरण के साथ (यदि प्रासंगिक हो तो नमूना फ़ाइल) ।
         
#### आपको जेनरेटडाटासेट से आउटपुट संपादित करने की आवश्यकता है Xml इसे बेहतर बनाने के लिए।{#you-need-to-edit-the-output-from-generatedatasetsxml-to-make-it-better} 
         
* अस्वीकरण:
का CHUNK datasets.xml MADE BE GenerateDatasets Xml ISN't perfect। आप एक सार्वजनिक में इसे इस्तेमाल करने से पहले XML को पढ़ें और संपादित करें ERDDAP । जनगणना Xml RELIES ON a LOT of RULES-OF-THUMB WHICH AREN'T ALWAYS CORRECT. आप XML के भ्रष्टाचार को बढ़ाने के लिए उत्तरदायी हैं, जिन्हें आप जोड़ना चाहते हैं। ERDDAP एस datasets.xml फ़ाइल
    
     (मज़ा तथ्य: मैं चिल्ला रही नहीं हूँ। ऐतिहासिक कानूनी कारणों के लिए, सभी कैप्स में अस्वीकरण लिखा जाना चाहिए।) 
    
GenerateDatasetsXml का उत्पादन एक मोटे ड्राफ्ट है।
आपको हमेशा इसे संपादित करने की आवश्यकता होगी।
हमने बनाया है और आउटपुट को तैयार करने के लिए एक बड़ा प्रयास किया है, लेकिन सीमाएँ हैं। अक्सर, आवश्यक जानकारी केवल स्रोत मेटाडाटा से उपलब्ध नहीं है।
    
एक मूलभूत समस्या यह है कि हम कंप्यूटर प्रोग्राम कह रहे हैं (जनरेट DatasetXml) यदि आपने 100 लोगों को समान कार्य दिया है तो आपको 100 अलग-अलग परिणाम मिलेंगे। कोई भी "right" उत्तर नहीं है। जाहिर है, कार्यक्रम बॉब के दिमाग को पढ़ने के करीब आता है (नहीं) लेकिन फिर भी, यह एक ऑल-अंडरस्टैंडिंग एआई प्रोग्राम नहीं है, सिर्फ एक गुच्छा हेरिस्टिक्स ने एआई-जैसे कार्य करने के लिए मिलकर काम किया। (उस दिन एक ऑल-अंडरस्टैंडिंग एआई प्रोग्राम आ सकता है, लेकिन यह अभी तक नहीं है। अगर यह करता है तो हम मनुष्य की बड़ी समस्याएं हो सकती हैं। क्या आप चाहते हैं?) 
    
* सूचनात्मक उद्देश्यों के लिए, आउटपुट वैश्विक स्रोत को दर्शाता हैAttributes और चर स्रोतAttributes टिप्पणियों के रूप में। ERDDAP™ SourceAttributes को जोड़ती है और addAttributes   (जो पूर्ववर्ती है) संयुक्त बनाने के लिए उन योगदानों को जो उपयोगकर्ता को दिखाए जाते हैं। (और अन्य विशेषताओं को स्वचालित रूप से लम्बाई, अक्षांश, ऊंचाई, गहराई और समय चर में जोड़ा जाता है जब ERDDAP™ वास्तव में डेटासेट बनाता है) ।
     
* यदि आप स्रोत को पसंद नहीं करते हैंविशेषण, इसे एक addAttribute जोड़कर ओवरराइट करेंएक ही नाम के साथ लेकिन एक अलग मूल्य (यदि आप इसे हटाना चाहते हैं, तो कोई मूल्य नहीं है) ।
     
* सभी addAttributes कंप्यूटर-generated सुझाव हैं। उन्हें संपादित करें&#33; यदि आप एक addAttribute पसंद नहीं करते हैं, तो इसे बदल दें।
     
* यदि आप अन्य जोड़ना चाहते हैं addAttributes उन्हें जोड़ें।
     
* यदि आप बदलाव करना चाहते हैं destinationName इसे बदल दें। लेकिन नहीं बदलता sourceName S.
     
* आप क्रम बदल सकते हैं dataVariable उनमें से किसी को भी हटा दें।


    * तब आप उपयोग कर सकते हैं [दास](#dasdds)   (नीचे देखें) उस डेटासेट के लिए XML को बार-बार परीक्षण करने के लिए यह सुनिश्चित करने के लिए कि परिणामी डेटासेट दिखाई देता है जैसा कि आप चाहते हैं कि यह क्या है ERDDAP ।
    * छोटे बदलाव करने के लिए स्वतंत्र महसूस करें datasets.xml उदाहरण के लिए, उत्पन्न होने वाले हिस्से को बेहतर आपूर्ति करना infoUrl , सारांश, या शीर्षक।
#### DonotAdd StandardNames{#donotaddstandardnames} 
यदि आप \\-doNotAdd StandardNames को एक कमांड लाइन पैरामीटर के रूप में शामिल करते हैं जब आप उत्पन्न होते हैं डेटासेट XML उत्पन्न डेटासेट एक्सएमएल नहीं जोड़ेगा standard\\_name to addAttributes किसी भी वैरिएबल के अलावा अन्य वैरिएबल्स के नाम पर अक्षांश, देशांतर, ऊंचाई, गहराई या समय (जो स्पष्ट है standard\\_name s) । यदि आप उत्पन्न होने से आउटपुट का उपयोग कर रहे हैं तो यह उपयोगी हो सकता है डेटासेट सीधे XML ERDDAP™ उत्पादन को संपादित किए बिना, क्योंकि उत्पन्न डेटासेट Xml अक्सर अनुमान लगाता है standard\\_name Incorrectly. (ध्यान दें कि हम हमेशा अनुशंसा करते हैं कि आप इसका उपयोग करने से पहले आउटपुट संपादित करें ERDDAP ।) इस पैरामीटर का उपयोग अन्य मामूली संबंधित प्रभाव होगा क्योंकि अनुमान लगाया गया है standard\\_name अक्सर अन्य प्रयोजनों के लिए उपयोग किया जाता है, उदाहरण के लिए, एक नया बनाने के लिए long\\_name , और रंगबार सेटिंग्स बनाने के लिए।
#### स्क्रिप्टिंग{#scripting} 
कीबोर्ड पर इंटरैक्टिव प्रश्नों का जवाब देने और अतिरिक्त डेटासेट उत्पन्न करने के लिए लूपिंग के विकल्प के रूप में, आप एक डेटासेट उत्पन्न करने के लिए सभी सवालों का जवाब देने के लिए कमांड लाइन तर्क प्रदान कर सकते हैं। जनगणना Xml उन मापदंडों को संसाधित करेगा, आउटपुट फ़ाइल में आउटपुट लिखें, और कार्यक्रम से बाहर निकलें।
        
इसे स्थापित करने के लिए, पहले इंटरैक्टिव मोड में प्रोग्राम का उपयोग करें और अपना जवाब नीचे लिखें। यहाँ एक आंशिक उदाहरण है:
चलो कहते हैं कि आप स्क्रिप्ट चलाते हैं:
फिर प्रवेश करें: EDDTableFromAsciiFiles
फिर दर्ज करें: /u00/data/
फिर प्रवेश करें: .\\\\\sc
फिर दर्ज करें: /u00/data/sampleFile.asc
फिर प्रवेश करें: ISO-8859-1
        
इसे गैर-इंटरएक्टिव तरीके से चलाने के लिए, इस कमांड लाइन का उपयोग करें:
./GenerateDatasetsXml.sh EDDTableFromAsciiFiles /u00/data/.\\\\.asc/u00/data/sampleFile.asc ISO-8859-1
इसलिए मूल रूप से, आप कमांड लाइन पर सभी उत्तरों को सूचीबद्ध करते हैं।
यह डेटासेट के लिए उपयोगी होना चाहिए जो अक्सर ऐसे तरीके से बदल जाता है जो फिर से चल रहे डेटा जेनरेटसेट्स की आवश्यकता होती है। एक्सएमएल (वास्तव में EDDGrid FromThreddsCatalog) ।
        
विवरण:

* यदि किसी पैरामीटर में एक स्पेस या कुछ विशेष चरित्र होता है, तो पैरामीटर को एक के रूप में एन्कोड करें [JSON-style स्ट्रिंग](https://www.json.org/json-en.html) , उदाहरण के लिए, "स्पेस और दो के साथ मेरा पैरामीटर \\n रेखाएं
* यदि आप एक पैरामीटर के रूप में एक खाली स्ट्रिंग निर्दिष्ट करना चाहते हैं, तो उपयोग करें: कुछ भी नहीं
* यदि आप किसी पैरामीटर के डिफ़ॉल्ट मान को निर्दिष्ट करना चाहते हैं, तो इसका उपयोग करें: डिफ़ॉल्ट
             
* जनगणना Xml -i का समर्थन करता है *डेटासेट XmlName* # *टैगनाम* कमांड लाइन पैरामीटर जो निर्दिष्ट में आउटपुट को सम्मिलित करता है datasets.xml फ़ाइल (डिफ़ॉल्ट है *tomcat* /content/erddap/ datasets.xml ) । जनगणना Xml डेटासेट में दो लाइनों के लिए लग रहा है XmlName:
```
        <!-- Begin GenerateDatasetsXml #*tagName someDatetime* -->  
```
और
```
        <!-- End GenerateDatasetsXml #*tagName someDatetime* -->  
```
और नई सामग्री के साथ उन पंक्तियों के बीच सब कुछ बदल देता है, और कुछ समय बदलता है।
* -i स्विच केवल संसाधित है (और परिवर्तन datasets.xml केवल बनाया गया है) यदि आप जेनरेटडेटासेट चलाते हैं Xml कमांड लाइन तर्क के साथ जो प्रोग्राम के एक लूप के लिए सभी सवालों के जवाब निर्दिष्ट करते हैं। (ऊपर 'Scripting' देखें।)   (यह सोच है: यह पैरामीटर स्क्रिप्ट के साथ उपयोग के लिए है। यदि आप इंटरैक्टिव मोड में प्रोग्राम का उपयोग करते हैं (कीबोर्ड पर टाइपिंग जानकारी) इससे पहले कि आप चाहते हैं, आपको XML के कुछ गलत हिस्से उत्पन्न करने की संभावना है।) 
* यदि शुरुआती और अंत रेखाएं नहीं पाई जाती हैं, तो उन रेखाओं और नई सामग्री को ठीक पहले डाला जाता है&lt;/erddapDatasets&gt;।
* -I भी (पूंजी i) परीक्षण उद्देश्यों के लिए स्विच करें जो -i के समान काम करता है, लेकिन एक फ़ाइल बनाता है जिसे बुलाया जाता है datasets.xml  *समय* नहीं बदलता datasets.xml ।
* जेनरेटडाटासेट एक ही बार में दो प्रक्रियाओं में Xml -i के साथ। वहाँ परिवर्तन का केवल एक सेट रखा जाएगा एक मौका है। गंभीर परेशानी हो सकती है (उदाहरण के लिए, भ्रष्ट फ़ाइलों) ।
    
यदि आप "GenerateDatasetsXml -verbose" का उपयोग करते हैं, तो यह सामान्य से अधिक नैदानिक संदेशों को प्रिंट करेगा।
    
#### विशेष/Pseudo Dataset प्रकार{#specialpseudo-dataset-types} 
सामान्य तौर पर, EDDType में विकल्प GenerateDatasets इस दस्तावेज़ में वर्णित EDD प्रकारों का Xml मैच (देखें [डेटासेट प्रकार की सूची](#list-of-types-datasets) ) उत्पन्न करना datasets.xml एक विशिष्ट डेटा स्रोत से एक डेटासेट बनाने के लिए भाग लें। कुछ अपवाद और विशेष मामले हैं:
    
#####  EDDGrid सेंध{#eddgridfromerddap} 
यह EDDType सभी उत्पन्न करता है datasets.xml बनाने के लिए आवश्यक भाग [ EDDGrid सेंध](#eddfromerddap) सभी से डेटासेट EDDGrid दूरस्थ में डेटासेट ERDDAP । आपके पास मूल रखने का विकल्प होगा datasetID s (जो कुछ डुप्लिकेट कर सकता है datasetID पहले से ही अपने में ERDDAP ) या नए नाम पैदा करना जो अद्वितीय होगा (लेकिन आम तौर पर मानव पठनीय नहीं हैं) ।
     
##### EDDTableFromErddap{#eddtablefromerddap} 
यह EDDType सभी उत्पन्न करता है datasets.xml बनाने के लिए आवश्यक भाग [EDDTableFromErddap](#eddfromerddap) दूरस्थ में सभी EDDTable डेटासेट से डेटासेट ERDDAP । आपके पास मूल रखने का विकल्प होगा datasetID s (जो कुछ डुप्लिकेट कर सकता है datasetID पहले से ही अपने में ERDDAP ) या नए नाम पैदा करना जो अद्वितीय होगा (लेकिन आम तौर पर मानव पठनीय नहीं हैं) ।
     
#####  EDDGrid FromThreddsCatalog{#eddgridfromthreddscatalog} 
यह EDDType सभी उत्पन्न करता है datasets.xml सभी के लिए जरूरत पड़ने वाले हिस्से [ EDDGrid FromDap](#eddgridfromdap) डेटासेट जो इसे एक THREDDS के माध्यम से तेजी से क्रॉलिंग द्वारा खोज सकते हैं (उप) सूची THREDDS कैटलॉग URL के कई रूप हैं। यह विकल्प उदाहरण के लिए, इसमें / कैटलॉग के साथ एक THREDDS .xml URL की आवश्यकता है।
https://oceanwatch.pfeg.noaa.gov/thredds/catalog/catalog.xmlया
https://oceanwatch.pfeg.noaa.gov/thredds/catalog/Satellite/aggregsatMH/chla/catalog.xml  
(a related) HTML catalog is at
https://oceanwatch.pfeg.noaa.gov/thredds/Satellite/aggregsatMH/chla/catalog.htmlजिसके लिए स्वीकार्य नहीं है EDDGrid FromThreddsCatalog).
यदि आपके पास समस्या है EDDGrid सेथरेड कैटलॉग:
* सुनिश्चित करें कि आप जिस URL का उपयोग कर रहे हैं वह मान्य है, इसमें /catalog/, और /catalog.xml के साथ समाप्त होता है।
* यदि संभव हो, तो सार्वजनिक आईपी पते का उपयोग करें (उदाहरण के लिए,https://oceanwatch.pfeg.noaa.gov) यूआरएल में, एक स्थानीय संख्यात्मक आईपी पता नहीं (उदाहरण के लिए,https://12.34.56.78) । यदि THREDDS केवल स्थानीय संख्यात्मक IP पते के माध्यम से सुलभ है, तो आप उपयोग कर सकते हैं [&lt;ConvertTopublicSourceUrl&gt; (#converttopublicsourceurl) इसलिए ERDDAP™ हालांकि, उपयोगकर्ता सार्वजनिक पते को देखते हैं ERDDAP™ स्थानीय संख्यात्मक पते से डेटा प्राप्त होता है।
* यदि आपको कोई समस्या है तो आप हल नहीं कर सकते, [समस्या निवारण युक्तियाँ की जाँच करें](#troubleshooting-tips) ।
* इसके लिए निम्न स्तर कोड अब उपयोग करता है Unidata Netcdf-java catalog क्रॉलर कोड (थर्ड सूची वर्ग) ताकि यह सभी THREDDS कैटलॉग को संभाल सके (जो आश्चर्यजनक रूप से जटिल हो सकता है) धन्यवाद Unidata उस कोड के लिए।
         
#####  EDDGrid LonPM180FromErddapCatalog{#eddgridlonpm180fromerddapcatalog} 
यह EDDtype उत्पन्न करता है datasets.xml बनाना [ EDDGrid LonPM180](#eddgridlonpm180) सभी से डेटासेट EDDGrid एक में डेटासेट ERDDAP इसमें 180 से अधिक लम्बाई मान होते हैं।
* यदि संभव हो, तो सार्वजनिक आईपी पते का उपयोग करें (उदाहरण के लिए,https://oceanwatch.pfeg.noaa.gov) यूआरएल में, एक स्थानीय संख्यात्मक आईपी पता नहीं (उदाहरण के लिए,https://12.34.56.78) । यदि ERDDAP™ केवल स्थानीय संख्यात्मक आईपी पते के माध्यम से सुलभ है, आप उपयोग कर सकते हैं [&lt;ConvertTopublicSourceUrl&gt; (#converttopublicsourceurl) इसलिए ERDDAP™ हालांकि, उपयोगकर्ता सार्वजनिक पते को देखते हैं ERDDAP™ स्थानीय संख्यात्मक पते से डेटा प्राप्त होता है।
         
#####  EDDGrid Lon0360FromErddapCatalog{#eddgridlon0360fromerddapcatalog} 
यह EDDtype उत्पन्न करता है datasets.xml बनाना [ EDDGrid Lon0360](#eddgridlon0360) सभी से डेटासेट EDDGrid एक में डेटासेट ERDDAP 0 से कम किसी भी देशांतर मान है।
* यदि संभव हो, तो सार्वजनिक आईपी पते का उपयोग करें (उदाहरण के लिए,https://oceanwatch.pfeg.noaa.gov) यूआरएल में, एक स्थानीय संख्यात्मक आईपी पता नहीं (उदाहरण के लिए,https://12.34.56.78) । यदि ERDDAP™ केवल स्थानीय संख्यात्मक आईपी पते के माध्यम से सुलभ है, आप उपयोग कर सकते हैं [&lt;ConvertTopublicSourceUrl&gt; (#converttopublicsourceurl) इसलिए ERDDAP™ हालांकि, उपयोगकर्ता सार्वजनिक पते को देखते हैं ERDDAP™ स्थानीय संख्यात्मक पते से डेटा प्राप्त होता है।
         
##### EDDsFromFiles{#eddsfromfiles} 
एक प्रारंभ निर्देशिका को देखते हुए, यह निर्देशिका और सभी उपनिर्देशों को विकृत करता है और डेटा फ़ाइलों के प्रत्येक समूह के लिए डेटासेट बनाने की कोशिश करता है जो इसे पाता है।
* यह मान लेता है कि जब डेटासेट पाया जाता है, तो डेटासेट में सभी उपनिर्देश शामिल हैं।
* यदि डेटासेट पाया जाता है, तो समान भाई-बहन निर्देशिकाओं को अलग-अलग डेटासेट के रूप में माना जाएगा। (उदाहरण के लिए, 1990 के दशक के लिए निर्देशिका, 2000 के, 2010 के, अलग डेटासेट उत्पन्न करेगा) । उन्हें हाथ से गठबंधन करना आसान होना चाहिए - बस पहले डेटासेट को बदल दें&lt;फ़ाइलDir&gt; माता-पिता निर्देशिका में और बाद में सभी भाई-बहन डेटासेट को हटा दें।
* यह केवल का एक हिस्सा उत्पन्न करने की कोशिश करेगा datasets.xml एक निर्देशिका में फ़ाइल एक्सटेंशन के सबसे आम प्रकार के लिए (.md5 की गिनती नहीं, जिसे अनदेखा किया गया है) । तो, 10 के साथ एक निर्देशिका दी .nc फ़ाइलों और 5 .txt फ़ाइलों के लिए एक डेटासेट उत्पन्न किया जाएगा .nc केवल फ़ाइलें।
* यह मानता है कि एक ही एक्सटेंशन के साथ निर्देशिका में सभी फाइलें समान डेटासेट से संबंधित हैं। यदि किसी निर्देशिका में कुछ है .nc SST डेटा और कुछ के साथ फ़ाइलों .nc क्लोरोफिल डेटा के साथ फाइलें, सिर्फ एक नमूना .nc फ़ाइल को पढ़ा जाएगा (SST? क्लोरोफिल?) और सिर्फ एक डेटासेट उस प्रकार की फ़ाइल के लिए बनाया जाएगा। यह डेटासेट शायद एक ही डेटासेट में दो प्रकार की फ़ाइलों को लोड करने की कोशिश करने की जटिलताओं के कारण लोड हो सकता है।
* यदि निर्देशिका में सबसे आम विस्तार के साथ 4 से अधिक फाइलें हैं, तो यह मान लेता है कि वे डेटा फाइलें नहीं हैं और सिर्फ निर्देशिका छोड़ते हैं।
* यदि निर्देशिका में 4 या अधिक फाइलें हैं, लेकिन यह सफलतापूर्वक एक हिस्सा उत्पन्न नहीं कर सकता है datasets.xml फ़ाइलों के लिए (उदाहरण के लिए, एक असमर्थित फ़ाइल प्रकार) यह उत्पन्न करेगा [EDDTableFromFileNames](#eddtablefromfilenames) फ़ाइलों के लिए डेटासेट।
* निदान के अंत में यह लॉग फ़ाइल में लिखा गया है, ठीक पहले datasets.xml यह सभी उपनिर्देशों को पार करके एकत्रित सूचना के सारांश के साथ एक तालिका मुद्रित करेगा। तालिका प्रत्येक उपनिर्देशिका को सूचीबद्ध करेगी और सबसे आम प्रकार की फ़ाइल एक्सटेंशन, कुल संख्या फ़ाइलों को इंगित करेगी, और इन फ़ाइलों के लिए किस प्रकार का डेटासेट बनाया गया था। (यदि कोई हो) । यदि आप एक जटिल, गहराई से घोंसले वाली फ़ाइल संरचना का सामना कर रहे हैं, तो चल रहे GenerateDatasets पर विचार करें EDDtype=EDDsFromFiles के साथ Xml सिर्फ इस जानकारी उत्पन्न करने के लिए,
* यह विकल्प डेटा फ़ाइलों के किसी दिए गए समूह के लिए सर्वश्रेष्ठ EDDtype का अनुमान लगाने का एक बड़ा काम नहीं कर सकता है, लेकिन यह त्वरित, आसान और एक कोशिश के लायक है। यदि स्रोत फाइलें उपयुक्त हैं, तो यह अच्छी तरह से काम करता है और यह एक अच्छा पहला कदम है जो इसे उत्पन्न करता है। datasets.xml बहुत सारे उपनिर्देशों के साथ एक फ़ाइल सिस्टम के लिए, प्रत्येक अलग डेटासेट से डेटा फ़ाइलों के साथ।
         
##### EDDTableFromEML और EDDTableFromEMLBatch{#eddtablefromeml-and-eddtablefromemlbatch} 
ये विशेष EDDType उत्पन्न करता है datasets.xml बनाना [EDDTableFromAsciiFiles](#eddtablefromasciifiles) प्रत्येक तालिका से डेटासेट एक में वर्णित है [पारिस्थितिक मेटाडाटा भाषा](https://knb.ecoinformatics.org/external//emlparser/docs/index.html) XML फ़ाइल "बैच" संस्करण स्थानीय या दूरस्थ निर्देशिका में सभी EML फ़ाइलों पर काम करता है। कृपया अलग देखें [EDDTableFromEML के लिए प्रलेखन](/docs/server-admin/EDDTableFromEML) ।
     
##### EDDTableFromInPort{#eddtablefrominport} 
यह विशेष EDDtype उत्पन्न करता है datasets.xml बनाना [EDDTableFromAsciiFiles](#eddtablefromasciifiles) सूचना से डेटासेट [Inport-xml](https://inport.nmfs.noaa.gov/inport) फ़ाइल यदि आप स्रोत डेटा फ़ाइल तक पहुंच सकते हैं (इनपोर्ट-xml फ़ाइल में clues होना चाहिए जहां इसे खोजने के लिए) , आप एक कामकाजी डेटासेट बना सकते हैं ERDDAP ।

निम्नलिखित चरणों में बताया गया है कि कैसे GenerateDatasets का उपयोग करने के लिए Xml एक inport-xml फ़ाइल के साथ आदेश में एक कार्य डेटासेट प्राप्त करने के लिए ERDDAP ।

1. एक बार जब आपके पास इनपोर्ट-xml फ़ाइल तक पहुंच होती है (या तो एक यूआरएल या एक स्थानीय फ़ाइल के रूप में) : run GenerateDatasets Xml, EDDtype=EDDTableFromInPort निर्दिष्ट करें, inport-xml URL या पूर्ण फ़ाइल नाम निर्दिष्ट करें, जो निर्दिष्ट करेंChild=0, और अन्य अनुरोधित जानकारी निर्दिष्ट करें (यदि ज्ञात हो) । (इस बिंदु पर, आपको स्रोत डेटा फ़ाइल रखने या उसका नाम निर्दिष्ट करने की आवश्यकता नहीं है।) जोChild=0 सेटिंग जनरेटडाटासेट बताती है XML के लिए जानकारी लिखने के लिए **सब** (d)&lt;इकाई-attribute-information&gt;&lt;Inport-xml file (यदि कोई हो) । यह एक पृष्ठभूमि सूचना सारांश को भी प्रिंट करता है, जिसमें सभी डाउनलोड-url को इनपोर्ट-xml फ़ाइल में सूचीबद्ध किया गया है।
2. सभी जानकारी के माध्यम से देखें (पृष्ठभूमि जानकारी है कि GenerateDatasets सहित XML प्रिंट) और डाउनलोड-url पर जाएं (s) स्रोत डेटा फ़ाइल खोजने की कोशिश करने के लिए (s) । यदि आप इसे पा सकते हैं (उन्हें) इसे डाउनलोड करें (उन्हें) एक निर्देशिका में जो सुलभ है ERDDAP । (यदि आप किसी भी स्रोत डेटा फ़ाइलों को नहीं पा सकते हैं, तो कार्यवाही में कोई बिंदु नहीं है।) 
3. रन जेनरेट डेटासेट फिर से XML।
यदि स्रोत डेटा फ़ाइल इनपोर्ट-xml फ़ाइल के एक से मेल खाती है&lt;इकाई-attribute-information&gt;&lt;इकाई&gt;'s, निर्दिष्ट करें जोChild= *thatEntity'sNumber*   (उदाहरण के लिए, 1, 2, 3, ...) । ERDDAP™ इकाई की जानकारी में नामों के लिए स्रोत डेटा फ़ाइल में कॉलम नामों से मिलान करने की कोशिश करेंगे और किसी भी असंतुष्टता को स्वीकार / अस्वीकार / निर्धारित करने के लिए प्रेरित करेंगे।
या, अगर इनपोर्ट-xml फ़ाइल में कोई नहीं है&lt;इकाई-attribute-information&gt;&lt;इकाई&gt;'s, निर्दिष्ट करें जोChild=0.
4. के भाग में datasets.xml इसे जेनरेटडाटासेट द्वारा बनाया गया था Xml, revise [global]&lt; addAttributes &gt; (#Global-attributes) जैसा कि आवश्यक/वांछनीय है।
5. के भाग में datasets.xml that was made by GenerateDatasetsXml, add/revise.&lt; dataVariable &gt; (#datavariable) प्रत्येक चर का वर्णन करने के लिए आवश्यक/वांछनीय जानकारी। सुनिश्चित करें कि आप प्रत्येक चर की सही पहचान करें
[&lt; sourceName &gt; (#sourcename)   (जैसा कि यह स्रोत में दिखाई देता है) ,
[&lt; destinationName &gt; (#Destinationname)   (जिसकी तुलना में अनुमत वर्णों पर अधिक सीमाएं हैं sourceName ) ,
[&lt;यूनिट&gt; (#units)   (विशेष रूप से अगर यह है [समय या समय-समय परिवर्तनशील](#timestamp-variables) जहां इकाइयों को प्रारूप निर्दिष्ट करने की आवश्यकता होती है) , और
[&lt; missing\\_value &gt; (#missing_value) ,
6. जब आप खत्म हो जाते हैं, तो बार-बार उपयोग करें [दास](#dasdds) टूल को जल्दी से देखने के लिए कि क्या डेटासेट विवरण मान्य है और यदि डेटासेट में दिखाई देगा ERDDAP™ जैसा कि आप चाहते हैं।
     

अगर इनपोर्ट का उपयोग करने वाले समूह अपने डेटासेट को दस्तावेज करने के लिए भी उपयोग करेंगे तो यह बहुत अच्छा होगा। ERDDAP™ वास्तविक डेटा उपलब्ध कराने के लिए:

*    ERDDAP™ एक ऐसा समाधान है जिसका इस्तेमाल अभी किया जा सकता है ताकि आप पूरा कर सकें NOAA ' [अनुसंधान परिणाम (PARR) आवश्यकताएं](https://nosc.noaa.gov/EDMC/PD.DSP.php) अभी नहीं, भविष्य में कुछ अस्पष्ट समय पर।
*    ERDDAP™ उपयोगकर्ताओं के लिए उपलब्ध वास्तविक डेटा बनाता है, न केवल मेटाडाटा। (डेटा के बिना मेटाडाटा क्या अच्छा है?) 
*    ERDDAP™ मेटाडाटा का समर्थन (विशेष रूप से, चर की इकाइयां) , कुछ अन्य डेटा सर्वर सॉफ्टवेयर के विपरीत माना जाता है। (मेटाडाटा के बिना डेटा क्या अच्छा है?) सॉफ़्टवेयर का उपयोग करने के लिए जो मेटाडाटा का समर्थन नहीं करता है, डेटा को गलत तरीके से जोड़ने और दुरुपयोग करने के लिए आमंत्रित करना है।
*    ERDDAP™ कुछ अन्य सॉफ्टवेयरों के विपरीत मुक्त और खुला स्रोत सॉफ्टवेयर है। का विकास ERDDAP™ पहले से ही भुगतान किया जाता है। समर्थन ERDDAP™ उपयोगकर्ता मुफ्त है।
*    ERDDAP अपने समूह को प्रतिबिंबित करने और हाइलाइट करने के लिए आसानी से अनुकूलित किया जा सकता है (नहीं ERD या ERDDAP ) ।
*    ERDDAP™ सभी डेटासेट तक पहुंचने का एक सुसंगत तरीका प्रदान करता है।
*    ERDDAP™ कई प्रकार की डेटा फ़ाइलों और रिलेशनल डेटाबेस से डेटा पढ़ सकते हैं।
*    ERDDAP™ डेटासेट सहित बड़े डेटासेट से निपट सकते हैं जहां स्रोत डेटा कई डेटा फ़ाइलों में है।
*    ERDDAP™ कई प्रकार की डेटा फ़ाइलों को डेटा लिख सकते हैं, उपयोगकर्ता के अनुरोध पर, जिसमें नेटसीडीएफ, ईएसआरआई जैसे वैज्ञानिक डेटा फ़ाइल प्रकार शामिल हैं। ODV .txt ।
*    ERDDAP™ उपयोगकर्ता के विनिर्देशों के आधार पर डेटा के सबसेट के कस्टम ग्राफ और मानचित्र बना सकते हैं।
*    ERDDAP™ छवि, वीडियो या ऑडियो फ़ाइलों के संग्रह जैसे गैर-डाटा डेटासेट से निपट सकते हैं।
*    ERDDAP™ स्थापित किया गया है और इस्तेमाल किया गया है [दुनिया भर में 60 से अधिक संस्थान](/#who-uses-erddap) ।
*    ERDDAP™ भीतर उपयोग के लिए अनुशंसित डेटा सर्वरों में से एक के रूप में सूचीबद्ध किया गया है NOAA में [ NOAA डेटा एक्सेस प्रक्रियात्मक निर्देश](https://www.ngdc.noaa.gov/wiki/index.php/Data_Access_Technical_Recommendations#Software_implementations) , कुछ अन्य सॉफ्टवेयर के विपरीत माना जाता है।
*    ERDDAP™ का एक उत्पाद है NMFS / NOAA इसके भीतर उपयोग करना NMFS और NOAA के लिए गर्व का एक बिंदु होना चाहिए NMFS और NOAA ।

कृपया देना ERDDAP™ कोशिश करो। यदि आपको मदद की आवश्यकता है, तो कृपया एक संदेश पोस्ट करें ERDDAP™ गूगल समूह।
     
##### AddFillValueAttributes{#addfillvalueattributes} 
यह विशेष EDDType विकल्प एक डेटासेट प्रकार नहीं है। यह एक उपकरण है जो कुछ डेटासेट में कुछ चरों के लिए \\FillValue विशेषताओं को जोड़ सकता है। देखें [AddFillValueAttributes](#add-_fillvalue-attributes) ।
     
##### ढूँढना समय{#findduplicatetime} 
यह विशेष EDDType विकल्प एक डेटासेट प्रकार नहीं है। इसके बजाय, यह जनरेटडाटासेट बताता है Xml ग्रिड के एक संग्रह के माध्यम से खोज करने के लिए .nc   (संबंधित) फ़ाइलों को डुप्लिकेट समय मूल्यों के साथ फ़ाइलों की एक सूची खोजने और मुद्रित करने के लिए। जब यह समय मान को देखता है, तो यह उन्हें मूल इकाइयों से मूल इकाइयों में बदल देता है "seconds since 1970-01-01" यदि विभिन्न फ़ाइल विभिन्न इकाइयों स्ट्रिंग का उपयोग करती हैं। आपको प्रारंभिक निर्देशिका प्रदान करने की आवश्यकता है (साथ या पीछे slash के बिना) , फ़ाइल का नाम नियमित अभिव्यक्ति (उदाहरण: .nc  ) , और फ़ाइलों में समय चर का नाम।
     
##### एनसीडंप{#ncdump} 
यह विशेष EDDType विकल्प एक डेटासेट प्रकार नहीं है। इसके बजाय, यह जनरेटडाटासेट बताता है XML प्रिंट करने के लिए [एनसीडंप](https://linux.die.net/man/1/ncdump) एक की तरह printout .nc , .nc एमएल, या .hdf फ़ाइल यह वास्तव में netcdf-java का उपयोग करता है [एनसीडंप](https://docs.unidata.ucar.edu/netcdf-java/5.4/javadoc/ucar/nc2/write/Ncdump.html) , जो एनसीडंप के सी संस्करण की तुलना में अधिक सीमित उपकरण है। यदि आप इस विकल्प का उपयोग करते हैं, तो GenerateDatasetsXml आपको विकल्पों में से एक का उपयोग करने के लिए कहेंगे: "-h" (हेडर) , "सी" (vars समन्वय) , "vall" (डिफ़ॉल्ट) , "v var1; var2", "v var1" (0,0:10,0:20) "। यह उपयोगी है क्योंकि बिना एनसीडंप के यह जानना मुश्किल है कि क्या है? .nc , .nc एमएल, या .hdf फ़ाइल और इस प्रकार कौन से EDDType को आपको जनरेटडाटासेट के लिए निर्दिष्ट करना चाहिए एक्सएमएल एक के लिए .nc एमएल फ़ाइल, यह परिणाम के लिए ncdump आउटपुट प्रिंट करेगा .nc एमएल फ़ाइल परिवर्तन अंतर्निहित पर लागू .nc या .hdf फ़ाइल
         
### दास{#dasdds} 
*    [ **दास** ](#dasdds) एक कमांड लाइन प्रोग्राम है जिसे आप एक नए डेटासेट के लिए XML में पहला प्रयास बनाने के बाद उपयोग कर सकते हैं datasets.xml । DasDds के साथ, आप XML को बार-बार परीक्षण और परिष्कृत कर सकते हैं। जब आप DasDds कार्यक्रम का उपयोग करते हैं:
    1. विंडोज पर, पहली बार जब आप DasDds चलाते हैं, तो आपको DasDds को संपादित करने की आवश्यकता है। जावा को पथ बदलने के लिए पाठ संपादक के साथ बल्लेबाजी फ़ाइल। इसलिए विंडोज को मिल सकता है Java ।
    2. DasDds आप के लिए पूछता है datasetID डेटासेट के लिए आप काम कर रहे हैं।
    3. DasDds उस के साथ डेटासेट बनाने की कोशिश करता है datasetID ।
        * DasDds हमेशा बहुत सारे नैदानिक संदेशों को प्रिंट करता है।
यदि आप "DasDds -verbose" का उपयोग करते हैं, तो DasDds सामान्य से अधिक नैदानिक संदेशों को प्रिंट करेगा।
        * सुरक्षा के लिए, DasDd हमेशा सभी कैश डेटासेट जानकारी को हटा देता है (फ़ाइलें) डेटासेट बनाने से पहले डेटासेट के लिए। यह एक सेटिंग के बराबर है [कठोर झंडा](/docs/server-admin/additional-information#hard-flag) इसलिए समेकित डेटासेट के लिए, आप डेटा निर्माता को खोजने वाली फ़ाइलों की संख्या को सीमित करने के लिए अस्थायी रूप से फ़ाइलNameRegex को समायोजित करना चाहते हैं।
        * यदि डेटासेट लोड करने में विफल रहता है (किसी भी कारण के लिए) , DasDds रोक देंगे और आपको पहली त्रुटि के लिए त्रुटि संदेश दिखाएंगे जो इसे ढूंढता है।
             **क्या समस्या हो सकती है यह अनुमान लगाने की कोशिश मत करो। ध्यान से ERROR संदेश पढ़ें।**   
यदि आवश्यक हो, तो अधिक clues और जानकारी प्राप्त करने के लिए पूर्ववर्ती नैदानिक संदेशों को पढ़ें।
        *    **इस समस्या को हल करने की कोशिश करने के लिए डेटासेट के XML में बदलाव करें**   
और DasDds फिर से डेटासेट बनाने की कोशिश करते हैं।
        *    **यदि आप प्रत्येक समस्या को बार-बार हल करते हैं, तो आप अंततः सभी समस्याओं को हल करेंगे**   
और डेटासेट लोड हो जाएगा।
    4. सभी DasDds उत्पादन (निदान और परिणाम) स्क्रीन पर लिखा जाता है और *बड़ाParentDirectory* /logs/DasDds.log.
    5. यदि DasDds डेटासेट बना सकता है, तो DasDds आपको दिखाएंगे। [.das (डेटासेट विशेषता संरचना) ](https://coastwatch.pfeg.noaa.gov/erddap/griddap/documentation.html#fileType_das) , [.dds (Dataset Descriptor संरचना) ](https://coastwatch.pfeg.noaa.gov/erddap/griddap/documentation.html#fileType_dds) , और [टाइमगैप (समय अंतराल) ](https://coastwatch.pfeg.noaa.gov/erddap/griddap/documentation.html#timeGaps) अपनी स्क्रीन पर डेटासेट के लिए जानकारी और उन्हें लिखने के लिए *बड़ाParentDirectory* /logs/DasDds.out.
    6. अक्सर, आप डेटासेट के मेटाडाटा को साफ करने और DasDds को फिर से चलाने के लिए डेटासेट के XML में कुछ छोटा बदलाव करना चाहते हैं।

### बोनस तृतीय-पक्ष टूल: ERDDAP हिन्दी{#bonus-third-party-tool-erddap-lint} 
 ERDDAP -lint आयरिश मरीन इंस्टीट्यूट के रॉब फुलर और एडम लीडबेटर का एक कार्यक्रम है जिसका उपयोग आप अपने मेटाडाटा को बेहतर बनाने के लिए कर सकते हैं। ERDDAP™ डेटासेट ERDDAP -lint "contains नियमों और अपने खिलाफ कुछ सत्यापन परीक्षण चलाने के लिए एक सरल स्थिर वेब अनुप्रयोग ERDDAP™ सर्वर सभी परीक्षण वेब ब्राउज़र में चल रहे हैं। लाइक [यूनिक्स / लिनक्स लिंट टूल](https://en.wikipedia.org/wiki/Lint_(software) आप मौजूदा नियमों को संपादित कर सकते हैं या नए नियमों को जोड़ सकते हैं। देखें [ ERDDAP हिन्दी](https://github.com/IrishMarineInstitute/erddap-lint) अधिक जानकारी के लिए।

यह उपकरण विशेष रूप से डेटासेट के लिए उपयोगी है जिसे आपने कुछ समय पहले बनाया था और अब अपने वर्तमान मेटाडाटा वरीयताओं के साथ अप-टू-डेट लाना चाहते हैं। उदाहरण के लिए, जनरेटडाटासेट के शुरुआती संस्करण एक्सएमएल ने वैश्विक बनाने में कोई प्रयास नहीं किया creator\\_name , creator\\_email , निर्माता \\_type, या creator\\_url मेटाडाटा आप उपयोग कर सकते हैं ERDDAP उन मेटाडाटा विशेषताओं की कमी वाले डेटासेट की पहचान करने के लिए -lint।

इस उपकरण को बनाने और इसे उपलब्ध कराने के लिए रोब और एडम के लिए धन्यवाद ERDDAP™ समुदाय।
 
## मूल संरचना datasets.xml फ़ाइल{#the-basic-structure-of-the-datasetsxml-file} 
एक में आवश्यक और वैकल्पिक टैग की अनुमति datasets.xml फ़ाइल (और वे समय की संख्या दिखाई दे सकते हैं) नीचे दिखाया गया है। व्यवहार में, आपका datasets.xml बहुत कुछ होगा&lt;डेटासेट&gt; के टैग और केवल दूसरे टैग का उपयोग भीतर&lt;आवश्यकता के रूप में erddapDatasets&gt;।

  >&nbsp;&lt;&#63;xml version="1.0" encoding="ISO-8859-1" &#63;>  
  >&nbsp;&lt;erddapDatasets>  
  >&nbsp;&nbsp;&nbsp;[&lt;angularDegreeUnits>](#angulardegreeunits)...&lt;/angularDegreeUnits> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;angularDegreeTrueUnits>](#angulardegreetrueunits)...&lt;/angularDegreeTrueUnits> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;cacheMinutes>](#cacheminutes)...&lt;/cacheMinutes> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;commonStandardNames>](#commonstandardnames)...&lt;/commonStandardNames> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;convertInterpolateRequestCSVExample />](#convertinterpolaterequestcsvexample) &lt;!-- 0 or more -->  
  >&nbsp;&nbsp;&nbsp;[&lt;convertInterpolateDatasetIDVariableList />](#convertinterpolatedatasetidvariablelist) &lt;!-- 0 or more -->  
  >&nbsp;&nbsp;&nbsp;[&lt;convertToPublicSourceUrl />](#converttopublicsourceurl) &lt;!-- 0 or more -->  
  >&nbsp;&nbsp;&nbsp;[&lt;decompressedCacheMaxGB>](#decompressed-cache)...&lt;/decompressedCacheMaxGB> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;decompressedCacheMaxMinutesOld>](#decompressed-cache)...&lt;/decompressedCacheMaxMinutesOld> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;drawLandMask>](#drawlandmask)...&lt;/drawLandMask> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;emailDiagnosticsToErdData>](#emaildiagnosticstoerddata)...&lt;/emailDiagnosticsToErdData> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;graphBackgroundColor>](#graphbackgroundcolor)...&lt;/graphBackgroundColor> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;ipAddressMaxRequests>](#ipaddressmaxrequests)...&lt;/ipAddressMaxRequests> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;ipAddressMaxRequestsActive>](#ipaddressmaxrequestsactive)...&lt;ipAddressMaxRequestsActive> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;ipAddressUnlimited>](#ipaddressunlimited)...&lt;ipAddressUnlimited> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;loadDatasetsMinMinutes>](#loaddatasetsminminutes)...&lt;/loadDatasetsMinMinutes> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;loadDatasetsMaxMinutes>](#loaddatasetsmaxminutes)...&lt;/loadDatasetsMaxMinutes> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;logLevel>](#loglevel)...&lt;/logLevel> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;nGridThreads>](#nthreads)...&lt;/nGridThreads> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;nTableThreads>](#nthreads)...&lt;/nTableThreads> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;palettes>](#palettes)...&lt;/palettes> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;partialRequestMaxBytes>](#partialrequestmaxbytes-and-partialrequestmaxcells)...&lt;/partialRequestMaxBytes> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;partialRequestMaxCells>](#partialrequestmaxbytes-and-partialrequestmaxcells)...&lt;/partialRequestMaxCells> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;requestBlacklist>](#requestblacklist)...&lt;/requestBlacklist> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;slowDownTroubleMillis>](#slowdowntroublemillis)...&lt;/slowDownTroubleMillis> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;subscriptionEmailBlacklist>](#subscriptionemailblacklist)...&lt;/subscriptionEmailBlacklist> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;unusualActivity>](#unusualactivity)...&lt;/unusualActivity> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;updateMaxEvents>](#updatemaxevents)...&lt;/updateMaxEvents> &lt;!-- 0 or 1 -->  
  >  
  >&nbsp;&nbsp;&nbsp;[&lt;standardLicense>](#standard-text)...&lt;/standardLicense> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;standardContact>](#standard-text)...&lt;/standardContact> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;standardDataLicenses>](#standard-text)...&lt;/standardDataLicenses> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;standardDisclaimerOfEndorsement>](#standard-text)...&lt;/standardDisclaimerOfEndorsement> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;standardDisclaimerOfExternalLinks>](#standard-text)...&lt;/standardDisclaimerOfExternalLinks> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;standardGeneralDisclaimer>](#standard-text)...&lt;/standardGeneralDisclaimer> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;standardPrivacyPolicy>](#standard-text)...&lt;/standardPrivacyPolicy> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;startHeadHtml5>](#standard-text)...&lt;/startHeadHtml5> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;startBodyHtml5>](#standard-text)...&lt;/startBodyHtml5> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;theShortDescriptionHtml>](#standard-text)...&lt;/theShortDescriptionHtml> &lt;!-- 0 or 1 -->  
  >&nbsp;&nbsp;&nbsp;[&lt;endBodyHtml5>](#standard-text)...&lt;/endBodyHtml5> &lt;!-- 0 or 1 -->  
  >  
  >&nbsp;&nbsp;&nbsp;[&lt;user username="..." password="..." roles="..." />](#user) &lt;!-- 0 or more -->  
  >  
  >&nbsp;&nbsp;&nbsp;[&lt;dataset>](#list-of-types-datasets)...&lt;/dataset> &lt;!-- 1 or more -->  
  >&nbsp;&lt;/erddapDatasets>  

यह संभव है कि भविष्य में अन्य एन्कोडिंग की अनुमति होगी, लेकिन अब तक, केवल ISO-8859-1 की सिफारिश की जाती है।
 
### XInclude{#xinclude} 
संस्करण 2.25 में नया XInclude के लिए समर्थन है। इसके लिए आपको एसएएक्स पार्सर का उपयोग करना होगा&lt;SaxParser&lt;अपने सेटअप.xml में /useSaxParser&gt;। यह आपको अपनी फ़ाइल में प्रत्येक डेटासेट लिखने की अनुमति दे सकता है, फिर उन्हें मुख्य में शामिल करें datasets.xml , डेटासेट परिभाषाओं के हिस्सों का पुन: उपयोग करें, या दोनों। यदि आप एक उदाहरण देखना चाहते हैं, तो, [EDDTestDataset.java](https://github.com/ERDDAP/erddap/blob/main/src/test/java/testDataset/EDDTestDataset.java) XInclude को चर परिभाषाओं का पुन: उपयोग करने के लिए सेट करें।
 

- -

## नोट्स{#notes} 

साथ काम करना datasets.xml फ़ाइल एक गैर-trivial परियोजना है। कृपया इन सभी नोटों को ध्यान से पढ़ें। जब आप चाहें तो [डेटासेट प्रकार](#list-of-types-datasets) , कृपया ध्यान से इसका विस्तृत विवरण पढ़ें।
     
### डेटासेट प्रकार का चयन करना{#choosing-the-dataset-type} 
ज्यादातर मामलों में, सिर्फ एक ही ERDDAP™ डेटासेट प्रकार जो किसी दिए गए डेटा स्रोत के लिए उपयुक्त है। कुछ मामलों में (उदाहरण के लिए .nc फ़ाइलें) लेकिन आम तौर पर उनमें से एक निश्चित रूप से सबसे अच्छा है। आपको जो पहला और सबसे बड़ा निर्णय करना चाहिए वह है: यह बहुआयामी सरणी के एक समूह के रूप में डेटासेट के इलाज के लिए उपयुक्त है (अगर ऐसा लगता है [ EDDGrid डेटासेट प्रकार](#eddgrid) ) या डेटा की डेटाबेस जैसी तालिका के रूप में (अगर ऐसा लगता है [EDDTable Dataset प्रकार](#eddtable) ) ।
     
### जैसा है डेटा की सेवा करना{#serving-the-data-as-is} 
आम तौर पर, डेटा स्रोत को संशोधित करने की कोई आवश्यकता नहीं है (उदाहरण के लिए, फ़ाइलों को कुछ अन्य फ़ाइल प्रकार में परिवर्तित करें) इतना ERDDAP™ यह सेवा कर सकते हैं। मान्यताओं में से एक ERDDAP™ यह है कि डेटा स्रोत के रूप में प्रयोग किया जाएगा। आमतौर पर यह ठीक काम करता है। कुछ अपवाद हैं:
* रिलेशनल डेटाबेस और Cassandra -- ERDDAP™ सीधे संबंधिक डेटाबेस और Cassandra से डेटा की सेवा कर सकते हैं। लेकिन सुरक्षा, लोड संतुलन और प्रदर्शन मुद्दों के लिए, आप एक ही डेटा के साथ एक और डेटाबेस स्थापित करने या डेटा को बचाने के लिए चुन सकते हैं NetCDF v3 .nc फ़ाइलें और है ERDDAP™ डेटा को नए डेटा स्रोत से परोसें। देखें [EDDTableFromDatabase](#eddtablefromdatabase) और [EDDTableFromCassandra](#eddtablefromcassandra) ।
* समर्थित डेटा स्रोत नहीं -- ERDDAP™ बड़ी संख्या में डेटा स्रोतों का समर्थन कर सकते हैं, लेकिन दुनिया 1000 के दशक से भरी हुई है। (लाखों?) विभिन्न डेटा स्रोतों (विशेष रूप से, डेटा फ़ाइल संरचना) । अगर ERDDAP™ अपने डेटा स्रोत का समर्थन नहीं करता है:
    * यदि डेटा स्रोत है NetCDF   .nc फ़ाइलें, आप उपयोग कर सकते हैं [एनसीएमएल](#ncml-files) डेटा फ़ाइलों को ऑन-द-फ्लाई संशोधित करने के लिए, या उपयोग करें [ NCO ](#netcdf-operators-nco) डेटा फ़ाइलों को स्थायी रूप से संशोधित करने के लिए।
    * आप डेटा को डेटा स्रोत प्रकार में लिख सकते हैं कि ERDDAP™ समर्थन NetCDF -3 .nc फाइलें एक अच्छी, सामान्य सिफारिश हैं क्योंकि वे द्विआधारी फाइलें हैं जो ERDDAP™ बहुत जल्दी पढ़ सकते हैं। सारणीबद्ध डेटा के लिए, डेटा को संग्रह में संग्रहीत करने पर विचार करें .nc फ़ाइलें जो उपयोग करती हैं [CF Discrete Sampling Geometries (DSG) ](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries) Contiguous Ragged Array डेटा संरचनाओं और इतने के साथ संभाला जा सकता है ERDDAP ' [EDDTableFromNcCFFiles](#eddtablefromnccffiles) ). यदि वे तार्किक रूप से व्यवस्थित हैं (प्रत्येक अंतरिक्ष और समय के एक हिस्से के लिए डेटा के साथ) , ERDDAP™ उनमें से बहुत जल्दी डेटा निकाल सकते हैं।
    * आप अनुरोध कर सकते हैं कि उस डेटा स्रोत के लिए समर्थन जोड़ा जा सकता है ERDDAP™ ईमेल द्वारा क्रिस जॉन at noaa.gov.
    * आप अपने आप को संभालने के लिए कोड लिखकर उस डेटा स्रोत के लिए समर्थन जोड़ सकते हैं। देखें [The number of the ERDDAP™ प्रोग्रामर गाइड](/docs/contributing/programmer-guide) 
* गति - ERDDAP™ कुछ डेटा स्रोतों से डेटा को दूसरों की तुलना में बहुत तेजी से पढ़ सकते हैं। उदाहरण के लिए, पढ़ना NetCDF v3 .nc ASCII फ़ाइलों को तेजी से पढ़ने और पढ़ने की गति धीमी है। और अगर वहाँ एक बड़ा है (&gt;1000) विशाल (&gt;10,000) स्रोत डेटा फ़ाइलों की संख्या, ERDDAP™ कुछ डेटा अनुरोधों को धीरे-धीरे जवाब देंगे। आमतौर पर, अंतर मनुष्यों के लिए ध्यान देने योग्य नहीं है। हालांकि, अगर आपको लगता है ERDDAP™ किसी दिए गए डेटासेट के लिए धीमा है, आप डेटा को अधिक कुशल सेटअप में लिखकर समस्या को हल करने का विकल्प चुन सकते हैं। (आमतौर पर: कुछ, अच्छी तरह से संरचित, NetCDF v3 .nc फ़ाइलें) । सारणीबद्ध डेटा के लिए देखें [यह सलाह](#millions-of-files) ।
         
### हिंट{#hint} 
डेटासेट में कार्य डेटासेट विवरण की एक प्रति बनाकर अक्सर XML को डेटासेट के लिए उत्पन्न करना आसान होता है।
    
### एन्कोडिंग विशेष वर्ण{#encoding-special-characters} 
चूंकि datasets.xml एक XML फ़ाइल है, आप MUST [और एन्कोड](https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML) "&", "&lt;"&amp" के रूप में किसी भी सामग्री में ",", "&lt;", और "&gt;".
Wrong:&lt;शीर्षक&gt; समय और ज्वार&lt;शीर्षक
सही:&lt;शीर्षक&gt; Time &amp; Tides&lt;शीर्षक
     
### XML syntax त्रुटियों को बर्दाश्त नहीं करता है{#xml-doesnt-tolerate-syntax-errors} 
डेटासेट.xml फ़ाइल को संपादित करने के बाद, यह सत्यापित करने का एक अच्छा विचार है कि परिणाम है [अच्छी तरह से निर्मित XML](https://www.w3schools.com/xml/xml_dtd.asp) XML टेक्स्ट को XML चेकर में पेस्ट करके [xmlvalidation](https://www.xmlvalidation.com/) ।
     
### समस्या निवारण युक्तियाँ{#troubleshooting-tips} 
*    **अन्य तरीके डेटासेट के साथ समस्याओं का निदान करने के लिए**   
दो मुख्य के अलावा [उपकरण](#tools) ,
    *    [लॉग-इन](/docs/server-admin/additional-information#log) सभी के साथ एक लॉग फ़ाइल है ERDDAP नैदानिक संदेश
    * The The most of the [दैनिक रिपोर्ट](/docs/server-admin/additional-information#daily-report) स्टेटस पेज की तुलना में अधिक जानकारी है, जिसमें डेटासेट की एक सूची शामिल है जो लोड नहीं हुई थी और अपवाद (त्रुटियां) वे उत्पन्न हुए।
    * The The most of the [स्थिति पृष्ठ](/docs/server-admin/additional-information#status-page) जांच करने का एक त्वरित तरीका है ERDDAP किसी भी वेब ब्राउज़र से स्थिति। इसमें डेटासेट की एक सूची शामिल है जो लोड नहीं हुई थी (हालांकि संबंधित अपवाद नहीं हैं) और टास्कथ्रेड सांख्यिकी (प्रगति दर्शाना [ EDDGrid कॉपी](#eddgridcopy) और [EDDTableCopy](#eddtablecopy) डेटासेट और कोई भी [ EDDGrid सेफिल](#eddgridfromfiles) या [EDDTableFromFiles](#eddtablefromfiles) डेटासेट जो उपयोग करते हैं [कैशFromUrl](#cachefromurl)   (लेकिन कैश नहीं आकार जीबी) ) ।
    * यदि आप अटक जाते हैं, तो हमें देखें [अतिरिक्त समर्थन प्राप्त करने पर अनुभाग](/docs/intro#support) ।
         
### विशेष चर{#special-variables} 
*    ** [देशांतर, अक्षांश, ऊंचाई, गहराई, दबाव और समय (LLAT) चर](#destinationname)   [ destinationName ](#destinationname) एस विशेष हैं।** 
    * सामान्य में:
        * LLAT चर के लिए जाना जाता है ERDDAP™ यदि अक्ष चर है (के लिए EDDGrid डेटासेट) या डेटा चर (EDDTable Datasets के लिए)   [ destinationName ](#destinationname) "longitude", "latitude", "altitude", "depth", या "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "altitude", "depth", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "atitude", "titude", "atitude", "titude", "atitude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", "titude", " "time" ।
        * जब भी संभव हो तो हम इन चरों के लिए इन मानक नामों का उपयोग करने के लिए प्रोत्साहित करते हैं। उनमें से कोई भी आवश्यक नहीं है। यदि आप इन विशेष वेरिएबल नामों का उपयोग नहीं करते हैं, तो आप इन विशेष वेरिएबल नामों का उपयोग नहीं करते हैं। ERDDAP™ उनके महत्व को नहीं पहचानेगा। उदाहरण के लिए, एलएलएटी चर को विशेष रूप से मेक ए ग्राफ द्वारा इलाज किया जाता है ( * datasetID * ग्राफ़) यदि X अक्ष चर "लंबाई" है और Y अक्ष चर " अक्षांश" है, तो आपको एक नक्शा मिलेगा (एक मानक प्रक्षेपण का उपयोग करके और एक भूमि मुखौटा, राजनीतिक सीमाओं आदि के साथ।) ग्राफ के बजाय।
        *    ERDDAP™ स्वचालित रूप से कई मेटाडाटा को LLAT चर में जोड़ देगा (उदाहरण के लिए, " [ ioos\\_category ](#ioos_category) "," [यूनिट](#units) ", और कई मानकों से संबंधित विशेषताओं जैसे "\\_CoordinateAxistype") ।
        *    ERDDAP™ स्वचालित रूप से, ऑन-द-फ्लाई, चयनित डेटा सबसेट के एलएलएटी मूल्यों से संबंधित कई वैश्विक मेटाडाटा जोड़ें (उदाहरण के लिए, "geospace \\_lon\\min") ।
        * इन मेटाडाटा मानकों का समर्थन करने वाले ग्राहक समय और स्थान पर डेटा को तैनात करने के लिए अतिरिक्त मेटाडाटा का लाभ उठाने में सक्षम होंगे।
        * ग्राहकों को उन प्रश्नों को उत्पन्न करना आसान होगा जिनमें एलएलएटी वेरिएबल्स शामिल हैं क्योंकि वेरिएबल के नाम सभी प्रासंगिक डेटासेट्स में समान हैं।
    * "longitude" चर और "latitude" चर के लिए:
        * उपयोग [ destinationName ](#destinationname) s "longitude" और "latitude" केवल अगर [यूनिट](#units) क्रमशः डिग्री \\_east और डिग्री \\_north हैं। यदि आपका डेटा इन आवश्यकताओं को पूरा नहीं करता है, तो विभिन्न परिवर्तनीय नामों का उपयोग करें (उदाहरण के लिए, x, y, lonRadians, latRadians) ।
        * यदि आपके पास विभिन्न इकाइयों में व्यक्त Longitude और अक्षांश डेटा है और इस प्रकार विभिन्न इकाइयों के साथ destinationName उदाहरण के लिए, lonRadians और latRadians, एक Graph बनाओ ( * datasetID * ग्राफ़) ग्राफ़ बना देंगे (उदाहरण के लिए, समय श्रृंखला) नक्शे के बजाय।
    * "altitude", "presure", या "depth" चर के लिए:
        * उपयोग [ destinationName ](#destinationname) समुद्र तल से ऊपर डेटा की दूरी की पहचान करने के लिए "altitude" (सकारात्मक) । वैकल्पिक रूप से, आप समुद्र तल से नीचे की दूरी के लिए "altitude" का उपयोग कर सकते हैं यदि मान समुद्र के नीचे नकारात्मक हैं (या यदि आप उपयोग करते हैं, तो उदाहरण के लिए,
[&lt;att name scale\\_factor "type="int"&gt; - 1&lt;/att&gt; (#scale_factor) गहराई मान को ऊंचाई मान में परिवर्तित करने के लिए।
        * उपयोग destinationName "गहराई" समुद्र तल से नीचे डेटा की दूरी की पहचान करने के लिए (सकारात्मक="down" मान) ।
        * वैकल्पिक रूप से, हवा के दबाव के स्तर द्वारा परिभाषित ऊंचाई के लिए (जैसे [आइसोबायर](https://en.wikipedia.org/wiki/Contour_line#Barometric_pressure) ) , आपको सेट करना चाहिए destinationName "दबाव" यह "hPa", "Pa", और "mbar" में इकाइयों का समर्थन करता है। (सकारात्मक="down" मान) ।
        * डेटासेट में केवल एक "परिमाण", "दबाव", या "गहराई" चर हो सकता है।
        * इन "altitude" और "depth" चर के लिए, [यूनिट](#units) "m", "meter", या "meters" होना चाहिए। अगर इकाइयों अलग (उदाहरण के लिए, fathom) , आप उपयोग कर सकते हैं
[&lt;att name scale\\_factor &gt;&gt; *कुछ मूल्य* &lt;/att&gt; (#scale_factor) [&lt;att name="units"&gt;meters&lt;/att&gt; (#units) इकाइयों को मीटर में बदलने के लिए।
        * यदि आपका डेटा इन आवश्यकताओं को पूरा नहीं करता है, तो एक अलग का उपयोग करें destinationName   (उदाहरण के लिए, ऊपर ToBottom) ।
        * यदि आप ऊर्ध्वाधर CRS जानते हैं तो कृपया इसे मेटाडाटा में निर्दिष्ट करें, उदाहरण के लिए, "EPSG:5829" (समुद्र तल से अधिक तात्कालिक ऊंचाई) , "EPSG:5831" (समुद्र तल के नीचे तात्कालिक गहराई) , या "EPSG:5703" (NAVD88 ऊंचाई) ।
    * के लिए "time" चर:
        * उपयोग [ destinationName ](#destinationname)   "time" केवल उन चरों के लिए जिनमें संपूर्ण तारीख + समय शामिल है (या तारीख, अगर यह सब है) । यदि, उदाहरण के लिए, तारीख और समय के लिए अलग-अलग कॉलम हैंOfday, चर नाम का उपयोग न करें "time" ।
        * देखें [यूनिट](#time-units) समय और समय के लिए इकाइयों की विशेषता के बारे में अधिक जानकारी के लिएStamp चर।
        * समय चर और संबंधित [समय मुद्रा परिवर्तक](#timestamp-variables) वे हमेशा स्रोत के समय स्वरूप से डेटा मान परिवर्तित कर रहे हैं कि अद्वितीय हैं (जो कुछ भी हो) एक संख्यात्मक मान में (1970-01-01T00:00:00Z) या स्ट्रिंग मान (आईएसओ 8601:2004 (E) स्वरूप) स्थिति के आधार पर।
        * जब कोई उपयोगकर्ता समय डेटा का अनुरोध करता है, तो वे उस समय को संख्यात्मक मान के रूप में निर्दिष्ट करके अनुरोध कर सकते हैं। (1970-01-01T00:00:00Z) या स्ट्रिंग मान (आईएसओ 8601:2004 (E) स्वरूप) ।
        *    ERDDAP™ इसमें उपयोगिता है [एक न्यूमेरिक कनवर्ट करें समय-समय पर स्ट्रिंग टाइम से](https://coastwatch.pfeg.noaa.gov/erddap/convert/time.html) ।
        * देखें [कैसे ERDDAP समय के साथ सौदे](https://coastwatch.pfeg.noaa.gov/erddap/convert/time.html#erddap) ।
            
### क्यों सिर्फ दो बुनियादी डेटा संरचनाओं?{#why-just-two-basic-data-structures} 
* चूंकि मानव ग्राहकों और कंप्यूटर ग्राहकों के लिए संभावित डेटासेट संरचनाओं के एक जटिल सेट से निपटने के लिए मुश्किल है, ERDDAP™ केवल दो बुनियादी डेटा संरचनाओं का उपयोग करता है:
    * a [ग्रिड डेटा संरचना](https://coastwatch.pfeg.noaa.gov/erddap/griddap/documentation.html#dataModel)   (उदाहरण के लिए, उपग्रह डेटा और मॉडल डेटा के लिए) और
    * a [सारणीबद्ध डेटा संरचना](https://coastwatch.pfeg.noaa.gov/erddap/tabledap/documentation.html#dataModel)   (उदाहरण के लिए, In-situ buoy, स्टेशन और trajectory डेटा के लिए) ।
* निश्चित रूप से, इन संरचनाओं में सभी डेटा को व्यक्त नहीं किया जा सकता है, लेकिन इसमें से अधिकांश कर सकते हैं। टेबल्स, विशेष रूप से, बहुत लचीला डेटा संरचनाएं हैं (रिलेशनल डेटाबेस प्रोग्राम की सफलता को देखें) ।
* यह डेटा क्वेरी को बनाना आसान बनाता है।
* यह डेटा प्रतिक्रियाओं को एक सरल संरचना बनाता है, जो डेटा को विभिन्न प्रकार के मानक फ़ाइल प्रकारों में सेवा करना आसान बनाता है। (जो अक्सर साधारण डेटा संरचनाओं का समर्थन करते हैं) । यह मुख्य कारण है कि हम इसे स्थापित करते हैं ERDDAP™ इस तरह।
* इसके बदले में यह हमारे लिए बहुत आसान बनाता है (या कोई) क्लाइंट सॉफ़्टवेयर लिखने के लिए जो सभी के साथ काम करता है ERDDAP™ डेटासेट
* यह विभिन्न स्रोतों से डेटा की तुलना करना आसान बनाता है।
* हम बहुत जानते हैं कि यदि आप अन्य डेटा संरचनाओं में डेटा के साथ काम करने के लिए उपयोग किए जाते हैं तो आप शुरू में सोच सकते हैं कि यह दृष्टिकोण सरल या अपर्याप्त है। लेकिन सभी डेटा संरचनाओं में कारोबार होता है। कोई भी सही नहीं है। यहां तक कि do-it-all संरचनाओं में उनके डाउनसाइड भी हैं: उनके साथ काम करना जटिल है और फ़ाइलों को केवल विशेष सॉफ्टवेयर पुस्तकालयों के साथ लिखा या पढ़ा जा सकता है। यदि आप स्वीकार करते हैं ERDDAP इसके साथ काम करने की कोशिश करने के लिए पर्याप्त दृष्टिकोण, आपको पता चल सकता है कि इसके फायदे हैं (विशेष रूप से एकाधिक फ़ाइल प्रकारों के लिए समर्थन जो डेटा प्रतिक्रियाओं को पकड़ सकता है) । The The most of the [ ERDDAP™ स्लाइड शो](https://coastwatch.pfeg.noaa.gov/erddap/images/erddapTalk/erddapTechTalk.html)   (विशेष रूप से [डेटा संरचना स्लाइड](https://coastwatch.pfeg.noaa.gov/erddap/images/erddapTalk/erddapTechTalk.html#dataStructures) ) इन मुद्दों के बारे में बहुत कुछ बात करता है।
* और यहां तक कि अगर यह दृष्टिकोण आपको अजीब लगता है, तो भी ERDDAP™ ग्राहक कभी नोटिस नहीं करेंगे - वे बस देखेंगे कि सभी डेटासेट में एक अच्छा सरल संरचना है और वे आभारी होंगे कि वे विभिन्न प्रकार के फ़ाइल प्रारूपों में लौटे स्रोतों से डेटा प्राप्त कर सकते हैं।
         
### आयाम{#dimensions} 
*    **क्या होगा यदि ग्रिड वैरिएबल्स इन सोर्स डाटासेट DON't share the अक्ष वैरिएबल?**   
में EDDGrid डेटासेट, सभी डेटा चर MUST उपयोग (शेयर) सभी अक्ष चर। यदि एक स्रोत डेटासेट में आयामों के एक सेट के साथ कुछ चर होते हैं, और आयामों के एक अलग सेट के साथ अन्य चर, तो आपको दो डेटासेट बनाने होंगे। ERDDAP । उदाहरण के लिए, आप एक बना सकते हैं ERDDAP™ डेटासेट जिसका शीर्षक "कुछ शीर्षक" है (सतह पर) वेरिएबल रखने के लिए जो सिर्फ इस्तेमाल करते हैं \\[ समय \\]  \\[ अक्षांश \\]  \\[ लंबाई \\] आयाम और एक दूसरे को बनाने ERDDAP™ डेटासेट जिसका शीर्षक "कुछ शीर्षक" है (गहराई पर) " वेरिएबल्स को रखने के लिए जो उपयोग करते हैं \\[ समय \\]  \\[ ऊंचाई \\]  \\[ अक्षांश \\]  \\[ लंबाई \\] । या शायद आप एक ही मान के साथ एक आयाम जोड़ने के लिए डेटा स्रोत को बदल सकते हैं (उदाहरण के लिए, ऊंचाई = 0) चर को सुसंगत बनाने के लिए।
    
     ERDDAP™ अधिक जटिल डेटासेट नहीं संभालती (उदाहरण के लिए, मॉडल जो त्रिभुज के जाल का उपयोग करते हैं) ठीक है। आप इन डेटासेटों में सेवा कर सकते हैं ERDDAP™ दो या अधिक डेटासेट बनाने के द्वारा ERDDAP™   (ताकि प्रत्येक नए डेटासेट में सभी डेटा चर अक्ष चर का एक ही सेट साझा करें) लेकिन यह वह नहीं है जो उपयोगकर्ता चाहते हैं। कुछ डेटासेट के लिए, आप डेटासेट का नियमित ग्रिड संस्करण बना सकते हैं और मूल डेटा के अलावा यह पेशकश कर सकते हैं। कुछ ग्राहक सॉफ्टवेयर केवल एक नियमित ग्रिड के साथ सौदा कर सकते हैं, इसलिए ऐसा करके, आप अतिरिक्त ग्राहकों तक पहुंच सकते हैं।
     
    
### अनुमानित ग्रिड डेटा{#projected-gridded-data} 
कुछ ग्रिड डेटा में एक जटिल संरचना है। उदाहरण के लिए, उपग्रह स्तर 2 ("ऑंग ट्रैक") डेटा एक सरल प्रक्षेपण का उपयोग नहीं करता है। मॉडल (अन्य) अक्सर विभिन्न गैर-बेलनाकार अनुमानों पर ग्रिड डेटा के साथ काम करते हैं (उदाहरण के लिए, conic, ध्रुवीय स्टीरियोग्राफिक, tripolar) या असंरचना ग्रिड में (एक जटिल डेटा संरचना) । कुछ अंतिम उपयोगकर्ता चाहते हैं कि यह डेटा है, इसलिए सूचना का कोई नुकसान नहीं है। उन ग्राहकों के लिए, ERDDAP™ डेटा की सेवा कर सकते हैं, जैसा कि है, केवल अगर ERDDAP™ प्रशासक मूल डेटासेट को कुछ डेटासेट में तोड़ देता है, जिसमें प्रत्येक भाग में चर शामिल होते हैं जो समान अक्ष चर को साझा करते हैं। हाँ, ऐसा लगता है कि शामिल लोगों के लिए अजीब लगता है और यह अधिकांश लोगों से अलग है OPeNDAP सर्वर लेकिन ERDDAP™ कई प्रारूपों में उपलब्ध डेटा बनाने पर जोर देता है। यह संभव है क्योंकि ERDDAP™ अधिक समान डेटा संरचना का उपयोग/require करता है। हालांकि यह थोड़ा अजीब है (यानी, उम्मीद से अलग) , ERDDAP™ अनुमानित डेटा वितरित कर सकते हैं।

 \\[ हाँ, ERDDAP™ डेटा संरचना के लिए ढीले आवश्यकताएं हो सकती हैं, लेकिन आउटपुट प्रारूपों के लिए आवश्यकताएं रख सकती हैं। लेकिन इससे कई उपयोगकर्ताओं के बीच भ्रम पैदा हो सकता है, विशेष रूप से newbies, चूंकि विभिन्न संरचनाओं के साथ डेटा के लिए कई प्रतीत होता है वैध अनुरोध अमान्य होगा क्योंकि डेटा फ़ाइल प्रकार में फिट नहीं होगा। हम वर्तमान सिस्टम के डिजाइन में वापस आते रहते हैं। \\] 

कुछ अंतिम उपयोगकर्ता विभिन्न स्थितियों में आसानी से उपयोग के लिए इक्विरेक्टांगुलर / प्लेट कैरी या मर्केटर जैसे लैटलोन बेलनाकार प्रोजेक्शन में डेटा चाहते हैं। इन स्थितियों के लिए, हम प्रोत्साहित करते हैं ERDDAP™ व्यवस्थापक कुछ अन्य सॉफ्टवेयर का उपयोग करने के लिए ( NCO ? Matlab ? आर? IDV? ...?) एक भौगोलिक पर डेटा को फिर से पेश करने के लिए (समीकरणीय प्रक्षेपण / प्लेट carrée) या अन्य बेलनाकार प्रक्षेपण और डेटा के उस रूप में काम करते हैं ERDDAP™ एक अलग डेटासेट के रूप में। यह वही है जो लोग उपग्रह स्तर 2 डेटा को स्तर 3 डेटा में परिवर्तित करते हैं। एक ऐसा उपकरण है [ NCO ](https://nco.sourceforge.net/nco.html#Regridding) जो रेगर्डिंग डेटा के लिए एक्सटेंशन विकल्प प्रदान करता है।

#### GIS and Reprojecting Data{#gis-and-reprojecting-data} 
चूंकि जीआईएस की दुनिया अक्सर उन्मुख होती है, जीआईएस कार्यक्रम आमतौर पर डेटा को फिर से पेश करने के लिए समर्थन प्रदान करते हैं, अर्थात्, एक अलग प्रक्षेपण के साथ एक मानचित्र पर डेटा साजिश।

वर्तमान में, ERDDAP™ डेटा को सुधारने के लिए उपकरण नहीं है। इसके बजाय, हम अनुशंसा करते हैं कि आप डेटासेट का एक संस्करण बनाने के लिए एक बाहरी उपकरण का उपयोग करते हैं, जहां डेटा को अपने मूल रूप से आयताकार पर दोबारा लागू किया गया है। (अक्षांश देशांतर) के लिए उपयुक्त सरणी ERDDAP ।

हमारी राय में, CF/ DAP दुनिया जीआईएस दुनिया की तुलना में थोड़ा अलग है और थोड़ा कम स्तर पर काम करता है। ERDDAP™ इसे दर्शाता है। सामान्य तौर पर, ERDDAP™ मुख्य रूप से डेटा के साथ काम करने के लिए डिज़ाइन किया गया है (नक्शा नहीं) और बदलना नहीं चाहता (उदाहरण के लिए, reproject) डेटा के लिए ERDDAP™ , ग्रिड डेटा अक्सर / आमतौर पर / संभवतः लैटलोन मूल्यों और एक बेलनाकार प्रक्षेपण के साथ जुड़ा हुआ है, न कि कुछ प्रक्षेपण के x, वाई मान। किसी भी मामले में, ERDDAP™ डेटा के प्रक्षेपण के साथ कुछ भी नहीं करता है; यह सिर्फ डेटा के माध्यम से गुजरता है, जैसा कि इसके वर्तमान प्रक्षेपण के साथ है, सिद्धांत पर कि एक सुधार डेटा के लिए एक महत्वपूर्ण परिवर्तन है और ERDDAP™ महत्वपूर्ण परिवर्तन के साथ शामिल नहीं होना चाहिए। इसके अलावा, बाद के उपयोगकर्ता फिर से डेटा को फिर से पेश कर सकते हैं, जो उतना अच्छा नहीं होगा जितना कि केवल एक पुनर्परियोजना करना। (तो, अगर ERDDAP™ व्यवस्थापक एक अलग प्रक्षेपण में डेटा की पेशकश करना चाहता है, ठीक है; केवल ऑफ़लाइन डेटा को फिर से पेश करें और यह पेशकश करें कि एक अलग डेटासेट के रूप में ERDDAP । उपग्रह आधारित डेटासेट के बहुत सारे की पेशकश की जाती है क्योंकि NASA ने स्तर 2 को क्या कहा है? (झरना) और स्तर 3 (समीकरणीय प्रक्षेपण) संस्करण।) कब ERDDAP™ नक्शा (सीधे WMS या KML) , ERDDAP™ वर्तमान में केवल समतुल्य / प्लेट carrée प्रोजेक्शन के साथ मानचित्र बनाने की पेशकश करता है, जो कि सौभाग्य से मैपिंग कार्यक्रमों द्वारा स्वीकार किया जाता है।

हम प्रोत्साहित करते हैं ERDDAP™ व्यवस्थापक कुछ अन्य सॉफ्टवेयर का उपयोग करने के लिए ( NCO ? Matlab ? आर? IDV? ...?) एक भौगोलिक पर डेटा को फिर से पेश करने के लिए (समीकरणीय प्रक्षेपण / प्लेट carrée) या अन्य बेलनाकार प्रक्षेपण और डेटा के उस रूप में काम करते हैं ERDDAP™ एक अलग डेटासेट के रूप में। यह वही है जो लोग उपग्रह स्तर 2 डेटा को स्तर 3 डेटा में परिवर्तित करते हैं। एक ऐसा उपकरण है [ NCO ](https://nco.sourceforge.net/nco.html#Regridding) जो रेगर्डिंग डेटा के लिए एक्सटेंशन विकल्प प्रदान करता है।

हमें आशा है कि ERDDAP™ भविष्य में अन्य अनुमानों के साथ मानचित्र पेश करने के लिए अंतर्निहित उपकरण होंगे। हम भविष्य में जीआईएस दुनिया के लिए बेहतर संबंध रखने की उम्मीद करते हैं (वर्तमान के अलावा WMS सेवा) । यह भयानक है कि इस "आधुनिक" दुनिया में, CF / के बीच संबंध DAP दुनिया और जीआईएस दुनिया अभी भी इतनी कमजोर है। उन दोनों चीजों को टू डो लिस्ट में शामिल किया गया है। (यदि आप मदद करना चाहते हैं, तो विशेष रूप से कनेक्ट होने के साथ ERDDAP™ To make a chris. जॉन at noaa.gov.) 
    
### डेटा प्रकार{#data-types} 
 ERDDAP™ निम्नलिखित डेटा प्रकारों का समर्थन करता है
 (नाम केस संवेदनशील हैं; 'u' उपसर्ग "unsigned" के लिए खड़ा है; अन्य प्रणालियों में कई नाम बिट की संख्या है) :

#### बाइट{#byte} 
*    **बाइट** -128 से 127 की एक श्रृंखला के साथ पूर्णांक मूल्यों पर हस्ताक्षर किए हैं।
अन्य प्रणालियों में इसे कभी-कभी int8 कहा जाता है।
इसे SQL और Cassandra द्वारा "tinyint" कहा जाता है।
     ERDDAP™ बदलना [बोरान](#boolean-data) कुछ स्रोतों से (उदाहरण के लिए, SQL और Cassandra) में बाइट्स ERDDAP™ 0=false, 1=true, and 127= missing\\_value ।
#### Ubyte{#ubyte} 
*    **Ubyte** 0 से 255 की एक श्रृंखला के साथ पूर्णांक मूल्यों को निर्दिष्ट नहीं किया गया है।
अन्य प्रणालियों में इसे कभी-कभी Uint8 कहा जाता है।
#### छोटा{#short} 
*    **छोटा** -32768 से 32767 तक की सीमा के साथ पूर्णांक मूल्यों पर हस्ताक्षर किए हैं।
अन्य प्रणालियों में इसे कभी-कभी int16 कहा जाता है।
इसे SQL और Cassandra द्वारा "smallint" कहा जाता है।
#### Ushort{#ushort} 
*    **Ushort** 0 से 65535 की एक श्रृंखला के साथ पूर्णांक मूल्यों को निर्दिष्ट नहीं किया गया है।
अन्य प्रणालियों में इसे कभी-कभी Uint16 कहा जाता है।
#### int{#int} 
*    **int** -2147483648 से 2147483647 की एक श्रृंखला के साथ पूर्णांक मूल्यों पर हस्ताक्षर किए हैं।
अन्य प्रणालियों में इसे कभी-कभी int32 कहा जाता है।
इसे "integer" कहा जाता है | संख्यात्मक (?) "Cassandra" द्वारा SQL और "int" द्वारा।
#### हिंदी{#uint} 
*    **हिंदी** 0 से 4294967295 की एक श्रृंखला के साथ पूर्णांक मूल्यों को निर्दिष्ट नहीं किया गया है।
अन्य प्रणालियों में इसे कभी-कभी Uint32 कहा जाता है।
#### लंबा{#long} 
*    **लंबा** -9223372036854775808 से 9223372036854775807 की एक श्रृंखला के साथ पूर्णांक मूल्यों पर हस्ताक्षर किए हैं।
अन्य प्रणालियों में इसे कभी-कभी int64 कहा जाता है।
इसे "बिगिंट" कहा जाता है | संख्यात्मक (?) एसक्यूएल और "बिगिंट" द्वारा Cassandra।
क्योंकि कई फ़ाइल प्रकार लंबे डेटा का समर्थन नहीं करते हैं, उनका उपयोग हतोत्साहित है। जब संभव हो, तो इसके बजाय डबल का उपयोग करें (नीचे देखें) ।
#### ऊँचा{#ulong} 
*    **ऊँचा** 0 से 18446744073709551615 की एक श्रृंखला के साथ unsigned पूर्णांक मान है
अन्य प्रणालियों में इसे कभी-कभी Uint64 कहा जाता है।
क्योंकि कई फ़ाइल प्रकार उल्लू डेटा का समर्थन नहीं करते हैं, उनका उपयोग हतोत्साहित है। जब संभव हो, तो इसके बजाय डबल का उपयोग करें (नीचे देखें) ।
#### फ्लोट{#float} 
*    **फ्लोट** लगभग +/- 3.402823466e + 38 की एक श्रृंखला के साथ एक IEEE 754 फ्लोट है।
अन्य प्रणालियों में इसे कभी-कभी फ्लोट32 कहा जाता है।
इसे "real" कहा जाता है | फ्लोट (?)  | दशमलव (?)  | संख्यात्मक (?) "Cassandra द्वारा SQL और "float" द्वारा।
विशेष मूल्य नान का अर्थ नो-ए-नंबर है।
     ERDDAP™ सकारात्मक और नकारात्मक इन्फिनिटी मूल्यों को NaN में बदल देता है।
#### डबल{#double} 
*    **डबल** लगभग की एक श्रृंखला के साथ एक IEEE 754 डबल है
+/- 1.7976931348623157E+308.
अन्य प्रणालियों में इसे कभी-कभी फ्लोट64 कहा जाता है।
इसे "डबल परिशुद्धता" कहा जाता है | फ्लोट (?)  | दशमलव (?)  | संख्यात्मक (?) एसक्यूएल और "डबल" द्वारा Cassandra।
विशेष मूल्य नान का अर्थ नो-ए-नंबर है।
     ERDDAP™ सकारात्मक और नकारात्मक इन्फिनिटी मूल्यों को NaN में बदल देता है।
#### char{#char} 
*    **char** एक एकल, 2-बाइट है (16-bit)   [यूनिकोड UCS-2](https://en.wikipedia.org/wiki/UTF-16) से लेकर \\u0000   (#0) माध्यम \\uffff   (#65535) ।
     \\uffff 'की परिभाषा नॉट-a-Character है, जो नान के दोहरे मान के अनुरूप है।
char का उपयोग हतोत्साहित है क्योंकि कई फ़ाइल प्रकार या तो chars का समर्थन नहीं करते हैं या केवल 1-byte chars समर्थन करते हैं। (नीचे देखें) । इसके बजाय स्ट्रिंग का उपयोग करने पर विचार करें।
उपयोगकर्ता ग्राफ़ बनाने के लिए चार चर का उपयोग कर सकते हैं। ERDDAP™ वर्णों को उनके यूनिकोड कोड बिंदु संख्या में परिवर्तित करेगा, जिसका उपयोग संख्यात्मक डेटा के रूप में किया जा सकता है।
#### स्ट्रिंग{#string} 
*    **स्ट्रिंग** 0 या उससे अधिक का अनुक्रम है, 2-byte (16-bit)   [यूनिकोड UCS-2 वर्ण](https://en.wikipedia.org/wiki/UTF-16) ।
     ERDDAP™ एक लापता मूल्य के रूप में 0-लंबाई स्ट्रिंग का उपयोग / व्याख्या करता है। ERDDAP™ एक वास्तविक शून्य स्ट्रिंग का समर्थन नहीं करता है।
सैद्धांतिक अधिकतम स्ट्रिंग लंबाई 2147483647 वर्ण है, लेकिन शायद कुछ हद तक कम स्ट्रिंग के साथ भी विभिन्न स्थानों में विभिन्न समस्याएं हैं।
उपयोग ERDDAP SQL के चरित्र, varchar, चरित्र भिन्नता, द्विआधारी, varbinary, अंतराल, सरणी, मल्टीसेट, xml, और किसी अन्य डेटाबेस डेटा प्रकार के लिए स्ट्रिंग जो किसी अन्य के साथ स्वच्छ रूप से फिट नहीं है ERDDAP™ डेटा प्रकार।
उपयोग ERDDAP Cassandra के "text" और किसी अन्य Cassandra डेटा प्रकार के लिए स्ट्रिंग जो स्वच्छ रूप से किसी अन्य के साथ फिट नहीं है ERDDAP™ डेटा प्रकार।
     

पहले ERDDAP™ v2.10, ERDDAP™ आंतरिक रूप से unsigned पूर्णांक प्रकारों का समर्थन नहीं किया और अपने डेटा पाठकों और लेखकों में सीमित समर्थन की पेशकश की।
    
### डेटा टाइप लिमिटेशन{#data-type-limitations} 
आप सोच सकते हैं ERDDAP™ एक प्रणाली के रूप में जिसमें आभासी डेटासेट होते हैं, और जो डेटासेट के स्रोत से एक आंतरिक डेटा मॉडल में डेटा पढ़ने और विभिन्न सेवाओं के लिए डेटा लिखने के द्वारा काम करता है (उदाहरण के लिए,)(OPeN)DAP, WMS उपयोगकर्ता अनुरोधों के जवाब में फ़ाइल प्रकार।

* प्रत्येक इनपुट रीडर डेटा प्रकारों की एक सबसेट का समर्थन करता है जो डेटा प्रकारों की एक सबसेट का समर्थन करता है। ERDDAP™ समर्थन तो डेटा पढ़ने में ERDDAP आंतरिक डेटा संरचना एक समस्या नहीं है।
* प्रत्येक आउटपुट लेखक डेटा प्रकारों की एक सबसेट का भी समर्थन करता है। यह एक समस्या है क्योंकि ERDDAP उदाहरण के लिए, फाइल प्रकारों में लंबे डेटा जो लंबे डेटा का समर्थन नहीं करते हैं।
     

नीचे सीमाओं के स्पष्टीकरण हैं (कोई नहीं) विभिन्न उत्पादन लेखकों और कैसे ERDDAP™ समस्याओं से निपटने के लिए। ऐसी जटिलताओं का एक अंतर्निहित हिस्सा है ERDDAP अविभाज्य सिस्टम बनाने का लक्ष्य।

#### ASCII{#ascii} 
* ASCII (Csv, .tsv आदि) टेक्स्ट फाइलें -
    * सभी संख्यात्मक डेटा अपने स्ट्रिंग प्रतिनिधित्व के माध्यम से लिखा जाता है (0-लंबाई स्ट्रिंग्स के रूप में दिखाई देने वाले लापता डेटा मानों के साथ) ।
    * हालांकि ERDDAP™ ASCII पाठ फ़ाइलों के लिए सही ढंग से लंबे और लंबे मूल्यों को लिखते हैं, कई पाठक (उदाहरण के लिए, स्प्रेडशीट कार्यक्रम) लंबे और लंबे मूल्यों के साथ सही ढंग से सौदा नहीं कर सकता है और इसके बजाय उन्हें दोहरे मूल्यों में परिवर्तित कर सकता है (कुछ मामलों में परिशुद्धता के नुकसान के साथ) ।
    * चार और स्ट्रिंग डेटा JSON स्ट्रिंग्स के माध्यम से लिखे गए हैं, जो सभी यूनिकोड वर्णों को संभालते हैं (विशेष रूप से, ASCII #127 से परे "असामान्य" वर्ण, उदाहरण के लिए, यूरो चरित्र "\\u20ac" के रूप में दिखाई देता है।) ।
    
        
#### JSON{#json} 
* JSON ( .json , .jsonlCSV आदि) टेक्स्ट फाइलें -
    * सभी संख्यात्मक डेटा अपने स्ट्रिंग प्रतिनिधित्व के माध्यम से लिखा जाता है।
    * चार और स्ट्रिंग डेटा JSON स्ट्रिंग के रूप में लिखा जाता है, जो सभी यूनिकोड वर्णों को संभालती है (विशेष रूप से, ASCII #127 से परे "असामान्य" वर्ण, उदाहरण के लिए, यूरो चरित्र "\\u20ac" के रूप में दिखाई देता है।) ।
    * सभी संख्यात्मक डेटा प्रकारों के लिए मिसिंग मान शून्य के रूप में दिखाई देते हैं।
         
####  .nc 3 फाइलें{#nc3-files} 
*    .nc 3 फाइलें मूल रूप से किसी भी निर्दिष्ट पूर्णांक डेटा प्रकार का समर्थन नहीं करती हैं। CF v1.9 से पहले, CF ने असाइन किए गए पूर्णांक प्रकारों का समर्थन नहीं किया। इससे निपटने के लिए, ERDDAP™ 2.10+ NUG मानक का अनुसरण करता है और हमेशा "true" या "false" के मूल्य के साथ एक "\\_Unsigned" विशेषता जोड़ती है, यह इंगित करने के लिए कि डेटा एक unsigned या हस्ताक्षरित चर से है। सभी पूर्णांक विशेषताओं को हस्ताक्षरित विशेषताओं के रूप में लिखा जाता है (उदाहरण के लिए, byte) हस्ताक्षरित मान (उदाहरण के लिए, एक ubyte) के साथ actual\\_range मान 0 से 255 के साथ विशेषता, मान 0 से -1 के साथ एक बाइट विशेषता के रूप में प्रकट होती है (बाहरी रेंज मान के दो के पूरक मूल्य के विपरीत)। यह जानने का कोई आसान तरीका नहीं है कि कौन सा (signed) पूर्णांक विशेषताओं को असाइन किए गए विशेषताओं के रूप में पढ़ा जाना चाहिए। ERDDAP™ जब यह पढ़ता है तो "\\_Unsigned" विशेषता का समर्थन करता है .nc 3 फाइलें।
*    .nc 3 फाइलें लंबे या लंबे डेटा प्रकारों का समर्थन नहीं करती हैं। ERDDAP™ इससे निपटने के लिए अस्थायी रूप से उन्हें डबल वेरिएबल में परिवर्तित करने के लिए। डबल्स बिल्कुल +/- 9,007,199,254,740,992 तक सभी मूल्यों का प्रतिनिधित्व कर सकते हैं जो 2^53 है। यह एक अपूर्ण समाधान है। Unidata मामूली उन्नयन करने से इनकार कर दिया .nc इस समस्या से निपटने के लिए 3, सिटिंग .nc 4 (एक प्रमुख बदलाव) समाधान के रूप में।
* CF विनिर्देश (इससे पहले v1.9) यह एक char डेटा प्रकार का समर्थन करता है, लेकिन यह स्पष्ट नहीं है कि अगर char केवल char सरणी के निर्माण ब्लॉक के रूप में ही इरादा है, जो प्रभावी रूप से स्ट्रिंग्स हैं। उनकी मेलिंग सूची में सवाल केवल जवाब देने के लिए पैदा हुआ। इन जटिलताओं के कारण, इसमें चार चरों से बचने के लिए सबसे अच्छा है ERDDAP™ और जब भी संभव हो स्ट्रिंग चर का उपयोग करें।
* पारंपरिक रूप से .nc 3 फाइलें केवल ASCII-encoded के साथ समर्थित तार (7-बिट, #0 - #127) वर्ण। एनयूजी (और ERDDAP ) कि विस्तार (शुरू ~2017) "ISO-8859-1" के मूल्य के साथ विशेषता "\\_Encoding" सहित (ASCII का विस्तार जो प्रत्येक 8-बिट चरित्र के सभी 256 मूल्यों को परिभाषित करता है) या "UTF-8" यह इंगित करने के लिए कि स्ट्रिंग डेटा को कैसे एन्कोड किया गया है। अन्य एन्कोडिंग कानूनी हो सकते हैं लेकिन इन्हें हतोत्साहित किया जा सकता है।
         
####  .nc 4 फाइलें{#nc4-files} 
*    .nc 4 फाइलें सभी का समर्थन करती हैं ERDDAP डेटा प्रकार।
    
#### NCCSV{#nccsv-files} 
NCCSV 1.0 फाइलें किसी भी निर्दिष्ट पूर्णांक डेटा प्रकार का समर्थन नहीं करती हैं।
 [NCCSV 1.1+ फाइलें](/docs/user/nccsv-1.00) सभी निर्दिष्ट पूर्णांक डेटा प्रकारों का समर्थन करते हैं।
     
####  DAP  {#dap} 
*   (OPeN)DAP  (.das, .dds, .asc ASCII फ़ाइलें, और .dods द्विआधारी फ़ाइलें) -
    *   (OPeN)DAPशॉर्ट, ushort, int, uint, फ्लोट और डबल मूल्यों को सही ढंग से संभालती है।
    *   (OPeN)DAPएक "बाइट" डेटा प्रकार है कि यह असाइन किया गया है, जबकि ऐतिहासिक रूप से, THREDDS और ERDDAP™ उनके द्वारा हस्ताक्षरित "बाइट" का इलाज किया गया है(OPeN)DAPसेवाएं इससे बेहतर निपटने के लिए, ERDDAP™ 2.10+ NUG मानक का अनुसरण करता है और हमेशा डेटा क्या है, यह इंगित करने के लिए "true" या "false" के मूल्य के साथ एक "\\_Unsigned" विशेषता जोड़ता है। ERDDAP™ byte or ubyte. सभी बाइट और यूबाइट विशेषताओं को हस्ताक्षरित मूल्यों (जैसे, एक ubyte) के साथ "बाइट" विशेषताओं के रूप में लिखा जाता है। actual\\_range मान 0 से 255 के साथ विशेषता, मान 0 से -1 के साथ एक बाइट विशेषता के रूप में प्रकट होती है (बाहरी रेंज मान के दो के पूरक मूल्य के विपरीत)। यह जानने का कोई आसान तरीका नहीं है कि "बाइट" विशेषताओं को यूबाइट विशेषताओं के रूप में पढ़ा जाना चाहिए।
    *   (OPeN)DAPहस्ताक्षरित या असाइन किए गए लंबे समय का समर्थन नहीं करता है। ERDDAP™ इससे निपटने के लिए अस्थायी रूप से उन्हें डबल वेरिएबल और विशेषताओं में परिवर्तित करने के लिए। डबल्स बिल्कुल 9,007,199,254,740,992 तक सभी मूल्यों का प्रतिनिधित्व कर सकते हैं जो 2^53 है। यह एक अपूर्ण समाधान है। OPeNDAP   (संगठन) मामूली उन्नयन करने से इनकार कर दिया DAP 2.0 इस और संबंधित समस्याओं से निपटने के लिए, उद्धृत करना DAP 4 (एक प्रमुख बदलाव) समाधान के रूप में।
    * क्योंकि(OPeN)DAPतकनीकी रूप से केवल 1-byte ASCII वर्णों का समर्थन नहीं करता है (#0 - #127) स्ट्रिंग्स में चार डेटा चर 1-character-long स्ट्रिंग्स के रूप में दिखाई देंगे(OPeN)DAP.das, .dds, और .dods प्रतिक्रियाओं।
    * तकनीकी रूप से,(OPeN)DAPविनिर्देश केवल ASCII-encoded वर्णों के साथ तारों का समर्थन करता है (#0 - #127) । एनयूजी (और ERDDAP ) कि विस्तार (शुरू ~2017) "ISO-8859-1" के मूल्य के साथ विशेषता "\\_Encoding" सहित (ASCII का विस्तार जो प्रत्येक 8-बिट चरित्र के सभी 256 मूल्यों को परिभाषित करता है) या "UTF-8" यह इंगित करने के लिए कि स्ट्रिंग डेटा को कैसे एन्कोड किया गया है। अन्य एन्कोडिंग कानूनी हो सकते हैं लेकिन इन्हें हतोत्साहित किया जा सकता है।
         
### डेटा प्रकार टिप्पणियाँ{#data-type-comments} 
* कई फ़ाइल प्रकारों में लंबे, ulong और char डेटा के लिए खराब समर्थन के कारण, हम इन डेटा प्रकारों के उपयोग को हतोत्साहित करते हैं ERDDAP । जब संभव हो, तो लंबे और लंबे समय तक डबल का उपयोग करें और चार के बजाय स्ट्रिंग का उपयोग करें।
     
* मेटाडाटा - क्योंकि(OPeN)DAP'.das and .dds प्रतिक्रियाओं लंबे या ulong विशेषताओं या डेटा प्रकारों का समर्थन नहीं करते हैं (इसके बजाय उन्हें डबल्स के रूप में दिखाते हैं) , आप इसके बजाय उपयोग करना चाहते हैं ERDDAP मेटाडाटा के सारणीबद्ध प्रतिनिधित्व के रूप में देखा गया http .../erddap/ **जानकारी** / * datasetID * Web page (उदाहरण के लिए, [https://coastwatch.pfeg.noaa.gov/erddap/info/cwwcNDBCMet/index.html](https://coastwatch.pfeg.noaa.gov/erddap/info/cwwcNDBCMet/index.html)  )   (जो आप अन्य फ़ाइल प्रकारों में भी प्राप्त कर सकते हैं, उदाहरण के लिए, .csv, .htmlTable , .itx , .json , .jsonlCSV1 , .jsonlCSV , .jsonlKVP , .mat , .nc , .nccsv , .tsv , .xhtml ) या .nccsv मेटाडाटा प्रतिक्रिया (उदाहरण के लिए, [https://coastwatch.pfeg.noaa.gov/erddap/tabledap/cwwcNDBCMet.nccsvMetadata](https://coastwatch.pfeg.noaa.gov/erddap/tabledap/cwwcNDBCMet.nccsvMetadata) हालांकि .nccsv मेटाडाटा केवल सारणीबद्ध डेटासेट के लिए उपलब्ध है) दोनों डेटा प्रकारों का समर्थन करते हैं (विशेष रूप से, लंबे, लंबे समय तक, और char) ।
         
### मीडिया फ़ाइलें{#media-files} 
सभी डेटा संख्याओं या पाठ के सरणी नहीं हैं। कुछ डेटासेट में मीडिया फ़ाइलों जैसे छवि, ऑडियो और वीडियो फ़ाइलों को शामिल या शामिल किया गया है। ERDDAP™ उपयोगकर्ताओं के लिए मीडिया फ़ाइलों तक पहुंच प्राप्त करना आसान बनाने के लिए कुछ विशेष सुविधाएँ हैं। यह दो चरण प्रक्रिया है:
 

1. प्रत्येक फ़ाइल को अपने स्वयं के URL के माध्यम से सुलभ बनाएं, एक प्रणाली के माध्यम से जो बाइट रेंज अनुरोधों का समर्थन करता है।
ऐसा करने का सबसे आसान तरीका यह है कि फ़ाइलों को एक निर्देशिका में डाल दिया जाए ERDDAP™ पहुँच है। (अगर वे एक कंटेनर में हैं, तो एक कंटेनर की तरह .zip फ़ाइल, उन्हें खोलना, हालांकि आप पेशकश करना चाहते हैं .zip उपयोगकर्ताओं के लिए भी फाइल करें।) फिर, बनाना [EDDTableFromFileNames](#eddtablefromfilenames) उन फ़ाइलों को सुलभ बनाने के लिए डेटासेट ERDDAP™ विशेष रूप से ERDDAP ' [ "files" प्रणाली](https://coastwatch.pfeg.noaa.gov/erddap/files/documentation.html) ।
    
EDDTableFromFileNames के माध्यम से सुलभ सभी फाइलें और ERDDAP ' "files" सिस्टम समर्थन [byte रेंज अनुरोध](https://en.wikipedia.org/wiki/Byte_serving) । आम तौर पर, जब एक ग्राहक (उदाहरण के लिए, एक ब्राउज़र) यूआरएल को अनुरोध करता है, यह पूरी फ़ाइल को प्रतिक्रिया के रूप में प्राप्त करता है। लेकिन एक बाइट रेंज अनुरोध के साथ, अनुरोध फ़ाइल से बाइट्स की एक श्रृंखला को निर्दिष्ट करता है, और सर्वर केवल उन बाइट्स को लौटाता है। यह यहां प्रासंगिक है क्योंकि ब्राउज़रों में ऑडियो और वीडियो प्लेयर केवल तभी काम करते हैं जब फ़ाइल को बाइट रेंज अनुरोधों के माध्यम से एक्सेस किया जा सकता है।
    
वैकल्पिक: यदि आपके पास संबद्ध मीडिया फ़ाइलों के साथ एक से अधिक डेटासेट है, तो आप केवल एक EDDTableFromFileNames बना सकते हैं, जिसमें फ़ाइलों के प्रत्येक समूह के लिए एक सबफ़ोल्डर है। लाभ यह है कि जब आप एक नए डेटासेट के लिए नई मीडिया फ़ाइलों को जोड़ना चाहते हैं, तो आपको बस एक नया फ़ोल्डर बनाना होगा और उस फ़ोल्डर में फ़ाइलों को डाल देना होगा। फ़ोल्डर और फ़ाइलों को स्वचालित रूप से EDDTableFromFileNames डेटासेट में जोड़ा जाएगा।
    
2. वैकल्पिक: यदि आपके पास एक डेटासेट है जिसमें मीडिया फ़ाइलों के संदर्भ शामिल हैं, तो इसे इसमें जोड़ें ERDDAP ।
उदाहरण के लिए, आपके पास प्रत्येक बार किसी ने व्हेल और एक कॉलम देखा, जिसमें उस दृष्टि से संबंधित एक छवि फ़ाइल का नाम शामिल है, एक पंक्ति के साथ एक .csv फ़ाइल हो सकती है। यदि छवि फ़ाइल का नाम सिर्फ फ़ाइल नाम है, उदाहरण के लिए, Img20141024T192403Z, एक पूर्ण यूआरएल नहीं है, तो आपको जोड़ने की आवश्यकता है [फ़ाइल AccessBase Url and/or fileAccessSuffix](#fileaccessbaseurl) इसके लिए मेटाडाटा की विशेषता dataVariable जो उन फाईलनामों के लिए baseURL और suffix निर्दिष्ट करता है। यदि आपने EDDTableFromFileNames के माध्यम से सुलभ फ़ाइलों को बनाया है, तो URL फॉर्म में होगा।
     *बेस* /erddap/files/ * datasetID * /
उदाहरण के लिए,
```
        <att name="fileAccessBaseUrl">*someBaseURL*</a>  
        <att name="fileAccessSuffix">.png</a>
```
        
अगर वहाँ है .zip या किसी अन्य कंटेनर फ़ाइल के साथ सभी मीडिया फ़ाइलों से संबंधित डेटा चर, हम अनुशंसा करते हैं कि आप उस फ़ाइल को उपयोगकर्ताओं के लिए सुलभ बना सकें (ऊपर देखें) और फिर इसे एक साथ पहचानें [फ़ाइल Url](#fileaccessarchiveurl) विशेषता।
    

 \\[ शुरू ERDDAP™ v1.82 \\] यदि आप ऊपर पहला कदम रखते हैं (दोनों चरणों) तब जब कोई उपयोगकर्ता विचार करता है ERDDAP™   "files" उस डेटासेट के लिए सिस्टम (या एक के माध्यम से डेटासेट की एक सबसेट देखने के लिए पूछता है .htmlTable यदि आप दूसरे चरण में थे तो अनुरोध करें) , ERDDAP™ फ़ाइल नाम के बाईं ओर एक '?' आइकन दिखाई देगा। यदि उपयोगकर्ता उस आइकन पर होवर्स करता है, तो वे एक पॉपअप छवि, या एक ऑडियो प्लेयर, या एक वीडियो प्लेयर दिखा देंगे। ब्राउज़र केवल सीमित संख्या में प्रकारों का समर्थन करते हैं

* छवि (आमतौर पर .gif, .jpg, और .png) ,
* ऑडियो (आमतौर पर .mp3, .ogg, और .wav) , और
* वीडियो फ़ाइलों (आमतौर पर .mp4, .ogv, और .mp4। वेब) ।

समर्थन विभिन्न ऑपरेटिंग सिस्टम पर विभिन्न ब्राउज़रों के विभिन्न संस्करणों के साथ भिन्न होता है। इसलिए यदि आपके पास एक विकल्प है जिसमें फ़ाइल प्रकार की पेशकश की जाती है, तो यह इन प्रकार की पेशकश करने के लिए समझ में आता है।

यदि कोई उपयोगकर्ता फ़ाइल नाम पर क्लिक करता है तो एक पर दिखाया गया है ERDDAP™ वेब पेज, उनके ब्राउज़र को एक अलग वेब पेज के रूप में छवि, ऑडियो या वीडियो फ़ाइल दिखाई देगा। यह एक बहुत बड़ी छवि या वीडियो को पूरी स्क्रीन पर स्केल करने के लिए उपयोगी है, बजाय एक पॉपअप में।
    
### AWS S3 Files के साथ काम करना{#working-with-aws-s3-files} 
 [अमेज़न वेब सेवा (एडब्ल्यूएस) ](https://aws.amazon.com) एक विक्रेता है [क्लाउड कंप्यूटिंग](https://en.wikipedia.org/wiki/Cloud_computing) सेवाएं [S3](https://aws.amazon.com/s3/) AWS द्वारा प्रस्तावित एक ऑब्जेक्ट स्टोरेज सिस्टम है। एक पारंपरिक फ़ाइल सिस्टम की निर्देशिकाओं और फ़ाइलों की पदानुक्रम प्रणाली के बजाय (अपने पीसी में हार्ड ड्राइव की तरह) , S3 सिर्फ "buckets" प्रदान करता है जो "objects" पकड़ता है (हम उन्हें कॉल करेंगे "files" ) ।

ASCII फ़ाइलों के लिए (उदाहरण के लिए, csv) , ERDDAP™ सीधे बाल्टी में फ़ाइलों के साथ काम कर सकते हैं। केवल वही चीज जो आपको करना है उसे निर्दिष्ट करें&lt;AWS बाल्टी के लिए एक विशिष्ट प्रारूप का उपयोग करके डेटासेट के लिए फ़ाइलDir&gt;, उदाहरण के लिए,https://*bucketName*.s3.*aws-region*.amazonaws.com/*subdirectory*/। आपको उपयोग नहीं करना चाहिए&lt;CashFromUrl&gt;। विवरण के लिए नीचे देखें।

लेकिन द्विआधारी फ़ाइलों के लिए (उदाहरण के लिए .nc , .grib, .bufr, और .hdf फ़ाइलें) , आपको उपयोग करने की आवश्यकता है&lt;CashFromUrl&gt; प्रणाली नीचे वर्णित है। ERDDAP , netcdfjava (जो ERDDAP™ इन फ़ाइलों से डेटा पढ़ने के लिए उपयोग करता है) , और अन्य वैज्ञानिक डेटा सॉफ्टवेयर को पारंपरिक फ़ाइल सिस्टम में फ़ाइलों के साथ काम करने के लिए डिज़ाइन किया गया है जो प्रदान करता है [ब्लॉक स्तर](https://en.wikipedia.org/wiki/Block-level_storage) फ़ाइलों तक पहुंच (जो किसी फ़ाइल के पढ़ने वाले हिस्से की अनुमति देता है) लेकिन केवल S3 प्रदान करता है [फाइल का स्तर (वस्तु) ](https://en.wikipedia.org/wiki/Block-level_storage) फ़ाइलों तक पहुंच (जो केवल संपूर्ण फ़ाइल पढ़ने की अनुमति देता है) । AWS S3 का विकल्प प्रदान करता है, [लोचदार ब्लॉक स्टोर (EBS) ](https://aws.amazon.com/ebs/) ), जो फ़ाइलों के लिए ब्लॉक स्तर की पहुंच का समर्थन करता है लेकिन यह S3 की तुलना में अधिक महंगा है, इसलिए इसका उपयोग शायद ही कभी बड़ी मात्रा में डेटा फ़ाइलों के थोक भंडारण के लिए किया जाता है। (इसलिए जब लोग क्लाउड में डेटा संग्रहीत करते हैं (S3) यह आमतौर पर नारंगी तुलना के लिए एक सेब है।) 

#### S3 बाल्टी{#s3-buckets} 
 **एक बाल्टी की सामग्री। कुंजी ऑब्जेक्ट्स। Delimiters।**   
तकनीकी रूप से, कंप्यूटर पर एक फ़ाइल सिस्टम की तरह एक पदानुक्रमिक फ़ाइल संरचना में S3 बाल्टी का आयोजन नहीं किया जाता है। इसके बजाय, बाल्टी में केवल "objects" होते हैं। (फ़ाइलें) जिनमें से प्रत्येक में "की" है (नाम) । उस noaa-goes17 बाल्टी में एक कुंजी का उदाहरण है

```
ABI-L1b-RadC/2019/235/22/OR\\_ABI-L1b-RadC-M6C01\\_G17\\_s20192352201196\\_e20192352203569\\_c20192352204013.nc
```
उस वस्तु के लिए संबंधित यूआरएल है

 [https://noaa-goes17.s3.us-east-1.amazonaws.com/ABI-L1b-RadC/2019/235/22/OR\\_ABI-L1b-RadC-M6C01\\_G17\\_s20192352201196\\_e20192352203569\\_c20192352204013.nc](https://noaa-goes17.s3.us-east-1.amazonaws.com/ABI-L1b-RadC/2019/235/22/OR_ABI-L1b-RadC-M6C01_G17_s20192352201196_e20192352203569_c20192352204013.nc) 

AWS उस URL का निर्माण करने के तरीके में थोड़ा भिन्नता का समर्थन करता है, लेकिन ERDDAP™ इस एक विशिष्ट प्रारूप की आवश्यकता है:
  https://*bucketName*.s3.*region*.amazonaws.com/*key*  

जैसा ERDDAP v2.29, अब आप उपयोग कर सकते हैं `s3` यूआरआई प्रारूप के बजाय बाल्टी यूआरएल। यह प्रारूप द्वारा उपयोग किया जाता है [AWS s3 cli](https://docs.aws.amazon.com/cli/latest/reference/s3/) ।
s3 *बाल्टीनाम* / *कुंजी* 

The The most of the *क्षेत्र* S3 URI के लिए तीन तरह से निर्दिष्ट किया जा सकता है:
- The The most of the *क्षेत्र* टॉमकैट उपयोगकर्ता में `~/.aws/config` प्रोफ़ाइल
- The The most of the `AWS_DEFAULT_REGION` पर्यावरण चर
- The The most of the `Aws.region` JVM चर (टॉमकैट के लिए Setenv.sh में) 

यह सामान्य अभ्यास है, जैसा कि इस उदाहरण के साथ, कुंजी नाम बनाने के लिए एक पदानुक्रमिक पथ के साथ-साथ एक फ़ाइल नाम की तरह दिखता है, लेकिन तकनीकी रूप से वे नहीं हैं। चूंकि यह आम और उपयोगी है, ERDDAP™ यदि वे एक पदानुक्रमिक पथ प्लस फ़ाइल नाम हैं तो /'s साथ कुंजी का व्यवहार करता है, और यह दस्तावेज़ उन्हें इस तरह के रूप में संदर्भित करेगा। यदि एक बाल्टी की चाबियाँ उपयोग नहीं करती हैं /'s (उदाहरण के लिए, एक कुंजी की तरह
ABI-Lib.2018.052.22.OR\\_ABI-L1b-RadM2-M3C10\\_G16\\_s20180522247575), फिर ERDDAP™ सिर्फ एक लंबे फाइल नाम के रूप में पूरी कुंजी का इलाज करेंगे।

निजी बनाम सार्वजनिक बाल्टी -- S3 बाल्टी के लिए प्रशासक बाल्टी और इसकी सामग्री को सार्वजनिक या निजी बना सकता है। यदि सार्वजनिक हो, तो बाल्टी में कोई भी फ़ाइल फाइल के लिए यूआरएल का उपयोग करके किसी को डाउनलोड किया जा सकता है। अमेज़न एक है [ओपन डेटा](https://aws.amazon.com/opendata/) प्रोग्राम जो सार्वजनिक डेटासेट की मेजबानी करता है (डेटा सहित NOAA नासा, और USGS) मुक्त करने के लिए और उन बाल्टी से फ़ाइलों को डाउनलोड करने के लिए किसी के लिए चार्ज नहीं करता है। यदि एक बाल्टी निजी है, तो बाल्टी में फाइलें केवल अधिकृत उपयोगकर्ताओं के लिए सुलभ हैं और AWS शुल्क लेता है (अक्सर बाल्टी के मालिक द्वारा भुगतान किया जाता है) फ़ाइलों को गैर-AWS S3 कंप्यूटर पर डाउनलोड करने के लिए। ERDDAP™ सार्वजनिक और निजी बाल्टी में डेटा के साथ काम कर सकते हैं।

#### AWS Credentials{#aws-credentials} 
ऐसा करने के लिए ERDDAP™ निजी बाल्टी की सामग्री को पढ़ सकते हैं, आपको एडब्ल्यूएस क्रेडेंशियल की आवश्यकता होती है और आपको मानक स्थान पर एक क्रेडेंशियल फ़ाइल स्टोर करने की आवश्यकता होती है। ERDDAP™ जानकारी प्राप्त कर सकते हैं। के लिए AWS SDK देखें Java 2.x प्रलेखन: [डिफ़ॉल्ट क्रेडेंशियल सेट](https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/setup.html#setup-credentials) । (मानों को स्टोर करने का विकल्प Java में कमांड लाइन पैरामीटर \\[ tomcat \\] /bin/setenv.sh एक अच्छा विकल्प हो सकता है।) 
#### AWS/files/{#aws-files} 
* / फ़ाइल / सिस्टम -- The The most of the ERDDAP™   [/ फ़ाइल / प्रणाली](#accessibleviafiles) उपयोगकर्ताओं को डेटासेट के लिए स्रोत फ़ाइलों को डाउनलोड करने की अनुमति देता है। हम अनुशंसा करते हैं कि आप इसे स्रोत फ़ाइलों के साथ सभी डेटासेट के लिए बदल दें क्योंकि कई उपयोगकर्ता मूल स्रोत फ़ाइलों को डाउनलोड करना चाहते हैं।
    * यदि फाइलें एक निजी S3 बाल्टी में हैं, तो उपयोगकर्ता के अनुरोध को डाउनलोड करने के लिए एक फ़ाइल द्वारा नियंत्रित किया जाएगा ERDDAP™ , जो डेटा को फ़ाइल से पढ़ेगा और फिर इसे उपयोगकर्ता को प्रेषित करेगा, इस प्रकार लोड को आपके पास बढ़ा देगा ERDDAP™ , आने वाले और आउटगोइंग बैंडविड्थ का उपयोग करके, और आपको बनाना (The number of the ERDDAP™ व्यवस्थापक) AWS को डेटा egress शुल्क का भुगतान करें।
    * यदि फाइलें सार्वजनिक S3 बाल्टी में हैं, तो उपयोगकर्ता के अनुरोध को डाउनलोड करने के लिए फ़ाइल को उस फाइल के लिए AWS S3 URL पर रीडायरेक्ट किया जाएगा, इसलिए डेटा प्रवाहित नहीं होगा। ERDDAP™ इस प्रकार लोड को कम करना ERDDAP । और अगर फाइलें अमेज़न ओपन डेटा में हैं (मुक्त) सार्वजनिक बाल्टी, फिर आप (The number of the ERDDAP™ व्यवस्थापक) AWS के लिए किसी भी डेटा egress शुल्क का भुगतान नहीं करना होगा। इस प्रकार, सार्वजनिक से डेटा की सेवा करने वाला एक बड़ा लाभ है (निजी नहीं) S3 बाल्टी और अमेज़न ओपन डेटा से डेटा की सेवा के लिए एक बड़ा लाभ (मुक्त) बाल्टी।

 ERDDAP सार्वजनिक बाल्टी के लिए गुमनाम क्रेडेंशियल का भी समर्थन करता है। अनाम क्रेडेंशियल का उपयोग करने के लिए, जोड़ें ` <useAwsAnonymous> सच </useAwsAnonymous> ` अपने सेटअप.xml के लिए।

#### कस्टम S3 समापन बिंदु{#custom-s3-endpoints} 
S3 संगत वस्तु भंडारण के लिए अमेज़न द्वारा होस्ट नहीं किया गया है, आपको कॉन्फ़िगर करने की आवश्यकता है [endpoint_url](https://docs.aws.amazon.com/sdkref/latest/guide/feature-ss-endpoints.html) साथ में अपनी बाल्टी/कुंजी को एक का उपयोग करके देखना `s3` यूआरआई

The The most of the *endpoint_url* तीन तरीकों में से एक में निर्दिष्ट किया जा सकता है:
- The The most of the *endpoint_url* टॉमकैट उपयोगकर्ता में `~/.aws/config` प्रोफ़ाइल
- The The most of the `AWS_ENDPOINT_URL` पर्यावरण चर
- The The most of the `aws.endpoint Url` JVM चर (टॉमकैट के लिए Setenv.sh में) 

S3 विन्यास चर की एक पूरी सूची के लिए, [अमेज़न प्रलेखन देखें](https://docs.aws.amazon.com/cli/latest/topic/config-vars.html) ।

 **स्व-signed प्रमाणपत्र** 
स्व-होस्टेड एस 3 बाल्टी के लिए, आपके पास अक्सर स्वयं-सिग्न एसएसएल प्रमाणपत्र होंगे। के लिए ERDDAP इन बाल्टी से पढ़ने के लिए, आपको अपने प्रमाणपत्र श्रृंखला को JVM ट्रस्टस्टोर में जोड़ने की आवश्यकता है `$JAVA_HOME/jre/lib/security/cacert` । इसके अतिरिक्त, ERDDAP उपयोग [AWS कॉमन रनटाइम](https://docs.aws.amazon.com/sdkref/latest/guide/common-runtime.html) अतुल्यकालिक रूप से बाल्टी तक पहुंचने के लिए। यह प्रदर्शन को बढ़ाता है, लेकिन यह भी आवश्यक है कि आपके स्वयं के हस्ताक्षरित प्रमाणपत्र आपके OS विशिष्ट ट्रस्टस्टोर में जुड़ जाएँ। यदि आप ऐसा करने से बचना चाहते हैं, तो आप AWS CRT को अक्षम कर सकते हैं। ` <useAwsCrt> झूठ </useAwsCrt> ` अपने सेटअप.xml में।

####  ERDDAP™ AWS S3 बाल्टी{#erddap-and-aws-s3-buckets} 
 [ ** ERDDAP™ AWS S3 बाल्टी** ](#erddap-and-aws-s3-buckets)   
सौभाग्य से, बहुत प्रयास के बाद, ERDDAP™ इसमें कई विशेषताएं हैं जो इसे S3 के ब्लॉक लेवल एक्सेस के साथ काम करने की अंतर्निहित समस्याओं से निपटने की अनुमति देती हैं।

*    \\[ अस्वीकरण: AWS S3 बाल्टी के साथ काम करना अतिरिक्त काम का एक बहुत है। AWS सेवाओं और सुविधाओं का एक विशाल पारिस्थितिकी तंत्र है। सीखने के लिए बहुत कुछ है। यह समय और प्रयास लेता है, लेकिन यह संभव है। रोगी बनें और आपको काम करने के लिए चीजें मिल जाएंगी। मदद के लिए देखो / ask
(a) [AWS प्रलेखन](https://aws.amazon.com/documentation/gettingstarted/) , जैसे वेबसाइट [स्टैक ओवरफ्लो](https://stackoverflow.com/) नियमित
     [ ERDDAP™ समर्थन विकल्प](/docs/intro#support) यदि आप अटक जाते हैं तो? \\]   
     
* यह भी एक S3 बाल्टी में फ़ाइलों के निर्देशिका संरचना और फ़ाइल नाम पता करने के लिए मुश्किल हो सकता है। ERDDAP™ इस समस्या का समाधान है: EDDTableFromFileNames एक विशेष समाधान है [\\*\\** FromOnTheFly](#fromonthefly) विकल्प जो आपको EDDTableFromFileNames Dataset बनाने देता है जो उपयोगकर्ताओं को S3 बाल्टी की सामग्री ब्राउज़ करने की अनुमति देता है। (फ़ाइल डाउनलोड करें) डेटासेट के माध्यम से "files" विकल्प वहाँ एक है [नीचे दिए गए उदाहरण](#viewing-the-contents-of-a-bucket) ।
     
*    ERDDAP™ से डेटा पढ़ सकते हैं [बाह्य रूप से संकुचित डेटा फ़ाइलों](#externally-compressed-files) यदि S3 पर फ़ाइलों को संग्रहीत किया जाता है तो यह ठीक है। .gz , .gzip , .bz2 बाहरी रूप से संपीड़ित डेटा फ़ाइलों के अन्य प्रकार जो नाटकीय रूप से हो सकते हैं (2 - 20X) फ़ाइल भंडारण लागत पर कटौती। बाह्य रूप से संपीड़ित फ़ाइलों का उपयोग करने के लिए अक्सर कोई समय दंड नहीं होता है, क्योंकि समय S3 से S3 तक एक छोटी फाइल को स्थानांतरित करके बचाया जाता है। ERDDAP मोटे तौर पर अतिरिक्त समय के लिए आवश्यक संतुलन ERDDAP™ फ़ाइल को डीकंप्रेस करने के लिए। इस सुविधा का उपयोग करने के लिए, आपको यह सुनिश्चित करना होगा कि डेटासेट का डेटासेट है।&lt;फ़ाइल नाम Regex&gt; संपीड़ित फ़ाइल प्रकार के लिए अनुमति देता है (उदाहरण के लिए, जोड़कर ( |  .gz ) रेगेक्स के अंत तक) ।
     
* सबसे आम मामले के लिए, जहां आपके पास एक है ERDDAP™ परीक्षण / विकास के लिए अपने पीसी पर स्थापित किया गया है और जहां डेटासेट में द्विआधारी डेटा फाइलें होती हैं जो S3 बाल्टी में वस्तुओं के रूप में संग्रहीत होती हैं, एक दृष्टिकोण में डेटासेट प्राप्त करने के लिए। ERDDAP™ है:
    1. कुछ परीक्षण डेटा फ़ाइलों को रखने के लिए अपने पीसी पर एक निर्देशिका बनाएं।
    2. स्रोत से दो डेटा फ़ाइलों को आपके द्वारा बनाई गई निर्देशिका में डाउनलोड करें।
    3. उपयोग [जनरेट DatasetXml](#generatedatasetsxml) का हिस्सा उत्पन्न करने के लिए datasets.xml दो स्थानीय डेटा फ़ाइलों के आधार पर डेटासेट के लिए।
    4. जांचें कि डेटासेट वांछित के रूप में काम करता है [दास](#dasdds) और/या अपने स्थानीय ERDDAP ।
        
         **निम्नलिखित कदम उस डेटासेट की एक प्रति बनाते हैं (जो S3 बाल्टी से डेटा प्राप्त करेगा) सार्वजनिक ERDDAP ।** 
        
    5. का हिस्सा कॉपी datasets.xml डेटासेट के लिए datasets.xml जनता के लिए ERDDAP™ यह डेटा की सेवा करेगा।
    6. जनता पर निर्देशिका बनाएं ERDDAP 'स्थानीय हार्ड ड्राइव अस्थायी फ़ाइलों का कैश रखने के लिए। निर्देशिका डिस्क स्थान का एक बहुत उपयोग नहीं करेगा (नीचे कैशSizeGB देखें) ।
    7. डेटासेट का मूल्य बदलें&lt;फ़ाइलDir&gt; टैग ताकि यह आपके द्वारा बनाई गई निर्देशिका को इंगित करता है (हालांकि निर्देशिका खाली है) ।
    8. जोड़ें [कैशFromUrl](#cachefromurl) टैग जो डेटासेट के बाल्टी नाम और वैकल्पिक उपसर्ग को निर्दिष्ट करता है (i.e., निर्देशिका) विशिष्ट में [Aws S3 URL प्रारूप कि ERDDAP™ आवश्यकता](#accessing-files-in-an-aws-s3-bucket) ।
    9. जोड़ना [&lt;कैशSizeGB&gt; (#cachefromurl) डेटासेट के xml को टैग करें (उदाहरण के लिए, 10 अधिकांश डेटासेट के लिए एक अच्छा मूल्य है) बताने के लिए ERDDAP™ स्थानीय कैश के आकार को सीमित करने के लिए (यानी, सभी दूरस्थ फ़ाइलों को कैश करने की कोशिश न करें) ।
    10. देखें कि क्या यह जनता में काम करता है ERDDAP । ध्यान दें कि पहली बार ERDDAP™ डेटासेट लोड करता है, यह लोड करने के लिए लंबे समय तक ले जाएगा क्योंकि ERDDAP™ सभी डेटा फ़ाइलों को डाउनलोड करने और पढ़ने की आवश्यकता है।
        
यदि डेटासेट विशाल ग्रिड डेटा फ़ाइलों का एक विशाल संग्रह है, तो यह बहुत लंबे समय तक ले जाएगा और अव्यवहारिक होगा। कुछ मामलों में, ग्रिड डेटा फ़ाइलों के लिए, ERDDAP™ आवश्यक जानकारी निकाल सकते हैं (उदाहरण के लिए, एक ग्रिड डेटा फ़ाइल में डेटा के लिए समय बिंदु) फ़ाइल नाम से और इस समस्या से बचने के लिए। देखें [द्वारा एकत्रीकरण फ़ाइल का नाम](#aggregation-via-file-names-or-global-metadata) ।
        
    11. वैकल्पिक (लेकिन विशेष रूप से EDDTableFromFiles डेटासेट के लिए) , आप जोड़ सकते हैं [nThread](#nthreads) डेटासेट को टैग करने के लिए ERDDAP डेटा के लिए उपयोगकर्ता के अनुरोध का जवाब देते समय 1 से अधिक थ्रेड का उपयोग करना। यह देरी के प्रभावों को कम करता है जो तब होता है जब ERDDAP™ डेटा फ़ाइलों को पढ़ने से (दूरस्थ) AWS S3 बाल्टी स्थानीय कैश में और (शायद) उन्हें नष्ट करना।

#### AWS S3 Open Data{#aws-s3-open-data} 
के भाग के रूप में NOAA ' [बिग डेटा प्रोग्राम](https://www.noaa.gov/nodd/about) , NOAA AWS सहित पांच संगठनों के साथ साझेदारी की है, "बाद में प्रमुख अवलोकनों और मॉडल आउटपुट की प्रतियों को संग्रहीत करने के संभावित लाभों का पता लगाने के लिए बिना किसी वितरण की आवश्यकता के सीधे डेटा पर गणना करने की अनुमति दी जाती है। AWS में डेटासेट शामिल है जो इसे से मिलता है NOAA अपने कार्यक्रम के एक हिस्से के रूप में सार्वजनिक पहुंच की पेशकश करने के लिए [AWS S3 पर खुला डेटा](https://registry.opendata.aws/) किसी भी कंप्यूटर से, चाहे वह अमेज़न कम्प्यूट उदाहरण हो (किराए पर कंप्यूटर) AWS नेटवर्क या किसी भी नेटवर्क पर अपने पीसी पर। नीचे दिए गए उदाहरण के अनुसार आप सार्वजनिक रूप से सुलभ डेटासेट के साथ काम कर रहे हैं।

#### AWS S3 बाल्टी में फ़ाइलों को एक्सेस करना{#accessing-files-in-an-aws-s3-bucket} 
एक निजी S3 डेटा बाल्टी के लिए, बाल्टी के मालिक को आपको बाल्टी तक पहुंच देना होगा। (AWS प्रलेखन देखें।) 

सभी मामलों में, आपको AWS खाता की आवश्यकता होगी क्योंकि AWS SDK के लिए Java   (जो ERDDAP™ एक बाल्टी की सामग्री के बारे में जानकारी पुनर्प्राप्त करने के लिए उपयोग करता है) AWS खाता क्रेडेंशियल की आवश्यकता है। (नीचे) 

 ERDDAP™ अगर आप निर्दिष्ट करते हैं तो केवल AWS S3 बाल्टी तक पहुंच सकते हैं [&lt;CashFromUrl&gt; (#cachefromurl) (or)&lt;एक विशिष्ट प्रारूप में फ़ाइलDir&gt;:
https://*bucketName*.s3.*aws-region*.amazonaws.com/*prefix/*  
कहाँ

* बाल्टीनाम बाल्टी नाम का छोटा रूप है, उदाहरण के लिए noaa-goes17।
* Aws-region, उदाहरण के लिए, us-east-1, "Region" कॉलम से एक सारणी में है। [AWS सेवा समापन बिंदु](https://docs.aws.amazon.com/general/latest/gr/rande.html) जहां बाल्टी वास्तव में स्थित है।
* उपसर्ग वैकल्पिक है। यदि आप उपस्थित हैं, तो इसके साथ समाप्त होना चाहिए '/' ।

उदाहरण के लिए,https://noaa-goes17.s3.us-east-1.amazonaws.com/ABI-L1b-RadC/  
यह URL प्रारूप AWS S3 सिफारिशों में से एक है: देखें [एक बाल्टी तक पहुंचना](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingBucket.html) और [यह विवरण उपसर्ग](https://docs.aws.amazon.com/AmazonS3/latest/dev/ListingKeysHierarchy.html) । ERDDAP™ की आवश्यकता है कि आप बाल्टी यूआरएल और वैकल्पिक उपसर्ग को एक URL में जोड़ते हैं ताकि निर्दिष्ट किया जा सके।&lt;कैशFromUrl&gt; (या&lt;फ़ाइलDir&gt;

#### टेस्ट पब्लिक AWS S3 बाल्टी{#test-public-aws-s3-buckets} 
सार्वजनिक बाल्टी के लिए, आप कर सकते हैं और अपने ब्राउज़र में AWS S3 निर्देशिका के बाल्टी URL का परीक्षण करना चाहिए, उदाहरण के लिए,
 [https://noaa-goes17.s3.us-east-1.amazonaws.com](https://noaa-goes17.s3.us-east-1.amazonaws.com) यदि बाल्टी यूआरएल सही है और उपयुक्त है ERDDAP यह एक XML दस्तावेज़ वापस कर देगा, जिसने XML दस्तावेज़ को वापस कर दिया है। (आंशिक) उस बाल्टी की सामग्री की सूची। दुर्भाग्य से, पूर्ण यूआरएल (यानी, बाल्टी यूआरएल प्लस उपसर्ग) कि ERDDAP™ किसी दिए गए डेटासेट के लिए एक ब्राउज़र में काम नहीं करता है। AWS अपने ब्राउज़र में आसानी से बाल्टी के पदानुक्रम को ब्राउज़ करने के लिए एक प्रणाली की पेशकश नहीं करता है। (यदि वह गलत है, तो कृपया क्रिस को ईमेल करें। जॉन at noaa.gov. अन्यथा, अमेज़न, कृपया इसके लिए समर्थन जोड़ें&#33;) 

#### एक बाल्टी की सामग्री देखना{#viewing-the-contents-of-a-bucket} 
S3 बाल्टी में अक्सर कुछ श्रेणियों की फाइलें होती हैं, कुछ छद्म उपनिर्देशों में, जो एक जोड़ी बन सकती हैं। ERDDAP™ डेटासेट बनाने के लिए ERDDAP™ डेटासेट, आपको प्रारंभिक निर्देशिका के लिए जानने की आवश्यकता है&lt;कैशFromUrl&gt; (या&lt;फ़ाइलDir&gt; और फ़ाइल नामों का प्रारूप जो फ़ाइलों की उस सबसेट की पहचान करता है। यदि आप किसी ब्राउज़र में बाल्टी की पूरी सामग्री को देखने की कोशिश करते हैं, तो S3 आपको पहली 1000 फाइलें दिखाएगा, जो अपर्याप्त है। वर्तमान में, आपके लिए एक बाल्टी की सभी सामग्री को देखने का सबसे अच्छा तरीका है [EDDTableFromFileNames](#eddtablefromfilenames) डेटासेट (अपने पीसी पर ERDDAP™ और/या अपनी जनता पर ERDDAP ) , जो आपको निर्देशिका संरचना और डाउनलोड फ़ाइलों को ब्राउज़ करने का एक आसान तरीका भी देता है। The The most of the&lt;फ़ाइलDir&gt; इसके लिए वह URL होगा जिसे आपने ऊपर बनाया है, उदाहरण के लिए,https://noaa-goes17.s3.us-east-1.amazonaws.com। \\[ क्यों नहीं करता AWS S3 किसी को भी AWS खाते के बिना ऐसा करने का एक त्वरित और आसान तरीका प्रदान करता है? \\] ध्यान दें कि जब मैं अपने पीसी पर एक गैर-अमेज़न नेटवर्क पर ऐसा करता हूं, तो ऐसा लगता है कि अमेज़ॅन एक ट्रिकल के जवाब को धीमा कर देता है (लगभग 100 (?) प्रति चंक) पहले कुछ हिस्सों के बाद (1000 फ़ाइलों का प्रति हिस्सा) डाउनलोड किया गया है। चूंकि बाल्टी में बड़ी संख्या में फाइलें हो सकती हैं (Noaa-goes17 है 26 मिलियन) एक बाल्टी की सभी सामग्री प्राप्त करने से EDDTableFromFileNames कई घंटे लग सकते हैं। (उदाहरण के लिए, 12&#33;) समाप्त करना \\[ अमेज़न क्या है? \\] 

#### EDDTable AWS S3 बाल्टी के साथ FileNames Dataset से{#making-an-eddtablefromfilenames-dataset-with-an-aws-s3-bucket} 
यदि आपके पास एक बाल्टी का नाम है, लेकिन पहले से ही S3 बाल्टी में फ़ाइलों की एक सूची नहीं है, जो बाल्टी में प्रासंगिक फ़ाइलों के स्थान की पहचान करता है, तो EDDTableFromFileNames डेटासेट बनाने के लिए नीचे दिए गए निर्देशों का उपयोग करें ताकि आप S3 बाल्टी के डायरेक्टरी पदानुक्रम को ब्राउज़ कर सकें। ERDDAP ' "files" प्रणाली।

1. AWS खाता खोलें
     ERDDAP™ उपयोग [AWS SDK Java ](https://docs.aws.amazon.com/sdk-for-java/index.html) AWS से बाल्टी जानकारी प्राप्त करने के लिए, इसलिए आपको आवश्यकता है [AWS खाता बनाएं और सक्रिय करें](https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/) । यह एक बहुत बड़ा काम है, जिसमें कई चीजें सीखने के लिए होती हैं।
     
2. अपने AWS क्रेडेंशियल को जहां रखें ERDDAP™ उन्हें पा सकते हैं।
निर्देशों का पालन करें [विकास के लिए एडब्ल्यूएस क्रेडेंशियल और क्षेत्र की स्थापना](https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/setup.html#setup-credentials) इसलिए ERDDAP™   (विशेष रूप से, AWS SDK के लिए Java ) अपने AWS क्रेडेंशियल को ढूंढने और उसका उपयोग करने में सक्षम होंगे। अगर ERDDAP™ नहीं मिल सकता है, आप एक देखेंगे
java.lang. IllegalArgumentException: प्रोफाइल फ़ाइल में त्रुटि नहीं होगी ERDDAP 's log.txt फ़ाइल.
    
लिनक्स और मैक ओएस के लिए Hint: क्रेडेंशियल फ़ाइल उपयोगकर्ता की होम डायरेक्टरी में होना चाहिए जो टॉमकैट चल रहा है। (और ERDDAP )   (इस अनुच्छेद के लिए, हम उपयोगकर्ता = tomcat मान लेंगे) एक फ़ाइल में ~/.aws/credentials कहा जाता है। यह नहीं मानो कि ~ /home/tomcat - वास्तव में सीडी ~ का उपयोग यह पता लगाने के लिए कि ऑपरेटिंग सिस्टम किस तरह सोचता है ~ उपयोगकर्ता के लिए=tomcat है। यदि यह मौजूद नहीं है तो निर्देशिका बनाएं। इसके अलावा, जब आप क्रेडेंशियल फ़ाइल को जगह में डाल देते हैं, तो सुनिश्चित करें कि उपयोगकर्ता और फ़ाइल के लिए समूह टोमकैट है और फिर यह सुनिश्चित करने के लिए chmod 400 क्रेडेंशियल का उपयोग करें कि फ़ाइल केवल उपयोगकर्ता=tomcat के लिए पढ़ी जाती है।
    
3. में बाल्टी यूआरएल बनाएं [प्रारूप ERDDAP™ आवश्यकता](#accessing-files-in-an-aws-s3-bucket) , उदाहरण के लिए,
     [https://noaa-goes17.s3.us-east-1.amazonaws.com](https://noaa-goes17.s3.us-east-1.amazonaws.com) , और (सार्वजनिक बाल्टी के लिए) यह सुनिश्चित करने के लिए कि यह XML दस्तावेज़ लौटाता है जिसमें उस बाल्टी की सामग्री को आंशिक रूप से सूचीबद्ध किया गया है।
     
4. उपयोग [जनरेट DatasetXml](#generatedatasetsxml) बनाना [EDDTableFromFileNames](#eddtablefromfilenames) डेटासेट:
    * प्रारंभिक निर्देशिका के लिए, इस वाक्यविन्यास का उपयोग करें:
        \\*\\*\\ *fromOnTheFly,* YourBucketUrl*
उदाहरण के लिए,
        \\*\\**OnTheFly से,https://noaa-goes17.s3.us-east-1.amazonaws.com/
    * फ़ाइल का नाम regex? *
    * Recursive? सच
    * रीलोड हरNMinutes? 10080
    *    infoUrl ?https://registry.opendata.aws/noaa-goes/
    * संस्था? NOAA 
    * सारांश? कुछ नहीं ( ERDDAP™ स्वचालित रूप से एक सभ्य सारांश तैयार करेगा।) 
    * शीर्षक? कुछ नहीं ( ERDDAP™ स्वचालित रूप से एक सभ्य शीर्षक तैयार करेगा।) सामान्य रूप से, आपको सुधार को सत्यापित करने और डेटासेट के हिस्से से पहले सुधार करने के लिए परिणामी XML को संपादित करना चाहिए। datasets.xml ।
5. यदि आप ऊपर दिए गए निर्देशों का पालन करते हैं और डेटासेट को लोड करते हैं ERDDAP , आपने EDDTableFromFiles डेटासेट बनाया है। उदाहरण के रूप में, और किसी के लिए AWS ओपन डेटा बाल्टी से फ़ाइलों को ब्राउज़ करने और डाउनलोड करने के लिए इसे आसान बनाने के लिए, हमने EDDTableFromFileNames डेटासेट बनाया है (सूची को देखें)
     [https://upwell.pfeg.noaa.gov/erddap/search/index.html?searchFor=awsS3Files\\_](https://upwell.pfeg.noaa.gov/erddap/search/index.html?searchFor=awsS3Files_) ) लगभग सभी के लिए [AWS S3 ओपन डेटा बकेट](https://registry.opendata.aws/) ।
     \\[ कुछ बाल्टी जिसमें हम शामिल नहीं थे, या तो रूट डायरेक्टरी में बड़ी संख्या में फाइलें हैं। (अधिक से अधिक समय में डाउनलोड किया जा सकता है) सार्वजनिक पहुंच की अनुमति नहीं है (क्या वे सभी को सार्वजनिक नहीं होना चाहिए?) , या अनुरोधकर्ता भुगतान बाल्टी हैं (उदाहरण के लिए, सेन्टिनेल) । \\]   
यदि आप क्लिक करते हैं "files" इन डेटासेटों में से एक के लिए लिंक, आप उस S3 बाल्टी में निर्देशिका पेड़ और फ़ाइलों को ब्राउज़ कर सकते हैं। रास्ते के कारण\\*\\*\\*OnTheFly EDDTableFromFiles काम करता है, इन निर्देशिका लिस्टिंग हमेशा पूरी तरह से अद्यतन कर रहे हैं क्योंकि ERDDAP™ उन्हें ऑन-द-फ्लाई मिलती है। यदि आप निर्देशिका के पेड़ को एक वास्तविक फ़ाइल नाम पर क्लिक करते हैं और फ़ाइल नाम पर क्लिक करते हैं, ERDDAP™ अपने अनुरोध को AWS S3 पर रीडायरेक्ट करेगा ताकि आप सीधे AWS से फाइल डाउनलोड कर सकें। फिर आप उस फ़ाइल का निरीक्षण कर सकते हैं।
    
मुसीबत?
यदि आपके EDDTableFromFiles में लोड नहीं होगा ERDDAP™   (या DasDd) एक त्रुटि संदेश के लिए log.txt फ़ाइल को देखें। यदि आप देखते हैं
java.lang. IllegalArgumentException: प्रोफ़ाइल फ़ाइल शून्य त्रुटि नहीं हो सकती है, समस्या यह है कि AWS SDK के लिए Java   (द्वारा इस्तेमाल किया ERDDAP ) क्रेडेंशियल फ़ाइल नहीं मिल रहा है। ऊपर दिए गए निर्देशों को देखें।
     

यह दुर्भाग्यपूर्ण है कि AWS केवल लोगों को सार्वजनिक बाल्टी की सामग्री देखने के लिए ब्राउज़र का उपयोग करने की अनुमति नहीं देता है।

 **फिर आप कर सकते हैं ERDDAP™ डेटासेट जो उपयोगकर्ताओं को फ़ाइलों में डेटा तक पहुंच प्रदान करते हैं।**   
में निर्देश देखें [ ERDDAP™ S3 बाल्टी](#erddap-and-aws-s3-buckets)   (ऊपर) ।
नमूना EDDTableFromFileNames डेटासेट के लिए जिसे आपने ऊपर बनाया था, यदि आप निर्देशिका के पेड़ में निर्देशिका और फ़ाइल नामों के साथ थोड़ा poking करते हैं, तो यह स्पष्ट हो जाता है कि शीर्ष स्तर निर्देशिका नाम (उदाहरण के लिए, ABI-L1b-RadC) क्या ERDDAP™ अलग डेटासेट कहेगा। आप जिस बाल्टी के साथ काम कर रहे हैं वह समान हो सकता है। तब आप अलग-अलग डेटासेट बना सकते हैं ERDDAP™ उन सभी डेटासेटों के लिए, उपयोग, उदाहरण के लिए,
https://noaa-goes17.s3.us-east-1.amazonaws.com/ABI-L1b-RadC/  
जैसा&lt;CashFromUrl&gt;। दुर्भाग्य से, इस विशेष उदाहरण के लिए, बाल्टी में डेटासेट सभी स्तर 1 या स्तर 2 डेटासेट प्रतीत होते हैं, जो स्तर 1 या स्तर 2 डेटासेट है। ERDDAP™   [विशेष रूप से अच्छा नहीं है](#dimensions) क्योंकि डेटासेट चर का एक अधिक जटिल संग्रह है जो विभिन्न आयामों का उपयोग करता है।
     
    
### NcML फाइलें{#ncml-files} 
NcML फाइलें आपको एक या अधिक मूल स्रोत में ऑन-द-फ्लाई बदलाव निर्दिष्ट करने देती हैं NetCDF   (v3)   .nc , .grib, .bufr, या .hdf   (v4 or v5) फ़ाइलें, और फिर है ERDDAP™ इलाज .nc एमएल फ़ाइलें स्रोत फ़ाइलों के रूप में। ERDDAP™ डेटासेट स्वीकार करेगा .nc जब भी मिली फ़ाइलें .nc फ़ाइलों की उम्मीद है। NcML फाइलें MUST में एक्सटेंशन है .nc मिली। देखें [ Unidata एनसीएमएल प्रलेखन](https://docs.unidata.ucar.edu/netcdf-java/current/userguide/ncml_overview.html) । NcML उपयोगी है क्योंकि आप इसके साथ कुछ चीजें कर सकते हैं (उदाहरण के लिए, एक संग्रह में विभिन्न फ़ाइलों में अलग-अलग परिवर्तन करना, जिसमें एक फ़ाइल के लिए एक विशिष्ट मान के साथ एक आयाम जोड़ना शामिल है।) , कि आप के साथ नहीं कर सकते ERDDAP ' datasets.xml ।

* एक में परिवर्तन .nc एमएल फ़ाइल का अंतिम संशोधित समय फाइल को जब भी डेटासेट को फिर से लोड किया जाता है, लेकिन अंतर्निहित में बदल जाता है .nc डेटा फ़ाइलों को सीधे नहीं देखा जाएगा।
* Hint: NcML है\\*बहुत\\*NcML फ़ाइल में कुछ वस्तुओं के आदेश के प्रति संवेदनशील। निर्दिष्ट आदेश में निर्देशों की एक श्रृंखला निर्दिष्ट करने के रूप में NcML के बारे में सोचें, स्रोत फ़ाइलों को बदलने के इरादे से (NcML फ़ाइल के प्रारंभ/शीर्ष पर राज्य) गंतव्य फ़ाइलों में (NcML फ़ाइल के अंत / नीचे राज्य) ।

NcML का विकल्प [ NetCDF ऑपरेटर ( NCO ) ](#netcdf-operators-nco) । बड़ा अंतर यह है कि एनसीएमएल ऑन-द-फ्लाई में बदलाव के लिए एक प्रणाली है (इसलिए स्रोत फ़ाइलों को परिवर्तित नहीं किया जाता है) जबकि NCO परिवर्तन करने के लिए इस्तेमाल किया जा सकता है (या नए संस्करण) फ़ाइलें दोनों NCO और NcML बहुत लचीला हैं और आप लगभग किसी भी बदलाव को बनाने की अनुमति देते हैं जो आप फ़ाइलों के बारे में सोच सकते हैं। दोनों के लिए, वास्तव में यह जानने के लिए चुनौतीपूर्ण हो सकता है कि आप क्या करना चाहते हैं -- इसी तरह के उदाहरणों के लिए वेब की जाँच करें। दोनों नेटसीडीएफ तैयार करने के लिए उपयोगी उपकरण हैं और HDF उपयोग के लिए फ़ाइलों के साथ ERDDAP विशेष रूप से, क्या से परे परिवर्तन करने के लिए ERDDAP 's हेरफेर प्रणाली कर सकते हैं।

उदाहरण #1: एक एकल मान के साथ एक समय आयाम जोड़ना
यहाँ एक है .nc एमएल फ़ाइल जो एक नया बाहरी आयाम बनाता है (समय, 1 मान के साथ: 1041379200) और उस आयाम को A2003001.L3m\\_day\\_PIC\\_pic\\_4km नामक फ़ाइल में चित्र चर में जोड़ता है। .nc :
```
    <netcdf xmlns='https://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2'>
      <variable name='time' type='int' shape='time' />
      <aggregation dimName='time' type='joinNew'>
        <variableAgg name='pic'/>
        <netcdf location='A2003001.L3m\\_DAY\\_PIC\\_pic\\_4km.nc' coordValue='1041379200'/>
      </aggregation>
    </netcdf>
```
उदाहरण #2: मौजूदा समय मूल्य बदलना
कभी कभी स्रोत .nc पहले से ही फ़ाइल में एक समय आयाम और समय मान है, लेकिन मूल्य गलत है (अपने उद्देश्य के लिए) । यह .nc एमएल फ़ाइल कहते हैं: "19810825230030-NCEI" नामक डेटा फ़ाइल के लिए, आयाम चर के लिए "time" , 1970-01-01T00:00:00Z के बाद से इकाइयों को 'सेकेंड' होने की विशेषता निर्धारित की और 367588800 होने का समय मान निर्धारित किया।
```
    <netcdf xmlns='https://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2'
      location="19810825230030-NCEI-L3C\\_GHRSST-SSTskin-AVHRR\\_Pathfinder-PFV5.3\\_NOAA07\\_G\\_1981237\\_day-v02.0-fv01.0.nc">
      <variable name="time">
        <attribute name='units' value='seconds since 1970-01-01T00:00:00Z' />
        <values>367588800</values>
      </variable>
    </netcdf>
```
###  NetCDF ऑपरेटर ( NCO )  {#netcdf-operators-nco} 
"नेटसीडीएफ ऑपरेटर" ( NCO ) एक दर्जन स्टैंडअलोन, कमांड लाइन प्रोग्राम है कि netCDF लेने शामिल \\[ v3 \\] , HDF   \\[ v4 or v5 \\] , \\[ .grib, .bufr, \\] और/or DAP इनपुट के रूप में फाइलें, फिर संचालित करें (उदाहरण के लिए, नए डेटा प्राप्त करें, आंकड़े, प्रिंट, हाइपरस्लाब, मेटाडाटा में हेरफेर करें) और पाठ, द्विआधारी या NetCDF प्रारूपों में स्क्रीन या फ़ाइलों के लिए परिणाम का उत्पादन। NCO ग्रिड वैज्ञानिक डेटा का विश्लेषण। शैल-समन्द शैली की NCO उपयोगकर्ताओं को संवादात्मक रूप से फ़ाइलों में हेरफेर करने और विश्लेषण करने की अनुमति देता है, या अभिव्यक्तिपूर्ण लिपियों के साथ जो उच्च स्तर के प्रोग्रामिंग वातावरण के कुछ ओवरहेड से बच जाते हैं। (से [ NCO ](https://nco.sourceforge.net/) होमपेज) ।

विकल्प NCO है [एनसीएमएल](#ncml-files) । बड़ा अंतर यह है कि एनसीएमएल ऑन-द-फ्लाई में बदलाव के लिए एक प्रणाली है (इसलिए स्रोत फ़ाइलों को परिवर्तित नहीं किया जाता है) जबकि NCO परिवर्तन करने के लिए इस्तेमाल किया जा सकता है (या नए संस्करण) फ़ाइलें दोनों NCO और NcML बहुत लचीला हैं और आप लगभग किसी भी बदलाव को बनाने की अनुमति देते हैं जो आप फ़ाइलों के बारे में सोच सकते हैं। दोनों के लिए, वास्तव में यह जानने के लिए चुनौतीपूर्ण हो सकता है कि आप क्या करना चाहते हैं -- इसी तरह के उदाहरणों के लिए वेब की जाँच करें। दोनों नेटसीडीएफ तैयार करने के लिए उपयोगी उपकरण हैं और HDF उपयोग के लिए फ़ाइलों के साथ ERDDAP विशेष रूप से, क्या से परे परिवर्तन करने के लिए ERDDAP 's हेरफेर प्रणाली कर सकते हैं।

उदाहरण के लिए, आप उपयोग कर सकते हैं NCO समय चर की इकाइयों को फ़ाइलों के एक समूह में संगत बनाने के लिए जहां वे मूल रूप से संगत नहीं थे। या, आप उपयोग कर सकते हैं NCO लागू करने के लिए scale\\_factor और add\\_offset फ़ाइलों के एक समूह में जहां scale\\_factor और add\\_offset विभिन्न स्रोत फ़ाइलों में अलग-अलग मान होते हैं।
 (अब आप उन समस्याओं का सामना कर सकते हैं ERDDAP™ माध्यम [ EDDGrid से NcFilesUnpacked](#eddgridfromncfilesunpacked) , जो का एक संस्करण है EDDGrid FromNcFiles, जो पैक किए गए डेटा को अनपैक करता है और एक संग्रह फ़ाइलों से निपटने के लिए कम स्तर पर समय मानों को मानकीकृत करता है, जिसमें अलग-अलग होते हैं। scale\\_factor s और add\\_offset , या अलग समय इकाइयों।) 

 NCO फ्री एंड ओपन सोर्स सॉफ्टवेयर है जो उपयोग करता है [GPL 3.0](https://www.gnu.org/licenses/gpl-3.0.html) लाइसेंस

उदाहरण #1: इकाई बनाना
 EDDGrid FromFiles and EDDTable फ़ाइलों से जोर देते हैं कि किसी दिए गए चर के लिए इकाइयां सभी फाइलों में समान हैं। यदि कुछ फाइलें तिरछे हैं (कार्यात्मक नहीं) अन्य (जैसे, समय इकाई) से अलग
1970-01-01 00:00:00 से UTC" से दूसरे
 "seconds since 1970-01-01T00:00:00Z" , आप उपयोग कर सकते हैं NCO ' [हिन्दी](https://nco.sourceforge.net/nco.html#ncatted-netCDF-Attribute-Editor) सभी फाइलों में इकाइयों को बदलने के लिए समान होना
nco/ncatted -a इकाइयों, समय, o, c, 1970-01-01T00:00Z'\\* .nc   
 \\[ इस तरह के कई समस्याओं के लिए EDDTableFrom ... फ़ाइलें, अब आप उपयोग कर सकते हैं [मानकीकरण क्या](#standardizewhat) बताने के लिए ERDDAP स्रोत फ़ाइलों को मानकीकृत करने के लिए क्योंकि उन्हें पढ़ा जाता है ERDDAP । \\] 
    
### डेटासेट के आकार की सीमा{#limits-to-the-size-of-a-dataset} 
आप नीचे "2 बिलियन" के कई संदर्भ देखेंगे। सही ढंग से, यह 2,147,483,647 के लिए एक संदर्भ है (2^31-1) 32-bit हस्ताक्षरित पूर्णांक का अधिकतम मान है। कुछ कंप्यूटर भाषाओं में, उदाहरण के लिए Java   (जो ERDDAP™ में लिखा गया है) यह सबसे बड़ा डेटा प्रकार है जिसका उपयोग कई डेटा संरचनाओं के लिए किया जा सकता है (उदाहरण के लिए, एक सरणी का आकार) ।

स्ट्रिंग मूल्यों के लिए (उदाहरण के लिए, चर नाम, विशेषता नाम, स्ट्रिंग विशेषता मान और स्ट्रिंग डेटा मान के लिए) , प्रति स्ट्रिंग वर्णों की अधिकतम संख्या ERDDAP™ ~2 बिलियन है। लेकिन लगभग सभी मामलों में, यदि कोई स्ट्रिंग उचित आकार से अधिक हो तो छोटी या बड़ी समस्याएं होंगी (उदाहरण के लिए, चर नामों और विशेषता नामों के लिए 80 वर्ण, और अधिकांश स्ट्रिंग विशेषता मूल्यों और डेटा मूल्यों के लिए 255 वर्ण) । उदाहरण के लिए, वेब पेज जो लंबे परिवर्तनीय नाम प्रदर्शित करते हैं, awkwardly चौड़े और लंबे परिवर्तनीय नामों को तबाह किया जाएगा जब वे प्रतिक्रिया फ़ाइल प्रकार की सीमा से अधिक हों।

ग्रिड डेटासेट के लिए:

* अधिकतम संख्या axisVariable s ~2 बिलियन है।
अधिकतम संख्या dataVariable s ~2 बिलियन है।
लेकिन अगर किसी डेटासेट में&gt;100 चर हैं, तो यह उपयोगकर्ताओं के लिए उपयोग करने के लिए बोझिल होगा।
यदि कोई डेटासेट में 1 मिलियन चर हैं, तो आपके सर्वर को बहुत सारे भौतिक स्मृति की आवश्यकता होगी और अन्य समस्याएं होंगी।
* प्रत्येक आयाम का अधिकतम आकार ( axisVariable ) ~2 बिलियन मान है।
* मुझे लगता है कि कोशिकाओं की अधिकतम कुल संख्या (सभी आयाम आकारों का उत्पाद) असीमित है, लेकिन यह ~ 9e18 हो सकता है।

सारणीबद्ध डेटासेट के लिए:

* अधिकतम संख्या dataVariable s ~2 बिलियन है।
लेकिन अगर किसी डेटासेट में&gt;100 चर हैं, तो यह उपयोगकर्ताओं के लिए उपयोग करने के लिए बोझिल होगा।
यदि कोई डेटासेट में 1 मिलियन चर हैं, तो आपके सर्वर को बहुत सारे भौतिक स्मृति की आवश्यकता होगी और अन्य समस्याएं होंगी।
* स्रोतों की अधिकतम संख्या (उदाहरण के लिए, फ़ाइलें) कि कुल किया जा सकता है ~2 अरब है।
* कुछ मामलों में, एक व्यक्तिगत स्रोत से पंक्तियों की अधिकतम संख्या (उदाहरण के लिए, फ़ाइल, लेकिन डेटाबेस नहीं) ~2 अरब पंक्तियों है।
* मुझे नहीं लगता कि अन्य सीमाएं हैं।

ग्रिड और सारणीबद्ध डेटासेट दोनों के लिए, सबसेट के आकार पर कुछ आंतरिक सीमाएं हैं जिन्हें एक उपयोगकर्ता द्वारा एक अनुरोध में अनुरोध किया जा सकता है। (अक्सर किसी चीज के 2 बिलियन या ~ 9e18 से संबंधित) लेकिन यह बहुत अधिक संभावना है कि एक उपयोगकर्ता फ़ाइल-प्रकार-विशिष्ट सीमाओं को हिट करेगा।

*    NetCDF संस्करण 3 .nc फाइलें 2GB बाइट्स तक सीमित हैं। (यदि यह वास्तव में किसी के लिए एक समस्या है, तो मुझे बताएं: मैं समर्थन जोड़ सकता हूं NetCDF संस्करण 3 .nc 64 बिट एक्सटेंशन या NetCDF संस्करण 4, जो सीमा को काफी बढ़ा देगा, लेकिन अनंत नहीं।) 
* ब्राउज़र डेटा के केवल ~500MB के बाद दुर्घटनाग्रस्त हो जाता है, इसलिए ERDDAP™ प्रतिक्रिया को सीमित करता है .htmlTable डेटा के ~400MB का अनुरोध करता है।
* कई डेटा विश्लेषण कार्यक्रमों में समान सीमा होती है (उदाहरण के लिए, आयाम का अधिकतम आकार अक्सर ~2 बिलियन मान होता है) इसलिए फ़ाइल-प्रकार-विशिष्ट सीमाओं के आसपास पहुंचने के लिए कड़ी मेहनत करने का कोई कारण नहीं है।
* फ़ाइल-प्रकार-विशिष्ट सीमाएं उस में उपयोगी होती हैं जिसमें वे वास्तव में डेटा की विशाल मात्रा के लिए नेव अनुरोधों को रोकते हैं। (उदाहरण के लिए, "मुझे इस डेटासेट के सभी प्राप्त करें" जब डेटासेट में 20 टीबी डेटा होता है) , जो सप्ताह या महीने डाउनलोड करने के लिए ले जाएगा। अब डाउनलोड करने की संभावना है कि यह कई कारणों से विफल हो जाएगा।
* फ़ाइल-प्रकार-विशिष्ट सीमाएं इस बात में उपयोगी हैं कि वे उपयोगकर्ता को उचित आकार के सबसेट से निपटने के लिए मजबूर करते हैं। (उदाहरण के लिए, एक समय बिंदु प्रत्येक से डेटा के साथ फ़ाइलों के माध्यम से एक बड़े ग्रिड डेटासेट से निपटने) ।
         
### ACDD-1.3 पर स्विच करें{#switch-to-acdd-13} 
हम (वास्तव में [जनरेट DatasetXml](#generatedatasetsxml) ) वर्तमान में सुझाव [ACDD संस्करण 1.3](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) , जिसे 2015 की शुरुआत में संशोधित किया गया था और जिसे वैश्विक सम्मेलनों की विशेषता में "ACDD-1.3" कहा जाता है। पहले ERDDAP™ संस्करण 1.62 (जून 2015 में जारी) , ERDDAP™ मूल, संस्करण 1.0, का उपयोग / सिफारिश की [ NetCDF डेटासेट डिस्कवरी के लिए योगदान सम्मेलन](https://wiki.esipfed.org/ArchivalCopyOfVersion1) जिसे "" कहा गया था Unidata डेटासेट डिस्कवरी v1.0" वैश्विक सम्मेलनों में और Metadata\\_Conventions विशेषताएँ

यदि आपके डेटासेट ACDD के पहले संस्करणों का उपयोग करते हैं, तो हम अनुशंसा करते हैं कि आप ACDD-1.3 पर स्विच करें। यह मुश्किल नहीं है। ACDD-1.3 अत्यधिक पिछड़े संस्करण 1.0 के साथ संगत है। सभी डेटासेट के लिए स्विच करने के लिए (सिवाय EDDGrid FromErddap and EDDTable FromErddap datasets) :

1. वैश्विक मूल्य निर्धारण Metadata\\_Conventions जोड़कर विशेषता (या मौजूदा बदलकर Metadata\\_Conventions विशेषता)   
```
        <att name="Metadata\\_Conventions">null</att>  
```
डेटासेट के वैश्विक&lt; addAttributes &gt;
     
2. यदि डेटासेट वैश्विक में एक कन्वेंशन विशेषता है&lt; addAttributes &gt; सभी बदलें Unidata डेटासेट डिस्कवरी v1.0 "ACDD-1.3" के संदर्भ में।
यदि डेटासेट के पास वैश्विक में एक कन्वेंशन विशेषता नहीं है&lt; addAttributes इसके बाद ACDD-1.3 को संदर्भित करता है। उदाहरण के लिए,
```
        <att name="Conventions">COARDS, CF-1.6, ACDD-1.3</att>  
```
         
3. यदि डेटासेट वैश्विक है standard\\_name\\_vocabulary विशेषता, उदाहरण के लिए, कृपया मूल्य के प्रारूप को बदलने के लिए,
```
        <att name="standard\\_name\\_vocabulary">CF Standard Name Table v65</att>  
```
यदि संदर्भ का पुराना संस्करण है [CF मानक नाम तालिका](https://cfconventions.org/Data/cf-standard-names/current/build/cf-standard-name-table.html) । शायद वर्तमान संस्करण में स्विच करना एक अच्छा विचार है (65, जैसा कि हम इसे लिखते हैं) चूंकि नए मानक नामों को बाद के संस्करणों के साथ उस तालिका में जोड़ा जाता है, लेकिन पुराने मानक नामों को शायद ही कभी अलग किया जाता है और कभी हटाया नहीं जाता है।
     
4. हालांकि ACDD-1.0 में वैश्विक गुण शामिल थे creator\\_name , creator\\_email , creator\\_url , [जनरेट DatasetXml](#generatedatasetsxml) कभी कभी कभी कभी नहीं मिला ERDDAP™ v1.50. यह महत्वपूर्ण जानकारी है:
        
    *    creator\\_name उपयोगकर्ताओं को डेटासेट के निर्माता को जानने / उद्धृत करने देता है।
    *    creator\\_email उपयोगकर्ताओं को डेटासेट के निर्माता से संपर्क करने के लिए पसंदीदा ईमेल पता बताता है, उदाहरण के लिए यदि उनके पास डेटासेट के बारे में प्रश्न हैं।
    *    creator\\_url उपयोगकर्ताओं को निर्माता के बारे में अधिक जानने का एक तरीका देता है।
    *    ERDDAP™ प्रत्येक डेटासेट के लिए FGDC और ISO 19115-2 / 19139 मेटाडाटा दस्तावेज़ उत्पन्न करते समय इस सभी जानकारी का उपयोग करता है। उन दस्तावेजों का अक्सर बाहरी खोज सेवाओं द्वारा उपयोग किया जाता है।
    
कृपया इन विशेषताओं को डेटासेट के वैश्विक स्तर पर जोड़ें&lt; addAttributes &gt;
```
        <att name="creator\\_name">NOAA NMFS SWFSC ERD</att>  
        <att name="creator\\_email">erd.data@noaa.gov</att>  
        <att name="creator\\_url">https://www.pfeg.noaa.gov</att>  
```
    
यही है। मुझे आशा है कि यह बहुत मुश्किल नहीं था।
     
### जैर{#zarr} 
संस्करण 2.25 ERDDAP™ स्थानीय पढ़ सकते हैं Zarr फ़ाइलों का उपयोग [EDDTableFromNcFiles](#eddtablefromncfiles) और [ EDDGrid FromNcFiles](#eddgridfromncfiles) ।

 (अगस्त 2019 तक) हम आसानी से गलत हो सकते हैं, लेकिन हम अभी तक आश्वस्त नहीं हैं कि [जैर](https://github.com/zarr-developers/zarr-python) , या इसी तरह के सिस्टम जो डेटा फ़ाइलों को छोटे टुकड़ों में तोड़ते हैं, की समस्या के लिए महान समाधान हैं ERDDAP™ Amazon AWS S3 जैसी क्लाउड सेवाओं में संग्रहीत डेटा को पढ़ना। जैर एक महान तकनीक है जिसने विभिन्न स्थितियों में अपनी उपयोगिता को दिखाया है, हम सिर्फ यह सुनिश्चित नहीं कर रहे हैं कि ज़ार कुछ स्थितियों में अपनी उपयोगिता को दर्शाता है। ERDDAP + S3 उन स्थितियों में से एक होगा। ज्यादातर हम कह रहे हैं: इससे पहले कि हम ज़ार में हमारे सभी डेटा को स्टोर करने का प्रयास करते हैं, आइए कुछ परीक्षण करते हैं कि क्या यह वास्तव में बेहतर समाधान है।

क्लाउड में डेटा एक्सेस करने वाली समस्याएं विलंबता हैं (पहले लैग डेटा प्राप्त करने के लिए) फ़ाइल स्तर का उपयोग (ब्लॉक-स्तर की पहुंच के बजाय) । Zarr फ़ाइल स्तर की पहुंच समस्या को हल करता है, लेकिन विलंबता के बारे में कुछ भी नहीं करता है। सिर्फ फाइल डाउनलोड करने की तुलना में (इसलिए इसे ब्लॉक-लेवल एक्सेस के साथ स्थानीय फ़ाइल के रूप में पढ़ा जा सकता है) ज़ार भी विलंबता समस्या को बढ़ा सकता है क्योंकि ज़ार के साथ, एक फ़ाइल पढ़ने में अब फ़ाइल के विभिन्न हिस्सों को पढ़ने के लिए कई कॉल शामिल हैं। (प्रत्येक अपने खुद के अंतराल के साथ) । विलंबता की समस्या को अनुरोधों को समानांतर करके हल किया जा सकता है, लेकिन यह एक उच्च स्तरीय समाधान है, जो जैर पर निर्भर नहीं है।

और जैर के साथ (संबंधिक डेटाबेस के साथ) , हम डेटा फ़ाइल होने की सुविधा खो देते हैं एक सरल, एकल फ़ाइल है जिसे आप आसानी से अखंडता को सत्यापित कर सकते हैं, या एक प्रतिलिपि बना सकते हैं।

 ERDDAP™   (V2) यूआरएल स्रोत से फ़ाइलों के स्थानीय कैश को बनाए रखने के लिए एक प्रणाली है (उदाहरण के लिए, S3) (देखें)&lt;कैशFromUrl&gt; और&lt;कैशमैक्सGB&gt; (#cachefromurl) ). नया [&lt;nThreads&gt; (#nthread) उच्च स्तर पर डेटा पुनर्प्राप्ति को समानांतर करके विलंबता समस्या को कम करना चाहिए।&lt;CashFromUrl&gt; कई परिदृश्यों के लिए बहुत अच्छी तरह से काम करता है। क्या हम यह सुनिश्चित नहीं कर रहे हैं कि कैसे फायदेमंद हो&lt;nThreads&gt; आगे परीक्षण के बिना है। हम मानते हैं कि हमने एक अच्छा नेटवर्क कनेक्शन के साथ AWS उदाहरण पर टाइमिंग टेस्ट नहीं किया है, लेकिन हमने फ़ाइलों के विभिन्न दूरस्थ URL स्रोतों के साथ सफलतापूर्वक परीक्षण किया है। और ERDDAP '&lt;कैशFromUrl&gt; किसी भी प्रकार की डेटा फ़ाइल के साथ काम करता है (उदाहरण के लिए .nc , .hdf , .csv, .jsonlCSV ) , भले ही बाहरी रूप से संपीड़ित हो (उदाहरण के लिए .gz ) बिना फाइलों में किसी बदलाव के (उदाहरण के लिए, उन्हें Zarr संग्रह के रूप में फिर से लिखना) ।

यह संभावना है कि विभिन्न परिदृश्य अलग-अलग समाधानों का पक्ष लेंगे, उदाहरण के लिए, केवल एक बार फ़ाइल का हिस्सा पढ़ने की आवश्यकता होती है (जैर जीतेगा) , बनाम एक बार एक फ़ाइल के सभी पढ़ने की आवश्यकता होती है, बनाम बार-बार एक फ़ाइल पढ़ने की आवश्यकता होती है ()&lt;कैशFromUrl&gt; जीत जाएगा।

ज्यादातर हम कह रहे हैं: इससे पहले कि हम ज़ार में हमारे सभी डेटा को स्टोर करने का प्रयास करते हैं, आइए कुछ परीक्षण करते हैं कि क्या यह वास्तव में बेहतर समाधान है।

- -
## टाइप डेटासेट की सूची{#list-of-types-datasets} 
यदि आपको सही डेटासेट प्रकार चुनने में मदद की आवश्यकता है, तो देखें [डेटासेट प्रकार का चयन करना](#choosing-the-dataset-type) ।

डेटासेट के प्रकार दो श्रेणियों में आते हैं। ( [क्यों?](#why-just-two-basic-data-structures) ) 

###  EDDGrid  {#eddgrid} 
*    [ ** EDDGrid ** ](#eddgrid) डेटासेट ग्रिड डेटा संभालती है।
    * में EDDGrid डेटासेट, डेटा चर डेटा के बहु-आयामी सरणी हैं।
    * प्रत्येक आयाम के लिए MUST एक अक्ष परिवर्तनीय है। एक्सिस वेरिएबल्स MUST को इस क्रम में निर्दिष्ट किया जाएगा कि डेटा वेरिएबल्स उनका उपयोग करते हैं।
    * में EDDGrid डेटासेट, सभी डेटा चर MUST उपयोग (शेयर) सभी अक्ष चर।
         ( [क्यों?](#why-just-two-basic-data-structures)   [क्या होगा?](#dimensions) ) 
में नया ERDDAP™ संस्करण 2.29.0 साथ EDDGrid FromNcFiles डेटा चर के लिए प्रयोगात्मक समर्थन है जो सभी अक्ष चरों का समर्थन नहीं करता है (या कुछ के रूप में यह एक ही डेटासेट में 1D और 2D डेटा कहा है) ।
    * क्रमबद्ध आयाम मान - सभी में EDDGrid डेटासेट, प्रत्येक आयाम MUST क्रमबद्ध क्रम में होना चाहिए (चढ़ना या उतरना) । प्रत्येक अनियमित रूप से स्पेस किया जा सकता है। कोई संबंध नहीं हो सकता है। यह आवश्यकता है [CF मेटाडाटा मानक](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) । यदि किसी भी आयाम के मान क्रमबद्ध क्रम में नहीं हैं, तो डेटासेट को लोड नहीं किया जाएगा और लोड नहीं किया जाएगा। ERDDAP™ लॉग फाइल में प्रथम अनॉर्टेड मान की पहचान करेगा, *बड़ाParentDirectory* /logs/log.txt।
        
कुछ उपवर्गों में अतिरिक्त प्रतिबंध हैं (विशेष रूप से,) EDDGrid कुल मौजूदा आयाम की आवश्यकता है कि बाहरी (लगभग, पहले) आयाम आरोही हो।
        
Unsorted आयाम मान लगभग हमेशा स्रोत डेटासेट के साथ एक समस्या का संकेत देते हैं। यह आमतौर पर तब होता है जब एकत्रीकरण में एक गलतनाम या अनुचित फ़ाइल शामिल की जाती है, जिससे एक अनधिकृत समय आयाम होता है। इस समस्या को हल करने के लिए त्रुटि संदेश देखें ERDDAP™ लॉग.txt फ़ाइल को ऑफेंडिंग टाइम वैल्यू खोजने के लिए। फिर संबंधित फ़ाइल खोजने के लिए स्रोत फ़ाइलों को देखें (पहले या एक के बाद) यह एकत्रीकरण में नहीं है।
        
    * अधिक पूर्ण विवरण देखें [ EDDGrid डेटा मॉडल](https://coastwatch.pfeg.noaa.gov/erddap/griddap/documentation.html#dataModel) ।
    * The The most of the EDDGrid डेटासेट प्रकार हैं:
        *    [ EDDGrid AudioFiles](#eddfromaudiofiles) स्थानीय ऑडियो फ़ाइलों के एक समूह से डेटा एकत्र करता है।
        *    [ EDDGrid FromDap](#eddgridfromdap) ग्रिड डेटा को संभालती है DAP सर्वर
        *    [ EDDGrid FromEDDTable](#eddgridfromeddtable) आपको एक सारणीबद्ध डेटासेट को ग्रिड डेटासेट में बदलने देता है।
        *    [ EDDGrid सेंध](#eddfromerddap) रिमोट से ग्रिड डेटा को संभालती है ERDDAP ।
        *    [ EDDGrid Etopo](#eddgridfrometopo) बस अंतर्निहित ETOPO स्थलाकृति डेटा को संभालती है।
        *    [ EDDGrid सेफिल](#eddgridfromfiles) सभी का सुपरक्लास है EDDGrid ...फिल्म कक्षाओं से।
        *    [ EDDGrid FromMergeIRFiles](#eddgridfrommergeirfiles) स्थानीय MergeIR समूह से डेटा एकत्र करता है .gz फ़ाइलें
        *    [ EDDGrid FromNcFiles](#eddgridfromncfiles) स्थानीय समूह से डेटा एकत्र करना NetCDF   (v3)   .nc और संबंधित फ़ाइलें।
        *    [ EDDGrid से NcFilesUnpacked](#eddgridfromncfilesunpacked) अगर एक संस्करण है EDDGrid FromNcFiles, जो स्थानीय लोगों के समूह से डेटा एकत्र करता है NetCDF   (v3)   .nc और संबंधित फाइलें, जो ERDDAP™ कम स्तर पर अनपैक।
        *    [ EDDGrid LonPM180](#eddgridlonpm180) एक बच्चे के अक्षांश मूल्यों को संशोधित करता है EDDGrid इसलिए वे -180 से 180 रेंज में हैं।
        *    [ EDDGrid Lon0360](#eddgridlon0360) एक बच्चे के अक्षांश मूल्यों को संशोधित करता है EDDGrid इसलिए वे 0 से 360 रेंज में हैं।
        *    [ EDDGrid साइडबायसाइड](#eddgridsidebyside) दो या अधिक EDDGrid डेटासेट साइड बाय साइड।
        *    [ EDDGrid समग्र आयाम](#eddgridaggregateexistingdimension) दो या अधिक EDDGrid डेटासेट, जिनमें से प्रत्येक में पहले आयाम के लिए मूल्यों की एक अलग श्रृंखला है, लेकिन अन्य आयामों के लिए समान मान।
        *    [ EDDGrid कॉपी](#eddgridcopy) किसी अन्य की स्थानीय प्रतिलिपि बना सकते हैं EDDGrid 's डेटा और स्थानीय प्रतिलिपि से डेटा कार्य करता है।
             
    * सब EDDGrid डेटासेट एक nThread सेटिंग का समर्थन करता है, जो बताता है ERDDAP™ कितने धागे का उपयोग करने के लिए जब एक अनुरोध का जवाब देते हैं। देखें [nThread](#nthreads) विवरण के लिए प्रलेखन।
         
### EDDTable{#eddtable} 
*    [ **EDDTable** ](#eddtable) डेटासेट सारणीबद्ध डेटा को संभालती है।
    * सारणीबद्ध डेटा को पंक्तियों और स्तंभों के साथ डेटाबेस जैसी तालिका के रूप में दर्शाया जा सकता है। प्रत्येक स्तंभ (एक डेटा चर) एक नाम, विशेषताओं का एक सेट है, और सिर्फ एक प्रकार का डेटा स्टोर करता है। प्रत्येक पंक्ति में एक अवलोकन है (या संबंधित मूल्यों का समूह) । डेटा स्रोत एक अलग डेटा संरचना, एक अधिक जटिल डेटा संरचना, और/या एकाधिक डेटा फ़ाइलों में डेटा हो सकता है, लेकिन ERDDAP™ डेटा को एक सारणीबद्ध डेटासेट के रूप में पेश करने के लिए डेटाबेस जैसी तालिका में स्रोत डेटा को समतल करने में सक्षम होना चाहिए ERDDAP ।
    * अधिक पूर्ण विवरण देखें [EDDTable डेटा मॉडल](https://coastwatch.pfeg.noaa.gov/erddap/tabledap/documentation.html#dataModel) ।
    * EDDTable Dataset प्रकार हैं:
        *    [EDDTableFromAllDatasets](#eddtablefromalldatasets) एक उच्च स्तरीय डेटासेट है जिसमें आपके सभी अन्य डेटासेट के बारे में जानकारी है। ERDDAP ।
        *    [EDDTableFromAsciiFiles](#eddtablefromasciifiles) कॉमा-, टैब-, सेमीकोलॉन-, या स्पेस-सेपरेटेड सारणीबद्ध ASCII डेटा फ़ाइलों से डेटा एकत्र करता है।
        *    [EDDTableFromAsciiService](#eddtablefromasciiservice) सभी EDDTableFromAsciiService.
        *    [EDDTableFromAsciiServiceNOS](#eddtablefromasciiservicenos) कुछ से डेटा संभालती है NOAA एनओएस वेब सेवाएं
        *    [EDDTableFromAudioFiles](#eddfromaudiofiles) स्थानीय ऑडियो फ़ाइलों के एक समूह से डेटा एकत्र करता है।
        *    [EDDTableFrom AwsXmlFiles](#eddtablefromawsxmlfiles) स्वचालित मौसम स्टेशन के एक सेट से डेटा एकत्र करता है (एडब्ल्यूएस) XML फ़ाइलें
        *    [EDDTableFromCassandra](#eddtablefromcassandra) एक Cassandra तालिका से सारणीबद्ध डेटा को संभालती है।
        *    [EDDTableFromColumnarAsciiFiles](#eddtablefromcolumnarasciifiles) स्थिर-चौड़ाई डेटा कॉलम के साथ सारणीबद्ध ASCII डेटा फ़ाइलों से डेटा एकत्र करता है।
        *    [EDDTableFromDapSequence](#eddtablefromdapsequence) से सारणीबद्ध डेटा संभालती है DAP अनुक्रम सर्वर
        *    [EDDTableFromDatabase](#eddtablefromdatabase) एक डेटाबेस तालिका से सारणीबद्ध डेटा को संभालती है।
        *    [EDDTableFrom EDDGrid ](#eddtablefromeddgrid) आपको एक EDDTable डेटासेट बनाने की अनुमति देता है EDDGrid डेटासेट।
        *    [EDDTableFromErddap](#eddfromerddap) रिमोट से सारणीबद्ध डेटा को संभालती है ERDDAP ।
        *    [EDDTableFromFileNames](#eddtablefromfilenames) सर्वर की फ़ाइल सिस्टम में फ़ाइलों के एक समूह के बारे में जानकारी से डेटासेट बनाता है, लेकिन यह फ़ाइलों के भीतर से डेटा की सेवा नहीं करता है।
        *    [EDDTableFromFiles](#eddtablefromfiles) सभी EDDTableFrom की सुपरक्लास है।
        *    [EDDTableFromHttpGet](#eddtablefromhttpget) है ERDDAP डेटा आयात के साथ-साथ डेटा निर्यात के लिए केवल सिस्टम।
        *    [EDDTableFrom Hyrax फ़ाइलें](#eddtablefromhyraxfiles)   (डिप्रेषित) फ़ाइलों से डेटा को एकत्रित करता है जिसमें साझा आयामों के साथ कई चर होते हैं, जो एक द्वारा सेवा की जाती है। [ Hyrax   OPeNDAP सर्वर](https://www.opendap.org/software/hyrax-data-server) ।
        *    [EDDTableFromInvalidCRAFiles](#eddtablefrominvalidcrafiles) से डेटा एकत्र करना NetCDF   (v3)   .nc फ़ाइलें जो CF DSG Contiguous Ragged Array का एक विशिष्ट, अवैध, संस्करण का उपयोग करती हैं (सीआरए) फ़ाइलें हालांकि ERDDAP™ इस फ़ाइल प्रकार का समर्थन करता है, यह एक अमान्य फ़ाइल प्रकार है जिसे कोई भी उपयोग करना शुरू नहीं करना चाहिए। वर्तमान में इस फ़ाइल प्रकार का उपयोग करने वाले समूह को दृढ़ता से उपयोग करने के लिए प्रोत्साहित किया जाता है ERDDAP™ मान्य CF DSG CRA फ़ाइलों को उत्पन्न करने और इन फ़ाइलों का उपयोग बंद करने के लिए।
        *    [EDDTableFromJsonlCSVFiles](#eddtablefromjsonlcsvfiles) से डेटा एकत्र करना [JSON लाइन्स CSV फ़ाइलों](https://jsonlines.org/examples/) ।
        *    [EDDTableFromMultidimNcFiles](#eddtablefrommultidimncfiles) से डेटा एकत्र करना NetCDF   (v3)   .nc साझा आयामों के साथ कई चर के साथ फ़ाइलें।
        *    [EDDTableFromMqtt](/docs/server-admin/mqtt-integration) MQTT संदेशों के आधार पर डेटासेट का निर्माण करता है। ध्यान दें कि प्रलेखन एक समर्पित पृष्ठ पर है। ध्यान दें कि बहुत सारी समानताएं हैं [EDDTableFromHttpGet](#eddtablefromhttpget) ।
        *    [EDDTableFromNcFiles](#eddtablefromncfiles) से डेटा एकत्र करना NetCDF   (v3)   .nc साझा आयामों के साथ कई चर के साथ फ़ाइलें। मौजूदा डेटासेट के लिए इस डेटासेट प्रकार का उपयोग जारी रखना ठीक है, लेकिन नए डेटासेट के लिए हम इसके बजाय EDDTableFromMultidimNcFiles का उपयोग करने की सलाह देते हैं।
        *    [EDDTableFromNcCFFiles](#eddtablefromnccffiles) से डेटा एकत्र करना NetCDF   (v3)   .nc जो फ़ाइलों द्वारा निर्दिष्ट फ़ाइल प्रारूपों में से एक का उपयोग करते हैं [CF Discrete Sampling Geometries (DSG) ](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries) सम्मेलन। लेकिन फ़ाइलों के लिए बहुआयामी CF DSG वेरिएंट का उपयोग करते हुए, उपयोग करते हैं [EDDTableFromMultidimNcFiles](#eddtablefrommultidimncfiles) इसके बजाय।
        *    [EDDTableFromNccsvFiles](#eddtablefromnccsvfiles) से डेटा एकत्र करना [एनसीसीएसवी](/docs/user/nccsv-1.00) ASCII फ़ाइलें.
        *    [EDDTableFromNOS](#eddtablefromnos)   (डिप्रेषित) NOS XML सर्वर से सारणीबद्ध डेटा को संभालती है।
        *    [EDDTableFromOBIS](#eddtablefromobis) ओबीआईएस सर्वर से सारणीबद्ध डेटा को संभालती है।
        *    [EDDTableFromParquetFiles](#eddtablefromparquetfiles) डेटा को संभालना [लकड़ी](https://parquet.apache.org/) ।
        *    [EDDTableFrom SOS ](#eddtablefromsos) से सारणीबद्ध डेटा संभालती है SOS सर्वर
        *    [EDDTableFromThreddsFiles](#eddtablefromthreddsfiles)   (डिप्रेषित) फ़ाइलों से डेटा को एकत्रित करता है जिसमें साझा आयामों के साथ कई चर होते हैं, जो एक द्वारा सेवा की जाती है। [थर्ड OPeNDAP सर्वर](https://www.unidata.ucar.edu/software/tds/) ।
        *    [EDDTableFrom WFS फ़ाइलें](#eddtablefromwfsfiles)   (डिप्रेषित) सभी डेटा की एक स्थानीय प्रति बनाता है ArcGIS MapServer WFS इसलिए डेटा को फिर से संरक्षित किया जा सकता है ERDDAP™ उपयोगकर्ता
        *    [EDDTableAggregateRows](#eddtableaggregaterows) EDDTable Dataset के एक समूह से EDDTable Dataset बना सकते हैं।
        *    [EDDTableCopy](#eddtablecopy) कई प्रकार के EDDTable डेटासेट की स्थानीय प्रतिलिपि बना सकते हैं और फिर स्थानीय प्रतिलिपि से डेटा को जल्दी से संरक्षित कर सकते हैं।

  
- -

## डेटासेट प्रकार के विस्तृत विवरण{#detailed-descriptions-of-dataset-types} 

###  EDDGrid FromDap{#eddgridfromdap} 
 [ ** EDDGrid FromDap** ](#eddgridfromdap) ग्रिड चर संभालती है [ DAP ](https://www.opendap.org/) सर्वर

* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। आप उस जानकारी को इकट्ठा कर सकते हैं जिसे आप tweak करना चाहते हैं या एक के लिए अपना खुद का XML बना सकते हैं EDDGrid अपने ब्राउज़र में स्रोत डेटासेट के डीडीएस और डीएएस फ़ाइलों को देखकर डेटासेट (.das और .dds जोड़कर sourceUrl उदाहरण के लिए, [https://thredds1.pfeg.noaa.gov/thredds/dodsC/satellite/BA/ssta/5day.dds](https://thredds1.pfeg.noaa.gov/thredds/dodsC/satellite/BA/ssta/5day.dds) ) ।
     
*    EDDGrid FromDap किसी भी बहु-आयामी चर से डेटा प्राप्त कर सकता है DAP डेटा सर्वर (पहले, EDDGrid FromDap को "grid" के रूप में नामित चर तक सीमित किया गया था, लेकिन यह अब आवश्यकता नहीं है।)   
     
* क्रमबद्ध आयाम मान - प्रत्येक आयाम के लिए मान को क्रमबद्ध क्रम में होना चाहिए (चढ़ना या उतरना) । मूल्यों को अनियमित रूप से स्पेस किया जा सकता है। कोई संबंध नहीं हो सकता है। यह आवश्यकता है [CF मेटाडाटा मानक](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) । यदि किसी भी आयाम के मान क्रमबद्ध क्रम में नहीं हैं, तो डेटासेट को लोड नहीं किया जाएगा और लोड नहीं किया जाएगा। ERDDAP™ लॉग फाइल में प्रथम अनॉर्टेड मान की पहचान करेगा, *बड़ाParentDirectory* /logs/log.txt।
    
Unsorted आयाम मान लगभग हमेशा स्रोत डेटासेट के साथ एक समस्या का संकेत देते हैं। यह आमतौर पर तब होता है जब एकत्रीकरण में एक गलतनाम या अनुचित फ़ाइल शामिल की जाती है, जिससे एक अनधिकृत समय आयाम होता है। इस समस्या को हल करने के लिए त्रुटि संदेश देखें ERDDAP™ लॉग.txt फ़ाइल को ऑफेंडिंग टाइम वैल्यू खोजने के लिए। फिर संबंधित फ़ाइल खोजने के लिए स्रोत फ़ाइलों को देखें (पहले या एक के बाद) यह एकत्रीकरण में नहीं है।
    
####  EDDGrid सेडैप कंकाल एक्सएमएल{#eddgridfromdap-skeleton-xml} 

 >&nbsp;&nbsp;&nbsp;&nbsp;&lt;dataset type="EDDGridFromDap" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceUrl>](#sourceurl)...&lt;/sourceUrl>  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaWMS>](#accessibleviawms)...&lt;/accessibleViaWMS> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->   
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;updateEveryNMillis>](#updateeverynmillis)...&lt;/updateEveryNMillis> &lt;!-- 0 or 1.   
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For EDDGridFromDap, this gets the remote .dds and then gets the new  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftmost (first) dimension values. -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;nThreads>](#nthreads)...&lt;/nThreads> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dimensionValuesInMemory>](#dimensionvaluesinmemory)...&lt;/dimensionValuesInMemory> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addAttributes>](#global-attributes)...&lt;/addAttributes> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;axisVariable>](#axisvariable)...&lt;/axisVariable> &lt;!-- 1 or more -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dataVariable>](#datavariable)...&lt;/dataVariable> &lt;!-- 1 or more -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dataset>  

     
###  EDDGrid FromEDDTable{#eddgridfromeddtable} 
 [ ** EDDGrid FromEDDTable** ](#eddgridfromeddtable) आपको EDDTable सारणीबद्ध डेटासेट को एक में बदलने की अनुमति देता है EDDGrid ग्रिड डेटासेट। याद रखें कि ERDDAP™ डेटासेट को या तो व्यवहार करता है [ग्रिड डेटासेट (उपवर्ग EDDGrid ) या सारणीबद्ध डेटासेट (EDDTable के उपवर्ग) ](#why-just-two-basic-data-structures) ।

* आम तौर पर, यदि आपके पास ग्रिड डेटा है, तो आप सिर्फ एक सेट अप करते हैं EDDGrid सीधे डेटासेट। कभी-कभी यह संभव नहीं है, उदाहरण के लिए, जब आपके पास संबंधिक डेटाबेस में संग्रहीत डेटा होता है ERDDAP™ केवल EDDTableFromDatabase के माध्यम से पहुँच सकते हैं। EDDGrid FromEDDTable class आपको उस स्थिति का उपाय करने देता है।
     
* जाहिर है, अंतर्निहित EDDTable डेटासेट में डेटा होना चाहिए (मूल) ग्रिड डेटा, लेकिन एक सारणीबद्ध रूप में। उदाहरण के लिए, EDDTable डेटासेट में CTD डेटा हो सकता है: पूर्वी और उत्तर की ओर की माप, कई गहराईयों पर, कई बार। चूंकि गहराई प्रत्येक समय बिंदु पर समान है, EDDGrid FromEDDTable एक समय और एक गहराई आयाम के साथ एक ग्रिड डेटासेट बना सकता है जो अंतर्निहित EDDTable डेटासेट के माध्यम से डेटा तक पहुंचता है।
     
* जनगणना Xml -- हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। आप उस जानकारी को इकट्ठा कर सकते हैं जिसे आपको किसी न किसी प्रारूप में सुधार करने की आवश्यकता है।
     
* स्रोत गुण -- अन्य सभी प्रकार के डेटासेट के साथ, EDDGrid FromTable is विचार है कि वहाँ वैश्विक स्रोतAttributes हैं और [वैश्विक addAttributes ](#global-attributes)   (में निर्दिष्ट datasets.xml ) , जो वैश्विक संयुक्त बनाने के लिए संयुक्त हैं विशेषता, जो उपयोगकर्ता देखते हैं। वैश्विक स्रोत के लिएविशेषताएं, EDDGrid FromEDDTable वैश्विक संयुक्त का उपयोग करता है अंतर्निहित EDDTable डेटासेट की विशेषता। (यदि आप इसके बारे में एक मिनट के लिए सोचते हैं तो यह समझ में आता है।) 
    
इसी तरह, प्रत्येक के लिए axisVariable 'और' dataVariable ' [ addAttributes ](#addattributes) , EDDGrid FromEDDTable चर के संयुक्त का उपयोग करता है अंतर्निहित EDDTable डेटासेट से योगदान करता है क्योंकि EDDGrid fromEDDTablevari's sourceAttributes. (यदि आप इसके बारे में एक मिनट के लिए सोचते हैं तो यह समझ में आता है।) 
    
एक परिणाम के रूप में, अगर EDDTable अच्छा मेटाडाटा है, EDDGrid FromEDDTable अक्सर बहुत कम जरूरत addAttributes मेटाडाटा - यहाँ और वहाँ सिर्फ कुछ tweaks।
    
*    dataVariable s बनाम axisVariable S -- अंतर्निहित EDDTable केवल है dataVariable S. An EDDGrid FromEDDTable dataset कुछ होगा axisVariable s (EDDTable dataVariable s) कुछ dataVariable s (शेष EDDTable से निर्मित dataVariable s) । [जनरेट DatasetXml](#generatedatasetsxml) यह अनुमान लगाया जाएगा कि ईडीडीटीबल किस प्रकार है? dataVariable होना चाहिए EDDGrid FromEDDTable axisVariable लेकिन यह सिर्फ एक अनुमान है। आपको निर्दिष्ट करने के लिए GenerateDatasetsXml के आउटपुट को संशोधित करने की आवश्यकता है dataVariable s होगा axisVariable s, और किस क्रम में।
     
* धुरी -- अंतर्निहित EDDT के बारे में कुछ भी नहीं है EDDGrid FromEDDTable the संभावित मान of the संभव मान axisVariable डेटासेट के ग्रिड संस्करण में एस, इसलिए आप प्रत्येक के लिए जानकारी प्रदान करते हैं axisVariable इन विशेषताओं में से एक के माध्यम से:
    
    * धुरी - आपको मूल्यों की एक सूची निर्दिष्ट करने देता है। उदाहरण के लिए,
        &lt;att name="axisValues" [टाइप="डबललिस्ट"](#attributetype) 2, 2.5, 3, 3.5, 4&lt;/att&gt;
एक का उपयोग नोट [डेटा प्रकार](#data-types) साथ ही शब्द सूची। इसके अलावा, सूची का प्रकार (उदाहरण के लिए, डबल) MUST डेटा से मेल खाता है EDDTable में चर का प्रकार और EDDGrid fromEDDTable Datasets.
    * AxisValuesStartStrideStop - आपको स्टार्ट, स्ट्राइड और स्टॉप वैल्यू को निर्दिष्ट करके नियमित रूप से स्पेस मूल्यों का अनुक्रम निर्दिष्ट करने देता है। यहाँ एक उदाहरण है कि ऊपर धुरी उदाहरण के बराबर है:
        &lt;att name="axisValuesStartStrideStop" [टाइप="डबललिस्ट"](#attributetype) 2, 0.5, 4&lt;/att&gt;
फिर, एक सूची डेटा प्रकार का उपयोग नोट करें। इसके अलावा, सूची का प्रकार (उदाहरण के लिए, डबल) MUST डेटा से मेल खाता है EDDTable में चर का प्रकार और EDDGrid fromEDDTable Datasets.
         
    
अपडेट जैसा कि कोई रास्ता नहीं है EDDGrid शुरू में EDDTable से अक्षवैल्यू निर्धारित करने के लिए FromDTable, इसके लिए कोई विश्वसनीय तरीका भी नहीं है। EDDGrid EDDTable से निर्धारित करने के लिए जब अक्षवैल्यू बदल गया है (विशेष रूप से, जब समय चर के लिए नए मान होते हैं) । वर्तमान में, एकमात्र समाधान में अक्षवैल्यू विशेषता को बदलना है datasets.xml और डेटासेट को फिर से लोड करें। उदाहरण के लिए, आप एक स्क्रिप्ट लिख सकते हैं
    
    1. खोज datasets.xml के लिए
         datasetID (a) *Datasetid* "
इसलिए आप सही डेटासेट के साथ काम कर रहे हैं।
    2. खोज datasets.xml अगली घटना के लिए
         <sourceName>  *SourceName*  </sourceName>   
इसलिए आप सही चर के साथ काम कर रहे हैं।
    3. खोज datasets.xml अगली घटना के लिए
```
        <att name="axisValuesStartStrideStop" type="doubleList">  
```
इसलिए आप टैग की शुरुआत स्थिति जानते हैं।
    4. खोज datasets.xml अगली घटना के लिए
```
        </att>  
```
इसलिए आप अक्ष मूल्यों की अंतिम स्थिति को जानते हैं।
    5. पुराने शुरू को बदलें, नए मूल्यों के साथ मूल्यों को रोकें।
    6. संपर्क करें [ध्वज यूआरएल](/docs/server-admin/additional-information#set-dataset-flag) डाटासेट के लिए बताने के लिए ERDDAP™ डेटासेट को फिर से लोड करने के लिए।
    
यह आदर्श नहीं है, लेकिन यह काम करता है।
     
* परिशुद्धता - कब EDDGrid FromEDDTable डेटा के लिए उपयोगकर्ता के अनुरोध का जवाब देता है, यह EDDTable प्रतिक्रिया तालिका से डेटा की एक पंक्ति को स्थानांतरित करता है। EDDGrid प्रतिक्रिया ग्रिड। ऐसा करने के लिए, यह पता लगाना होगा कि तालिका में दी गई पंक्ति पर "अक्ष" मान ग्रिड में अक्ष मानों के कुछ संयोजन से मेल खाते हैं। पूर्णांक डेटा प्रकार के लिए, यह निर्धारित करना आसान है कि दो मान बराबर हैं। लेकिन फ्लोट और डबल्स के लिए, यह फ्लोटिंग पॉइंट नंबर की भयानक समस्या को बढ़ा देता है [बिल्कुल मिलान नहीं](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/) । (उदाहरण के लिए, 0.2 बनाम 0.199999999999999996) । करने के लिए (कोशिश करो) इससे निपटने के लिए, EDDGrid FromTable आप किसी भी के लिए एक सटीक विशेषता निर्दिष्ट करने देता है axisVariable S, जो decimal अंकों की कुल संख्या को निर्दिष्ट करता है जो समान होना चाहिए।
    * उदाहरण के लिए,&lt;att name="property" type="int"&gt;5&lt;/att&gt;
    * विभिन्न प्रकार के डेटा चर के लिए, विभिन्न डिफ़ॉल्ट सटीक मान हैं। आमतौर पर डिफ़ॉल्ट उपयुक्त होते हैं। यदि वे नहीं हैं, तो आपको विभिन्न मूल्यों को निर्दिष्ट करने की आवश्यकता है।
    * के लिए axisVariable (s) [समय मुद्रा परिवर्तक](#timestamp-variables) , डिफ़ॉल्ट पूर्ण परिशुद्धता है (एक सटीक मैच) ।
    * के लिए axisVariable जो फ्लोट हैं, डिफ़ॉल्ट परिशुद्धता 5 है।
    * के लिए axisVariable s कि डबल्स हैं, डिफ़ॉल्ट परिशुद्धता 9. है
    * के लिए axisVariable जिनके पास डेटा प्रकार पूर्ण है, EDDGrid FromEDDTable परिशुद्धता विशेषता को नजरअंदाज करता है और हमेशा पूर्ण परिशुद्धता का उपयोग करता है (एक सटीक मैच) ।
         
    *    **चेतावनी&#33;** जब ग्रिड डेटा के एक हिस्से में सारणीबद्ध डेटा के एक हिस्से में रूपांतरण किया जाता है, अगर EDDGrid FromEDDTable अपेक्षित में से एक के लिए EDDTable "axis" मान से मेल नहीं खा सकता EDDGrid FromEDDTable अक्ष मान, EDDGrid FromEDDTable चुपचाप (कोई त्रुटि नहीं) तालिका की उस पंक्ति से डेटा को फेंक देता है। उदाहरण के लिए, अन्य डेटा हो सकता है (ग्रिड पर नहीं) EDDTable Dataset में। (और अगर stride&gt; 1, यह स्पष्ट नहीं है EDDGrid इससे पहले कि कौन-सा अक्ष मान वांछित मान हैं और कौन-सा व्यक्ति स्ट्राइड के कारण छोड़ दिया जाना है।) इसलिए, यदि सटीक मान बहुत अधिक हैं, तो उपयोगकर्ता डेटा प्रतिक्रिया में लापता मान देखेगा जब वैध डेटा मान वास्तव में मौजूद हैं।
        
इसके विपरीत, यदि सटीक मान बहुत कम होते हैं, तो EDDTable "axis" मान जो मिलान नहीं करना चाहिए EDDGrid FromEDDTable अक्ष मान (erroneously) मैच।
        
ये संभावित समस्याएं भयानक हैं, क्योंकि उपयोगकर्ता गलत डेटा प्राप्त करता है (या लापता मान) जब उन्हें सही डेटा प्राप्त करना चाहिए (या कम से कम एक त्रुटि संदेश) ।
इसमें कोई दोष नहीं है EDDGrid FromTable. EDDGrid इस समस्या को हल नहीं कर सकता। समस्या सारणीबद्ध डेटा में परिवर्तित होने में निहित है (जब तक अन्य मान्यताओं को बनाया जा सकता है, लेकिन उन्हें यहां नहीं बनाया जा सकता है) ।
यह आप तक है, ERDDAP™ व्यवस्थापक **अपना परीक्षण EDDGrid FromEDDTable well** यह सुनिश्चित करने के लिए कि इन संभावित समस्याओं से बचने के लिए सटीक मान निर्धारित किए गए हैं।
        
#### गैंगबैंग{#gapthreshold} 
*    [गैंगबैंग](#gapthreshold) -- यह डेटासेट का एक बहुत ही असामान्य प्रकार है। चूंकि उन प्रश्नों के प्रकार जिन्हें करने के लिए बनाया जा सकता है (द्वारा संभाला) एक EDDGrid डेटासेट (श्रेणियों और सीमाओं से संबंधित axisVariable s) उन प्रश्नों के प्रकारों से बहुत अलग हैं जिन्हें बनाया जा सकता है (द्वारा संभाला) EDDTable Dataset (कुछ चरों की श्रेणियों से संबंधित) , का प्रदर्शन EDDGrid FromEDDTable Datasets सटीक अनुरोध जो बनाया गया है और अंतर्निहित EDDTable Dataset की गति के आधार पर बहुत भिन्न होगा। उन अनुरोधों के लिए जिनके पास एक स्ट्राइड वैल्यू है &gt; 1, EDDGrid FromEDDTable डेटा के अपेक्षाकृत बड़े हिस्से के लिए अंतर्निहित EDDTable पूछ सकता है (अगर stride=1) और फिर परिणामों के माध्यम से सिफ्ट करें, डेटा को कुछ पंक्तियों से रखें और दूसरों से डेटा को फेंक दें। यदि आवश्यक डेटा प्राप्त करने के लिए बहुत सारे डेटा के माध्यम से इसे तोड़ना पड़ता है, तो अनुरोध को भरने के लिए लंबे समय तक ले जाएगा।
    
अगर EDDGrid FromEDDTable यह बता सकता है कि बड़े अंतराल होंगे (अवांछित डेटा की पंक्तियों के साथ) वांछित डेटा वाली पंक्तियों के बीच, EDDGrid FromEDDTable एक बड़े अनुरोध के बजाय अंतर्निहित EDDTable को कई सबरीक्शंस बनाने का विकल्प चुन सकता है, जिससे बड़े अंतराल में डेटा की अवांछित पंक्तियों को छोड़ दिया जा सकता है। इस निर्णय के लिए संवेदनशीलता को अंतराल द्वारा नियंत्रित किया जाता हैथ्रेसहोल्ड मान जैसा कि निर्दिष्ट में है&lt;gapThreshold&gt; टैग (डिफ़ॉल्ट = 1000 पंक्तियों के स्रोत डेटा) । एक छोटी संख्या के लिए थ्रेसहोल्ड करने से डेटासेट बनाने का नेतृत्व होगा (आम तौर पर) अधिक subrequests एक बड़ी संख्या में होने वाले अंतराल को सेट करने से डेटासेट बनाने का नेतृत्व होगा (आम तौर पर) कम उपनिवेश।
    
यदि अंतराल थ्रेसहोल्ड बहुत छोटा है, EDDGrid FromEDDTable धीरे-धीरे काम करेगा क्योंकि कई अनुरोधों के ऊपर कुछ अतिरिक्त डेटा प्राप्त करके बचाया समय से अधिक होगा। अगर अंतर थ्रेसहोल्ड बहुत बड़ा है, EDDGrid FromEDDTable धीरे-धीरे काम करेगा क्योंकि इतना अतिरिक्त डेटा EDDTable से लिया जाएगा, केवल खारिज किया जाएगा। (जैसा कि गोल्डीलॉक्स की खोज की गई थी, मध्य "सही" है।) विभिन्न प्रकार के EDDTable डेटासेट के लिए ओवरहेड बहुत भिन्न होता है, इसलिए आपके डेटासेट के लिए वास्तविक सर्वोत्तम सेटिंग जानने का एकमात्र तरीका प्रयोग के माध्यम से है। लेकिन आप डिफ़ॉल्ट के लिए बहुत गलत स्टिकिंग नहीं करेंगे।
    
एक साधारण उदाहरण है: कल्पना करो EDDGrid केवल एक के साथ axisVariable   (समय, 100000 के आकार के साथ) एक dataVariable   (तापमान) , और डिफ़ॉल्ट अंतराल1000 की थ्रेसहोल्ड।
    
    * यदि कोई उपयोगकर्ता तापमान का अनुरोध करता है \\[ 0&#58;100&#58;5000 \\] , स्ट्राइड 100 है इसलिए अंतराल का आकार 99 है, जो कि खाई से भी कम है। तो EDDGrid FromTable अनुरोध के लिए आवश्यक सभी डेटा के लिए EDDTable के लिए सिर्फ एक अनुरोध करेगा (तापमान के बराबर \\[ 0:5000 \\] ) और डेटा की सभी पंक्तियों को फेंकने की जरूरत नहीं है।
    * यदि कोई उपयोगकर्ता तापमान का अनुरोध करता है \\[ 0:2500:5000 \\] , यह तय 2500 है, इसलिए अंतराल का आकार 2499 है, जो अंतराल से अधिक हैथ्रेशोल्ड। तो EDDGrid FromTable EDDTable के लिए अलग-अलग अनुरोध करेगा जो तापमान के बराबर हैं \\[ 0 \\] तापमान \\[ 2500 \\] तापमान \\[ 5000 \\] ।
    
जब एकाधिक अक्ष होते हैं तो अंतर आकार की गणना अधिक जटिल होती है।
    
प्रत्येक उपयोगकर्ता अनुरोध के लिए, EDDGrid FromEDDTable prints डायग्नोस्टिक संदेशों में इस संबंध में [लॉग-इन](/docs/server-admin/additional-information#log) फ़ाइल
    
    * यदि&lt;लॉग लेवल&gt; (#loglevel) में datasets.xml जानकारी के लिए सेट किया गया है, इस तरह के एक संदेश प्रिंट
\\* nOuterAxes=1 of 4 nOuterRequest=22
यदि nOuterAxes=0, gapThreshold से अधिक नहीं था और केवल एक अनुरोध EDDTable को किया जाएगा।
यदि nOuterAxes&gt;0, gapThreshold से अधिक हो गया था और nOuterRequests EDDTable के लिए बनाया जाएगा, प्रत्येक अनुरोध के संयोजन के लिए बाएं सबसे nOuterAxes. उदाहरण के लिए, यदि डेटासेट में 4 है axisVariable s और dataVariable जैसे पूर्वी \\[ समय \\]  \\[ अक्षांश \\]  \\[ लंबाई \\]  \\[ गहराई \\] सबसे बाएं (पहला) अक्ष चर समय है।
    * अगर&lt;लॉग इन करें में datasets.xml सभी के लिए सेट किया गया है, अतिरिक्त जानकारी log.txt फ़ाइल में लिखी गई है।
         
####  EDDGrid FromEDDTable कंकाल एक्सएमएल{#eddgridfromeddtable-skeleton-xml} 
 >&nbsp;&lt;dataset type="EDDGridFromEDDTable" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaWMS>](#accessibleviawms)...&lt;/accessibleViaWMS> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->   
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;updateEveryNMillis>](#updateeverynmillis)...&lt;/updateEveryNMillis> &lt;!-- 0 or 1.   
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For EDDGridFromEDDTable, this only works if the underlying EDDTable  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;supports updateEveryNMillis. -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;gapThreshold>](#gapthreshold)...&lt;/gapThreshold> &lt;!-- 0 or 1. The default is 1000. >  
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addAttributes>](#global-attributes)...&lt;/addAttributes> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;axisVariable>](#axisvariable)...&lt;/axisVariable> &lt;!-- 1 or more -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dataVariable>](#datavariable)...&lt;/dataVariable> &lt;!-- 1 or more -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&lt;dataset>...&lt;/dataset> &lt;!-- The underlying source EDDTable dataset. -->  
 >&nbsp;&lt;/dataset>  

### EDD*From ERDDAP  {#eddfromerddap} 
 ** EDDGrid सेंध** रिमोट से ग्रिड डेटा को संभालती है ERDDAP™ सर्वर
 **EDDTableFromErddap** रिमोट से सारणीबद्ध डेटा को संभालती है ERDDAP™ सर्वर

*    EDDGrid FromErddap and EDDTableFromErddap अन्य सभी प्रकार के डेटासेट से अलग-अलग व्यवहार करते हैं। ERDDAP ।
    * अन्य प्रकार के डेटासेट की तरह, ये डेटासेट स्रोत से डेटासेट के बारे में जानकारी प्राप्त करते हैं और इसे स्मृति में रखते हैं।
    * डेटासेट के अन्य प्रकारों की तरह, जब ERDDAP™ डेटासेट की खोज, डेटा एक्सेस फॉर्म प्रदर्शित करता है ( * datasetID * एचटीएमएल) मेक A Graph form ( * datasetID * ग्राफ़) , ERDDAP™ डेटासेट के बारे में जानकारी का उपयोग करता है जो स्मृति में है।
    *    EDDGrid FromErddap and EDDTable FromErddap के लिए आधार हैं [ग्रिड / क्लस्टर / फेडरेशन](/docs/server-admin/scaling) of ERDDAP s, जो कुशलता से सीपीयू उपयोग वितरित (ज्यादातर नक्शा बनाने के लिए) एक बड़े डेटा सेंटर के मेमोरी उपयोग, डेटासेट भंडारण और बैंडविड्थ उपयोग।
#### रीडायरेक्ट{#redirect} 
* डेटासेट के अन्य प्रकारों के विपरीत, जब ERDDAP™ इन डेटासेट से डेटा या छवियों के लिए अनुरोध प्राप्त करता है, ERDDAP   [पुनर्निर्देशन](https://en.wikipedia.org/wiki/URL_redirection) रिमोट के लिए अनुरोध ERDDAP™ सर्वर परिणाम है:
    * यह बहुत कुशल है (सीपीयू, मेमोरी और बैंडविड्थ) अन्यथा
        1. समग्र ERDDAP™ अन्य को अनुरोध भेजना ERDDAP™   (जो समय लगता है) ।
        2. अन्य ERDDAP™ डेटा प्राप्त करना, इसे सुधारना और डेटा को समग्र में संचारित करना है ERDDAP ।
        3. समग्र ERDDAP™ डेटा प्राप्त करना (बैंडविड्थ का उपयोग करना) इसे सुधारना (सीपीयू और मेमोरी का उपयोग करना) , और उपयोगकर्ता को डेटा संचारित (बैंडविड्थ का उपयोग करना) । अनुरोध को पुनर्निर्देशित करके और दूसरे को अनुमति देना ERDDAP™ उपयोगकर्ता को सीधे प्रतिक्रिया भेजने के लिए, समग्र ERDDAP™ अनिवार्य रूप से अनुरोध पर सीपीयू समय, मेमोरी या बैंडविड्थ खर्च नहीं करता है।
    * ग्राहक सॉफ्टवेयर की परवाह किए बिना उपयोगकर्ता के लिए पुनर्निर्देशित है (ब्राउज़र या किसी अन्य सॉफ्टवेयर या कमांड लाइन टूल) ।
*    [आप कह सकते हैं ERDDAP™ ](#redirect) सेटिंग द्वारा किसी भी उपयोगकर्ता अनुरोध को पुनर्निर्देशित न करें&lt;Redirect&gt;false&lt;/redirect&gt;, लेकिन यह बहुत सारे फायदे की उपेक्षा करता है ...FromErddap डेटासेट प्रकार (विशेष रूप से, लोड को सामने के छोर पर फैलाना ERDDAP™ दूरस्थ / बैकेंड के लिए ERDDAP ) ।
         
     
#### सदस्यता{#subscriptions} 
आम तौर पर, जब EDDGrid FromErddap and EDDTable सेंधप हैं (फिर) आपका स्वागत है ERDDAP वे दूरस्थ डेटासेट के लिए एक सदस्यता जोड़ने की कोशिश करते हैं ERDDAP ईमेल / यूआरएल सदस्यता प्रणाली इस तरह, जब भी दूरस्थ डेटासेट बदलता है, रिमोट ERDDAP™ संपर्क [सेट ध्वज यूआरएल](/docs/server-admin/additional-information#set-dataset-flag) अपने ERDDAP™ इसलिए कि स्थानीय डेटासेट को ASAP रीलोड किया गया है और इसलिए कि स्थानीय डेटासेट हमेशा पूरी तरह से अप-टू-डेट है और दूरस्थ डेटासेट की नकल करता है। तो, पहली बार ऐसा होता है, आपको एक ईमेल अनुरोध करना चाहिए कि आप सदस्यता को मान्य करें। हालांकि, अगर स्थानीय ERDDAP™ कोई ईमेल नहीं भेज सकता है या अगर रिमोट ERDDAP 'ई-मेल/URL सदस्यता प्रणाली सक्रिय नहीं है, आपको दूरस्थ ईमेल करना चाहिए ERDDAP™ प्रशासक और अनुरोध है कि वह मैन्युअल रूप से जोड़ती है [&lt;OnChange&gt; (#onchange) ......&lt;/onChange&gt; अपने डेटासेट को कॉल करने के लिए प्रासंगिक डेटासेट के सभी के लिए टैग [सेट ध्वज यूआरएल](/docs/server-admin/additional-information#set-dataset-flag) । देखें ERDDAP™ सेटडाटासेट की सूची के लिए दैनिक रिपोर्ट ध्वज यूआरएल, लेकिन सिर्फ उन लोगों को भेजने के लिए EDDGrid FromErddap and EDDTableFromErddap datasets to the Remote ERDDAP™ व्यवस्थापक।
    
क्या यह काम नहीं कर रहा है? क्या आपके स्थानीय डेटासेट दूरस्थ डेटासेट के साथ सिंक में नहीं रह रहे हैं?
कई चीजों को इस प्रणाली के लिए सही ढंग से काम करना चाहिए ताकि आपका डाटा सेट अप-टू-डेट बने। इन सभी चीजों को क्रम में देखें:
    
    1. आपका ERDDAP™ ईमेल भेजने में सक्षम होना चाहिए। अपने सेटअप.xml में ईमेल सेटिंग देखें।
    2. सामान्य (लेकिन हमेशा नहीं) , आपका ERDDAP '&lt;BaseUrl&gt; और&lt;BaseHttpsUrl&gt; में पोर्ट नंबर नहीं होना चाहिए (उदाहरण के लिए:8080, :8443) । यदि वे करते हैं, तो इसका उपयोग करें [प्रॉक्सीपास](/docs/server-admin/deploy-install#proxypass) बंदरगाह को Url से निकालने के लिए।
    3. अपने सेटअप.xml में,&lt;सदस्यता ToRemoteErddapDataset&gt; को सही करने के लिए सेट किया जाना चाहिए।
    4. जब आपका स्थानीय EDD ... fromErddap dataset को फिर से लोड किया गया है, इसे रिमोट के लिए एक अनुरोध भेजना चाहिए ERDDAP™ दूरस्थ डेटासेट की सदस्यता के लिए। Log.txt में यह देखने के लिए कि यह क्या हो रहा है।
    5. आपको एक ईमेल प्राप्त करना चाहिए जो आपको सदस्यता अनुरोध को मान्य करने के लिए कहता है।
    6. सदस्यता अनुरोध को मान्य करने के लिए आपको उस ईमेल में लिंक पर क्लिक करना होगा।
    7. दूरस्थ ERDDAP™ यह कहना चाहिए कि सत्यापन सफल रहा। किसी भी समय, आप दूरस्थ से एक ईमेल का अनुरोध कर सकते हैं ERDDAP™ अपने लंबित और वैध सदस्यता की एक सूची के साथ। पर फॉर्म देखें *दूरदर्शन Url* /erddap/subscriptions/list.html
    8. जब दूरस्थ डेटासेट में परिवर्तन होता है (उदाहरण के लिए, अतिरिक्त डेटा प्राप्त करता है) दूरस्थ ERDDAP™ अपने झंडे से संपर्क करने की कोशिश करनी चाहिए ERDDAP । आप इसे नहीं देख सकते, लेकिन आप दूरस्थ के व्यवस्थापक से पूछ सकते हैं ERDDAP™ यह जाँच करने के लिए।
    9. आपका ERDDAP™ उस झंडे को सेट करने के लिए अनुरोध प्राप्त करना चाहिए। "setDatasetFlag.txt" के लिए अपने log.txt को देखें (s) और देखें कि अनुरोधों से जुड़े त्रुटि संदेश क्या है।
    10. आपका ERDDAP™ फिर उस डेटासेट को फिर से लोड करने की कोशिश करनी चाहिए (शायद तुरंत नहीं, बल्कि ASAP) ।
         
#### अप करने के लिए तारीख अधिकतम (समय) ?{#up-to-date-maxtime} 
 EDDGrid /TableFromErddap डेटासेट केवल स्रोत डेटासेट होने पर प्रत्येक स्रोत डेटासेट के बारे में उनकी संग्रहीत जानकारी बदलता है। ["reload"ed](#reloadeverynminutes) मेटाडाटा परिवर्तन का कुछ टुकड़ा (उदाहरण के लिए, समय चर actual\\_range ) जिससे सदस्यता अधिसूचना उत्पन्न होती है। यदि स्रोत डेटासेट में डेटा होता है जो अक्सर बदलता है (उदाहरण के लिए, प्रत्येक सेकंड में नया डेटा) और उपयोग ["update"](#updateeverynmillis) अंतर्निहित डेटा में लगातार परिवर्तन को नोटिस करने के लिए सिस्टम, EDDGrid /TableFromErddap अगले डेटासेट "रीलोड" तक इन लगातार परिवर्तनों के बारे में सूचित नहीं किया जाएगा, इसलिए EDDGrid /TableFromErddap पूरी तरह से अद्यतन नहीं होगा। आप स्रोत डेटासेट के बदलकर इस समस्या को कम कर सकते हैं&lt;ReloadEveryNMinutes&gt; एक छोटे से मूल्य के लिए (60?) इतना है कि वहाँ अधिक सदस्यता अधिसूचनाओं को बताने के लिए कर रहे हैं EDDGrid /TableFromErddap स्रोत डेटासेट के बारे में अपनी जानकारी अद्यतन करने के लिए।

यदि आपके डेटा प्रबंधन प्रणाली को पता चलता है कि स्रोत डेटासेट में नया डेटा है (उदाहरण के लिए, एक स्क्रिप्ट के माध्यम से जो एक डेटा फ़ाइल को जगह में कॉपी करता है) , और अगर वह सुपर लगातार नहीं है (उदाहरण के लिए, हर 5 मिनट, या कम लगातार) एक बेहतर समाधान है:

1. उपयोग न करें&lt;अद्यतन EveryNMillis&gt; स्रोत डेटासेट अप-टू-डेट रखने के लिए।
2. स्रोत डेटासेट सेट करें&lt;ReloadEveryNMinutes&gt; एक बड़ी संख्या में (1440?) ।
3. स्क्रिप्ट स्रोत डेटासेट से संपर्क करें [ध्वज यूआरएल](/docs/server-admin/additional-information#set-dataset-flag) इसके ठीक बाद एक नई डेटा फ़ाइल को जगह में कॉपी किया जाता है।
     

इससे स्रोत डेटासेट पूरी तरह से अप-टू-डेट होने का कारण बनता है और इसे सदस्यता अधिसूचना उत्पन्न करने का कारण बनता है, जिसे भेजा जाएगा। EDDGrid /TableFromErddap डेटासेट। यही कारण है कि नेतृत्व करेंगे EDDGrid /TableFromErddap डेटासेट पूरी तरह से अद्यतन करने के लिए (अच्छी तरह से, नए डेटा के 5 सेकंड के भीतर जोड़ा जा रहा है) । वह सब जो कुशलतापूर्वक किया जाएगा (अनावश्यक डेटासेट रीलोड के बिना) ।
     
#### नहीं addAttributes , axisVariable या dataVariable  {#no-addattributes-axisvariable-or-datavariable} 
डेटासेट के अन्य प्रकारों के विपरीत, EDDTableFromErddap और EDDGrid FromErddap डेटासेट वैश्विक अनुमति नहीं देते&lt;addAttributes&gt;,&lt; axisVariable और Gt; या&lt; dataVariable &gt; अनुभागों में datasets.xml उस डेटासेट के लिए। समस्या यह है कि उन लोगों की अनुमति देने से असंगति होगी:
    
1. आइए कहते हैं कि यह अनुमति दी गई थी और आपने एक नया वैश्विक विशेषता जोड़ा।
2. जब कोई उपयोगकर्ता आपसे पूछता है ERDDAP™ वैश्विक विशेषताओं के लिए, नई विशेषता दिखाई देगी।
3. लेकिन जब कोई उपयोगकर्ता आपसे पूछता है ERDDAP™ एक डेटा फ़ाइल के लिए, आपका ERDDAP™ स्रोत के अनुरोध को पुनर्निर्देशित करता है ERDDAP । कि ERDDAP™ नई विशेषता से अनजान है। तो अगर यह मेटाडाटा के साथ एक डेटा फ़ाइल बनाता है, उदाहरण के लिए, एक .nc फ़ाइल, मेटाडाटा में नई विशेषता नहीं होगी।

वहाँ दो काम के आसपास हैं:

1. स्रोत के व्यवस्थापक Convince ERDDAP™ उन परिवर्तनों को बनाने के लिए जो आप मेटाडाटा चाहते हैं।
2. EDDTableFromErddap के बजाय, उपयोग [EDDTableFromDapSequence](#eddtablefromdapsequence) । या इसके बजाय EDDGrid FromErddap, use [ EDDGrid FromDap](#eddgridfromdap) । उन EDD प्रकार आपको दूरस्थ रूप से डेटासेट से कनेक्ट करने की अनुमति देते हैं ERDDAP™   (लेकिन डेटा अनुरोधों को पुनर्निर्देशित किए बिना) और वे आपको वैश्विक रूप से शामिल करने की अनुमति देते हैं&lt;addAttributes&gt;,&lt; axisVariable और Gt; या&lt; dataVariable &gt; अनुभागों में datasets.xml । एक अन्य अंतर: आपको मैन्युअल रूप से दूरस्थ डेटासेट को सब्सक्राइब करने की आवश्यकता होगी ताकि आपके डेटासेट पर डेटासेट हो सके ERDDAP™ अधिसूचित किया जाएगा (के माध्यम से [ध्वज यूआरएल](/docs/server-admin/additional-information#set-dataset-flag) ) जब दूरस्थ डेटासेट में परिवर्तन होते हैं। इस प्रकार, आप दूरस्थ डेटासेट से जुड़ने के बजाय एक नया डेटासेट बना रहे हैं।
         
#### अन्य नोट्स{#other-notes} 
* सुरक्षा कारणों के लिए EDDGrid FromErddap and EDDTable FromErddap don't support the [[]]&lt;सुलभ (#accessibleto) टैग और दूरस्थ डेटासेट के साथ इस्तेमाल नहीं किया जा सकता है जिसके लिए लॉग इन करना होता है (क्योंकि वे उपयोग करते हैं [&lt;सुलभ (#accessibleto) .. देखें ERDDAP ' [सुरक्षा प्रणाली](/docs/server-admin/additional-information#security) कुछ उपयोगकर्ताओं को कुछ डेटासेट तक पहुंच को प्रतिबंधित करने के लिए।
     
* शुरू ERDDAP™ v2.10, EDDGrid FromErddap and EDDTableFromErddap समर्थन [erddap]&lt;सुलभ ViaFiles&gt; (#accessibleviafiles) टैग अन्य प्रकार के डेटासेट के विपरीत, डिफ़ॉल्ट सही है, लेकिन डेटासेट की फाइलें केवल तभी सुलभ होंगी जब स्रोत डेटासेट भी हो&lt;सुलभ ViaFiles&gt; सही करने के लिए सेट।
     
* आप उपयोग कर सकते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) बनाने के लिए datasets.xml इस प्रकार के डेटासेट के लिए भाग लें। लेकिन आप इन प्रकार के डेटासेट को आसानी से हाथ से कर सकते हैं।
     
####  EDDGrid एर्डडाप कंकाल से एक्सएमएल{#eddgridfromerddap-skeleton-xml} 
*    EDDGrid एर्डडाप कंकाल से XML डेटासेट बहुत सरल है, क्योंकि इरादा सिर्फ दूरस्थ डेटासेट की नकल करना है जो पहले से ही उपयोग के लिए उपयुक्त है। ERDDAP :
 >&nbsp;&nbsp;&lt;dataset type="EDDGridFromErddap" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceUrl>](#sourceurl)...&lt;/sourceUrl>  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaFiles>](#accessibleviafiles)...&lt;/accessibleViaFiles> &lt;!-- 0 or 1, default=true. -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;updateEveryNMillis>](#updateeverynmillis)...&lt;/updateEveryNMillis> &lt;!-- 0 or 1   
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For EDDGridFromErddap, this gets the remote .dds and then gets  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the new leftmost (first) dimension values. -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;nThreads>](#nthreads)...&lt;/nThreads> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dimensionValuesInMemory>](#dimensionvaluesinmemory)...&lt;/dimensionValuesInMemory> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
 >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;redirect>](#redirect)true(default)|false&lt;/redirect> &lt;!-- 0 or 1; -->  
 >&nbsp;&nbsp;&lt;/dataset>  

#### EDDTableFromErddap कंकाल एक्सएमएल{#eddtablefromerddap-skeleton-xml} 
* एक EDDTableFromErddap Dataset के लिए कंकाल XML बहुत सरल है, क्योंकि इरादा दूरस्थ डेटासेट की नकल करना है, जो पहले से ही उपयोग के लिए उपयुक्त है। ERDDAP :
>&nbsp;&nbsp;&lt;dataset type="EDDTableFromErddap" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceUrl>](#sourceurl)...&lt;/sourceUrl>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addVariablesWhere>](#addvariableswhere)...&lt;/addVariablesWhere> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;redirect>](#redirect)true(default)|false&lt;/redirect> &lt;!-- 0 or 1; -->  
>&nbsp;&nbsp;&lt;/dataset>  

###  EDDGrid Etopo{#eddgridfrometopo} 
 [ ** EDDGrid Etopo** ](#eddgridfrometopo) बस सेवा [ETOPO1 ग्लोबल 1-मिन्यूट ग्रिड्ड एलिवेशन डेटा सेट](https://www.ngdc.noaa.gov/mgg/global/global.html)   (बर्फ की सतह, ग्रिड पंजीकृत, द्विआधारी, 2byte int: etopo1\\_ice\\_g\\_i2 .zip ) जिसे वितरित किया जाता है ERDDAP ।

* केवल दो datasetID एस के लिए समर्थित हैं EDDGrid FromEtopo, ताकि आप डेटा को अक्षांश मान -180 से 180, या अक्षांश मान 0 से 360 तक एक्सेस कर सकें।
* कभी भी कोई उप टैग नहीं हैं, क्योंकि डेटा पहले से ही भीतर वर्णित है ERDDAP ।
* तो दो विकल्प EDDGrid FromEtopo डाटासेट हैं (सचमुच) :
```
      <!-- etopo180 serves the data from longitude -180 to 180 -->
      <dataset type="EDDGridFromEtopo" datasetID="etopo180" /> 
      <!-- etopo360 serves the data from longitude 0 to 360 -->
      <dataset type="EDDGridFromEtopo" datasetID="etopo360" /> 
```

###  EDDGrid सेफिल{#eddgridfromfiles} 
 [ ** EDDGrid सेफिल** ](#eddgridfromfiles) सभी का सुपरक्लास है EDDGrid ...फिल्म कक्षाओं से। आप उपयोग नहीं कर सकते EDDGrid सीधे फिल्स से। इसके बजाय, एक उपश्रेणी का उपयोग करें EDDGrid FromFiles विशिष्ट फ़ाइल प्रकार को संभालने के लिए:

*    [ EDDGrid FromMergeIRFiles](#eddgridfrommergeirfiles) ग्रिड से डेटा संभालती है [मर्जी .gz ](https://www.cpc.ncep.noaa.gov/products/global_precip/html/README) फ़ाइलें
*    [ EDDGrid AudioFiles](#eddfromaudiofiles) स्थानीय ऑडियो फ़ाइलों के एक समूह से डेटा एकत्र करता है।
*    [ EDDGrid FromNcFiles](#eddgridfromncfiles) ग्रिड से डेटा संभालती है [GRIB .grb](https://en.wikipedia.org/wiki/GRIB) फ़ाइलें, [ HDF   (v4 or v5)   .hdf ](https://www.hdfgroup.org/) फ़ाइलें, [ .nc एमएल](#ncml-files) फ़ाइलें, और [ NetCDF   (v3)   .nc ](https://www.unidata.ucar.edu/software/netcdf/) फ़ाइलें यह अन्य फ़ाइल प्रकारों के साथ काम कर सकता है (उदाहरण के लिए, BUFR) यदि आप रुचि रखते हैं तो कृपया हमें कुछ नमूना फ़ाइलों को भेजें।
*    [ EDDGrid से NcFilesUnpacked](#eddgridfromncfilesunpacked) का एक प्रकार है EDDGrid से NcFiles जो ग्रिड से डेटा को संभालती है NetCDF   (v3)   .nc और संबंधित फाइलें, जो ERDDAP™ कम स्तर पर अनपैक।

वर्तमान में, कोई अन्य फ़ाइल प्रकार समर्थित नहीं है। लेकिन यह आमतौर पर अन्य फ़ाइल प्रकारों के लिए समर्थन जोड़ने के लिए अपेक्षाकृत आसान है। यदि आपके पास अनुरोध है तो हमसे संपर्क करें। यदि आपका डेटा पुराने फ़ाइल प्रारूप में है तो आप दूर जाना चाहते हैं, तो हम अनुशंसा करते हैं कि फ़ाइलों को परिवर्तित करने के लिए फ़ाइलों को परिवर्तित करें। NetCDF v3 .nc फ़ाइलें NetCDF एक व्यापक रूप से समर्थित, द्विआधारी प्रारूप है, डेटा तक तेजी से यादृच्छिक पहुंच की अनुमति देता है, और पहले से ही समर्थित है ERDDAP ।

#### फाइल विवरण से{#from-files-details} 
निम्नलिखित जानकारी सब वर्गों के लिए लागू होती है EDDGrid सेफाइल्स

##### मौजूदा आयाम का एकत्रीकरण{#aggregation-of-an-existing-dimension} 
के सभी रूपों EDDGrid FromFiles स्थानीय फ़ाइलों से डेटा एकत्र कर सकते हैं, जहां प्रत्येक फ़ाइल में 1 है (या अधिक) बायीं ओर विभिन्न मूल्यों (पहला) आयाम, आमतौर पर \\[ समय \\] , जो समुचित हो जाएगा। उदाहरण के लिए, आयाम हो सकता है \\[ समय \\]  \\[ ऊंचाई \\]  \\[ अक्षांश \\]  \\[ लंबाई \\] , और फ़ाइलों को एक के लिए डेटा हो सकता है (कुछ) समय मूल्य (s) प्रति फ़ाइल परिणामस्वरूप डेटासेट दिखाई देता है जैसे कि फ़ाइल के सभी डेटा को जोड़ा गया था। एकत्रीकरण के बड़े फायदे हैं:

* समुचित डेटा सेट का आकार एक फ़ाइल की तुलना में बहुत बड़ा हो सकता है, आसानी से किया जा सकता है (~2GB) ।
* निकट-वास्तविक समय डेटा के लिए, डेटा के नवीनतम हिस्से के साथ एक नई फ़ाइल जोड़ना आसान है। आपको पूरे डेटासेट को फिर से लिखना नहीं है।

एकत्रीकरण की आवश्यकताएं हैं:
* स्थानीय फ़ाइलों की आवश्यकता नहीं है dataVariable s (डेटासेट में परिभाषित के रूप में datasets.xml ) । डेटासेट होगा dataVariable में परिभाषित datasets.xml । यदि किसी दिए गए फ़ाइल में कोई दी गई फ़ाइल नहीं होती है dataVariable , ERDDAP™ आवश्यकतानुसार लापता मूल्यों को जोड़ देगा।
* सभी dataVariable MUST उसी का उपयोग करता है axisVariable S/dimension (डेटासेट में परिभाषित के रूप में datasets.xml ) । पहले के आधार पर फ़ाइलों को एकत्र किया जाएगा (सबसे ज्यादा) आयाम, आरोही क्रम में क्रमबद्ध।
* प्रत्येक फ़ाइल MAY में पहले आयाम के एक या अधिक मूल्यों के लिए डेटा होता है, लेकिन फ़ाइलों के बीच कोई ओवरलैप नहीं हो सकता है। यदि फ़ाइल में पहले आयाम के लिए एक से अधिक मान हैं, तो मान MUST को आरोही क्रम में क्रमबद्ध किया जाएगा, जिसमें कोई संबंध नहीं है।
* सभी फाइलें MUST में अन्य सभी आयामों के लिए बिल्कुल समान मान हैं। परीक्षण की परिशुद्धता द्वारा निर्धारित की जाती है [मैच AxisNDigits](#matchaxisndigits) ।
* सभी फाइलें MUST बिल्कुल समान हैं [यूनिट](#units) सभी के लिए मेटाडाटा axisVariable s और dataVariable S. यदि यह एक समस्या है, तो आप उपयोग करने में सक्षम हो सकते हैं [एनसीएमएल](#ncml-files) या [ NCO ](#netcdf-operators-nco) समस्या को ठीक करने के लिए।
         
##### फ़ाइल नाम या वैश्विक मेटाडाटा के माध्यम से एकत्रीकरण{#aggregation-via-file-names-or-global-metadata} 
के सभी रूपों EDDGrid FromFiles एक नए बाएं सबसे अधिक जोड़कर फ़ाइलों का एक समूह भी एकत्र कर सकता है (पहला) आयाम, आम तौर पर समय, प्रत्येक फ़ाइल नाम से या प्रत्येक फ़ाइल में है कि एक वैश्विक विशेषता के मूल्य से व्युत्पन्न मूल्य के आधार पर। उदाहरण के लिए, फ़ाइल नाम में फ़ाइल में डेटा के लिए समय मान शामिल हो सकता है। ERDDAP™ फिर एक नया समय आयाम बना देगा।

THREDDS में समान विशेषता के विपरीत, ERDDAP™ हमेशा बनाना axisVariable संख्यात्मक मूल्यों के साथ (सीएफ द्वारा आवश्यकतानुसार) कभी स्ट्रिंग मूल्य नहीं (जो CF द्वारा अनुमति नहीं है) । इसके अलावा, ERDDAP™ संख्यात्मक आधार पर एकत्रीकरण में फ़ाइलों को सॉर्ट करेगा axisVariable मान जो प्रत्येक फ़ाइल को सौंपा गया है, ताकि अक्ष चर हमेशा सीएफ द्वारा आवश्यक मानों को सॉर्ट किया जाएगा। फ़ाइल नामों के आधार पर एक lexicographic प्रकार करने का THREDDS दृष्टिकोण एकत्रीकरण की ओर जाता है जहां अक्ष मूल्यों को सॉर्ट नहीं किया जाता है। (जो CF द्वारा अनुमति नहीं है) जब फ़ाइल नाम अलग तरह से व्युत्पन्न की तुलना में axisVariable मान

इन संकलनों में से एक को स्थापित करने के लिए ERDDAP™ , आप एक नया leftmost परिभाषित करेंगे (पहला)   [ axisVariable ](#axisvariable) विशेष, छद्म के साथ&lt; sourceName &gt;, जो कहता है ERDDAP™ जहां और कैसे प्रत्येक फ़ाइल से नए आयाम के लिए मूल्य खोजने के लिए।

* छद्म के लिए प्रारूप sourceName जो एक फ़ाइल नाम से मूल्य प्राप्त करता है (बस filename.ext) है
    \\*\\*\\ *फ़ाइल नाम*  [डेटा प्रकार](#data-types)  *,* अर्क *,* समूह संख्या*
* छद्म के लिए प्रारूप sourceName जो एक फ़ाइल के पूर्ण पथ नाम से मान प्राप्त करता है
    \\*\\*\\ *पथनाम*  [डेटा प्रकार](#data-types)  *,* अर्क *,* समूह संख्या*
     \\[ इसके लिए, पथ का नाम हमेशा उपयोग करता है '/' निर्देशिका विभाजक चरित्र के रूप में, कभी नहीं '\'। \\] 
* छद्म के लिए प्रारूप sourceName जो वैश्विक विशेषता से मूल्य प्राप्त होता है
    \\*\\*\\ *वैश्विक:* विशेषता नाम *,*  [डेटा प्रकार](#data-types)  *,* अर्क *,* समूह संख्या*
* यह छद्म sourceName विकल्प दूसरों से अलग तरीके से काम करता है: इसके बजाय एक नया बाएं (पहला)   axisVariable यह वर्तमान के मूल्य को बदल देता है axisVariable फ़ाइल नाम से निकाले गए मूल्य के साथ (बस filename.ext) । प्रारूप है
    \\*\\*\\ *बदलना फ़ाइलनाम से,*  [डेटा प्रकार](#data-types)  *,* अर्क *,* समूह संख्या*
     

जिन हिस्सों को आप प्रदान करना चाहते हैं, उनके विवरण हैं:

*    *विशेषता नाम* -- वैश्विक विशेषता का नाम जो प्रत्येक फ़ाइल में है और जिसमें आयाम मान होता है।
*    *डेटा प्रकार* -- यह डेटा प्रकार निर्दिष्ट करता है जिसका उपयोग मूल्यों को स्टोर करने के लिए किया जाएगा। की मानक सूची देखें [डेटा प्रकार](#data-types) कि ERDDAP™ समर्थन करता है, सिवाय उस स्ट्रिंग को यहां अक्ष चर के बाद से अनुमति नहीं है ERDDAP™ स्ट्रिंग चर नहीं हो सकता है।
    
एक अतिरिक्त छद्म डेटाटाइप, टाइमफॉर्मैट = है *स्ट्रिंग टाइमफॉर्मैट* कौन कहता है ERDDAP™ यह मान एक स्ट्रिंग टाइमस्टैम्प है [स्ट्रिंग समय के लिए उपयुक्त इकाइयों](#string-time-units) । अधिकांश मामलों में, आपको आवश्यक स्ट्रिंगटाइमफॉर्मैट इन प्रारूपों में से एक का एक रूप होगा:
    
    *    yyyy-MM-dd 'T'H:mm:ss.SSSZ - जो ISO 8601:2004 (E) तारीख समय प्रारूप। आपको इसका एक छोटा संस्करण की आवश्यकता हो सकती है, उदाहरण के लिए, yyyy-MM-dd 'T'H:mm:s, or yyyy-MM-dd ।
    * YyymmddHmms.SSS - जो ISO 8601 तारीख समय प्रारूप का कॉम्पैक्ट संस्करण है। आपको इसका एक छोटा संस्करण, उदाहरण के लिए, yyyymmddHmms या yyyymmdd की आवश्यकता हो सकती है।
    * M/d/yyyyy एच: मिमी: एसएसएसएस - जो यूएस स्लैश डेट प्रारूप है। आपको इसका एक छोटा संस्करण की आवश्यकता हो सकती है, उदाहरण के लिए, M/d/yyyyy.
    * yyydddhmmsssSS - जो वर्ष और वर्ष के शून्य गद्देदार दिन है (उदाहरण के लिए, 001 = जनवरी 1, 365 = दिसंबर 31 एक गैर-लीप वर्ष में; कभी-कभी इसे कभी-कभी जूलियन तारीख कहा जाता है।) । आपको इसका एक छोटा संस्करण की आवश्यकता हो सकती है, उदाहरण के लिए, yyyddd।
    
यदि आप इस छद्म डेटाटाइप का उपयोग करते हैं, तो इसे नए परिवर्तनीय के रूप में जोड़ें&lt; addAttributes &gt;:
```
        <att name="units">seconds since 1970-01-01T00:00:00Z</att>  
```
यदि आप सभी समय मूल्यों को बदलना चाहते हैं, तो इकाइयों में समय मान को स्थानांतरित करें, उदाहरण के लिए,
1970-01-01T12:00:00Z.
*    *अर्क* -- यह है [नियमित अभिव्यक्ति](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html)   ( [ट्यूटोरियल](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html) ) जिसमें एक कैप्चर समूह शामिल है (माता-पिता में) जो वर्णन करता है कि कैसे फ़ाइल नाम या वैश्विक विशेषता मान से मूल्य निकालने के लिए। उदाहरण के लिए, S19980011998031.L3b\\_MO\\_CHL की तरह एक फ़ाइल नाम दिया गया। .nc , समूह #1 कब्जा, "\" \\dट्यूटोरियल ", नियमित अभिव्यक्ति एस में (\\ \\dट्यूटोरियल ) \\ \\dट्यूटोरियल \\.L3b.\\* 'S': 1998001 के बाद पहले 7 अंकों को कैप्चर करेगा।
*    *समूह* -- यह कैप्चर समूह की संख्या है (माता-पिता की एक जोड़ी के भीतर) नियमित अभिव्यक्ति में जिसमें रुचि की जानकारी होती है। यह आम तौर पर 1, पहला कैप्चर समूह है। कभी-कभी आपको रेगेक्स में अन्य प्रयोजनों के लिए कैप्चर समूहों का उपयोग करने की आवश्यकता होती है, इसलिए तब महत्वपूर्ण कैप्चर समूह संख्या 2 होगी। (दूसरा कैप्चर समूह) या 3 (तीसरा) आदि

एक पूर्ण उदाहरण axisVariable जो एक नए समय अक्ष के साथ एक समेकित डेटासेट बनाता है जो प्रत्येक फ़ाइल के फ़ाइल नाम से समय मान प्राप्त करता है।
```
      <axisVariable>
        <sourceName>\\*\\*\\*fileName,timeFormat=yyyyDDD,S(\\d{7})\\.L3m.\\*,1</sourceName>
        <destinationName>time</destinationName>
      </axisVariable>
```
जब आप "timeFormat=" छद्म डेटा का उपयोग करते हैं प्रकार, ERDDAP™ 2 विशेषताओं को जोड़ देगा axisVariable इसलिए वे स्रोत से आने लगते हैं:
```
    <att name="standard\\_name">time</att>  
    <att name="units">seconds since 1970-01-01T00:00:00Z</att>  
```
इस मामले में, ERDDAP™ एक नया अक्ष बनाया जाएगा "time" दोहरे मूल्यों के साथ (1970-01-01T00:00:00Z) 'S' के बाद 7 अंकों को निकालकर और फ़ाइल नाम में ".L3m" से पहले और उन लोगों की व्याख्या करते हुए जिन्हें समय मान के रूप में YyyyDDD के रूप में स्वरूपित किया गया था।

आप डिफ़ॉल्ट आधार समय को ओवरराइड कर सकते हैं (1970-01-01T00:00:00Z) जोड़कर [Attribute](#addattributes) जो अलग-अलग इकाइयों को अलग-अलग आधार समय के साथ निर्दिष्ट करता है। एक आम स्थिति है: वहाँ डेटा फ़ाइलों के समूह हैं, प्रत्येक एक उपग्रह डाटासेट के 1 दिन मिश्रित के साथ, जहां आप चाहते हैं कि समय मान के लिए दोपहर का दिन फ़ाइल नाम में उल्लेख किया है (प्रत्येक दिन केन्द्रित समय) और वेरिएबल चाहते हैं long\\_name "Centered Time" होना चाहिए। यह कौन है:
```
      <axisVariable>
        <sourceName>\\*\\*\\*fileName,timeFormat=yyyyDDD,S(\\d{7})\\.L3m.\\*,1</sourceName>
        <destinationName>time</destinationName>
        <addAttributes>
          <att name="long\\_name">Centered Time</att>
          <att name="units">seconds since 1970-01-01T12:00:00Z</att>
        </addAttributes>
      </axisVariable>
```
आधार समय में नोट घंटे = 12, जो 1970-01-01T00:00Z के मूल आधार समय के सापेक्ष 12 घंटे जोड़ता है।

एक पूर्ण उदाहरण axisVariable जो एक नए "रन" अक्ष के साथ एक समेकित डेटासेट बनाता है (Int मान के साथ) जो प्रत्येक फ़ाइल में "runID" वैश्विक विशेषता से रन मान प्राप्त करता है ("r17\\_global" जैसे मूल्यों के साथ, जहां 17 रन नंबर है) है
```
      <axisVariable> 
        <sourceName>\\*\\*\\*global:runID,int,(r|s)(\\d+)\\_global,2</sourceName>
        <destinationName>run</destinationName>
        <addAttributes>
          <att name="ioos\\_category">Other</att>
          <att name="units">count</att>
        </addAttributes>
      </axisVariable>
```
'r' या 's' के बाद होने वाले अंकों को पकड़ने के लिए कैप्चर समूह संख्या 2 का उपयोग नोट करें, और "\\_global" से पहले। यह उदाहरण यह भी दिखाता है कि अतिरिक्त विशेषताओं को कैसे जोड़ा जाए (उदाहरण के लिए ioos\\_category इकाई) अक्ष चर के लिए।
     
#### बाह्य रूप से संपीड़ित फ़ाइलें{#externally-compressed-files} 
* डेटासेट जो कि सबसेट हैं EDDGrid FromFiles and EDDTable FromFiles बाह्य रूप से संपीड़ित डेटा फ़ाइलों से सीधे डेटा की सेवा कर सकते हैं, जिनमें शामिल हैं .tgz , .tar  .gz , .tar  .gzip , .gz , .gzip , .zip , .bz2 , और .Z फ़ाइलें।
     
*    **यह आश्चर्यजनक रूप से अच्छी तरह से काम करता है&#33;**   
ज्यादातर मामलों में, छोटी और मध्यम आकार की डेटा फ़ाइलों को डिकंप्रेस करने से संबंधित मंदी मामूली है। यदि आपको डिस्क स्पेस को संरक्षित करने की आवश्यकता है, तो हम इस सुविधा का उपयोग करने के लिए दृढ़ता से प्रोत्साहित करते हैं, विशेष रूप से पुरानी फ़ाइलों के लिए जो शायद ही कभी एक्सेस किए जाते हैं।
     
*    **पैसे बचाओ&#33;**   
इसमें कुछ विशेषताएं हैं ERDDAP™ जो आपको बहुत सारे पैसे बचाने का मौका देता है (हालांकि थोड़ा कम प्रदर्शन की लागत पर) । यदि संपीड़न अनुपात उदाहरण है, तो 6:1 (कभी कभी यह बहुत अधिक होगा) फिर डेटासेट की डेटा फ़ाइलों को केवल 1/6 डिस्क स्पेस की आवश्यकता होगी। फिर शायद आप 1 RAID के साथ मिल सकते हैं (किसी दिए गए आकार का) 6 RAIDS के बजाय (समान आकार) । यह एक विशाल लागत बचत है। उम्मीद है कि एक संग्रह में कुछ फ़ाइलों को संपीड़ित करने की क्षमता (पुराने लोग?) और दूसरों को संपीड़ित नहीं करना (नए लोग?) , और किसी भी समय इसे बदलने के लिए, चलो आप फ़ाइलों में से कुछ को कंप्रेस करने के लिए डाउनसाइड को कम करते हैं (धीमी पहुँच) । यदि विकल्प टेप पर फ़ाइलों को संग्रहीत करने के बीच है (केवल अनुरोध पर सुलभ, देरी के बाद) उन्हें एक RAID पर संकुचित भंडारण बनाम (और सुलभ ERDDAP ) , फिर संपीड़न का उपयोग करने का एक बड़ा लाभ है ताकि उपयोगकर्ता इंटरैक्टिव हो सकें और (अपेक्षाकृत) डेटा तक त्वरित पहुंच। अगर यह आपको अतिरिक्त RAID खरीदने से बचा सकता है, तो यह सुविधा आपको $30,000 डॉलर बचा सकती है।
     
* सभी के लिए EDDGrid FromFiles subclasses, यदि डेटा फ़ाइलों का विस्तार होता है तो यह दर्शाता है कि वे बाहरी रूप से संपीड़ित फाइलें हैं। (वर्तमान में: .tgz , .tar  .gz , .tar  .gzip , .gz , .gzip , .zip , .bz2 A.Z.) , ERDDAP™ जब यह उन्हें पढ़ता है तो डेटासेट की कैश डायरेक्टरी को फ़ाइलों को डिकंप्रेस करेगा (अगर वे पहले से ही कैश में नहीं हैं) । वही द्विआधारी फ़ाइल के लिए सच है (उदाहरण के लिए .nc ) EDDTableFromFiles के उपवर्ग।
     
* EDDTableFromFiles के लिए गैर-binary फ़ाइलों के लिए उप-वर्ग (उदाहरण के लिए, csv) एक एक्सटेंशन के साथ डेटा फाइलें यह संकेत देती हैं कि वे बाहरी रूप से संपीड़ित फ़ाइलों को ऑन-द-फ्लाई को डिकंप्रेस किया जाएगा क्योंकि फ़ाइल को पढ़ा जाता है।
     
* REQUIREMENT: यदि बाहरी रूप से संपीड़ित फ़ाइल का प्रकार उपयोग किया जाता है (उदाहरण के लिए .tgz या .zip ) संपीड़ित फ़ाइल के अंदर 1 से अधिक फ़ाइल का समर्थन करता है, संपीड़ित फ़ाइल में सिर्फ 1 फ़ाइल होना चाहिए।
     
* REQUIREMENT: यह सुविधा मानती है कि बाहरी रूप से संपीड़ित फ़ाइलों की सामग्री बदल नहीं जाती है, ताकि एक कैश्ड डिकंप्रेस्ड फ़ाइल का पुन: उपयोग किया जा सके। यदि कुछ या सभी डेटासेट की डेटा फ़ाइलों को कभी-कभी बदल दिया जाता है, तो उन फ़ाइलों को संपीड़ित न करें। यह आम उपयोग के अनुरूप है, क्योंकि लोग आम तौर पर उन फ़ाइलों को संपीड़ित नहीं करते हैं जिन्हें उन्हें कभी-कभी बदलने की आवश्यकता होती है।
     
*   &lt;फ़ाइल नाम Regex&gt; इस काम को बनाने के लिए, डेटासेट का&lt;फ़ाइलNameRegex&gt; को संपीड़ित फ़ाइलों के नाम से मिलान करना चाहिए। जाहिर है, जैसे regexes।\\*सभी फ़ाइल नामों से मेल खाते हैं। यदि आप एक विशिष्ट फ़ाइल प्रकार निर्दिष्ट करते हैं, उदाहरण के लिए, ।\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ .nc , फिर आपको संपीड़न विस्तार को भी शामिल करने के लिए रेगेक्स को संशोधित करने की आवश्यकता है, उदाहरण के लिए,। *\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ .nc \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ .gz (यदि सभी फाइलें होंगी)* * .nc  .gz फ़ाइलें
     
* यह ठीक है यदि आपके डेटासेट में संपीड़ित का मिश्रण और संपीड़ित फ़ाइलों का मिश्रण शामिल है। यदि आप मानते हैं कि कुछ फाइलें (उदाहरण के लिए, पुरानी फाइलें) अक्सर इस्तेमाल किया जाएगा और इसलिए उन्हें कंप्रेस करके डिस्क स्पेस को बचाने के लिए उपयोगी होगा। इस काम को बनाने के लिए,&lt;फ़ाइलNameRegex&gt; को संपीड़ित और संपीड़ित फ़ाइलों के नाम, उदाहरण के लिए, मिलान करना चाहिए।\\*या।\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ .nc  ( | \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ .gz ) (जहां उस के अंत में कैप्चर समूह यह निर्दिष्ट करता है कि .gz वैकल्पिक है।
     
* यदि आप किसी भी समय संग्रह में विशिष्ट फ़ाइलों को संपीड़ित या डीकंप्रेस करते हैं तो यह ठीक है।
यदि डेटासेट का उपयोग नहीं किया जाता है [&lt;EveryNMillis (#updateeverynmillis) डेटासेट सेट करें [झंडा](/docs/server-admin/additional-information#flag) बताने के लिए ERDDAP™ डेटासेट को फिर से लोड करने के लिए और इस प्रकार परिवर्तन को नोटिस करता है। दिलचस्प बात यह है कि आप एक ही डेटासेट में विभिन्न फ़ाइलों के लिए विभिन्न संपीड़न एल्गोरिदम और सेटिंग्स का उपयोग कर सकते हैं (उदाहरण के लिए .bz2 शायद ही कभी इस्तेमाल फ़ाइलों के लिए, .gz अक्सर इस्तेमाल की जाने वाली फ़ाइलों के लिए और अक्सर इस्तेमाल की जाने वाली फ़ाइलों के लिए कोई संपीड़न नहीं) , सिर्फ यकीन है कि रेगेक्स उन सभी फ़ाइल एक्सटेंशनों का समर्थन करता है जो उपयोग में हैं, उदाहरण के लिए, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\]\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ .nc  ( | \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ .gz  | \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ .bz2 ) ।
     
* बेशक, विभिन्न संपीड़न एल्गोरिदम के लिए संपीड़न अनुपात और गति स्रोत फ़ाइल और सेटिंग्स के साथ भिन्न होती है (उदाहरण के लिए, संपीड़न स्तर) । यदि आप अपनी फ़ाइलों के लिए इस प्रणाली को अनुकूलित करना चाहते हैं, तो अपनी फ़ाइलों के साथ और संपीड़न सेटिंग्स की एक श्रृंखला के साथ विभिन्न संपीड़न विधियों का परीक्षण करें। यदि आप ईमानदारी से अच्छे हैं (सबसे अच्छा) सेटअप, हम थोड़ा सिफारिश करेंगे gzip   ( .gz ) । gzip सबसे छोटी संकुचित फ़ाइल नहीं बनाती (यह काफी करीब है) लेकिन यह बहुत जल्दी फ़ाइल को संपीड़ित करता है और (महत्वपूर्ण ERDDAP™ उपयोगकर्ता) फ़ाइल को जल्दी से डिकंप्रेस करता है। प्लस, gzip सॉफ्टवेयर हर लिनक्स और मैक ओएस स्थापना के साथ मानक आता है और 7Zip और लिनक्स ऐड-ऑन जैसे गिट बैश जैसे मुफ्त उपकरणों के माध्यम से विंडोज के लिए आसानी से उपलब्ध है। उदाहरण के लिए, एक स्रोत फ़ाइल को एक स्रोत फ़ाइल में संपीड़ित करने के लिए .gz फ़ाइल का संस्करण (एक ही फ़ाइल नाम, लेकिन साथ में .gz परिशिष्ट) उपयोग (लिनक्स, मैक ओएस और गिट बैश में)   
     gzip   * sourceName *   
एक decompressed .gz फ़ाइल वापस मूल में, उपयोग
बंदूक * sourceName  .gz *   
निर्देशिका में प्रत्येक स्रोत फ़ाइलों को संपीड़ित करने के लिए और इसके उपनिर्देशिकाओं, पुनरावर्ती, उपयोग
     gzip -r *निदेशकनाम*   
प्रत्येक को डिकंप्रेस करने के लिए .gz निर्देशिका और इसके उपनिर्देशों में फाइलें, पुनरावर्ती रूप से, उपयोग
Gunzip -r *निदेशकनाम*   
     
* चेतावनी: बाह्य रूप से संपीड़ित न करें ( gzip ) फ़ाइलें जो पहले से ही आंतरिक रूप से संपीड़ित हैं&#33;
कई फाइलें पहले से ही आंतरिक रूप से संकुचित डेटा है। यदि आप gzip इन फ़ाइलों, जिसके परिणामस्वरूप फ़ाइलों को बहुत छोटा नहीं होगा ()&lt;5% ERDDAP™ जब उन्हें पढ़ने की आवश्यकता होती है तो उन्हें बर्बाद करने का समय होगा। उदाहरण के लिए:
    
    * डेटा फाइलें: उदाहरण के लिए, .nc 4, और .hdf 5 फाइलें: कुछ फाइलें आंतरिक संपीड़न का उपयोग करती हैं; कुछ नहीं करते। कैसे बताएं: संपीड़ित चर में "\\_ChunkSize" गुण होते हैं। इसके अलावा, अगर ग्रिड का एक समूह .nc या .hdf फाइलें सभी अलग-अलग आकार हैं, वे आंतरिक रूप से संपीड़ित होने की संभावना रखते हैं। यदि वे सभी समान आकार के होते हैं, तो वे आंतरिक रूप से संपीड़ित नहीं होते हैं।
    * Englishالعربية中文(简体)हिन्दी; हिंदीاردو
    * ऑडियो फाइलें: उदाहरण के लिए, .mp3, और .ogg।
    * वीडियो फाइलें: उदाहरण के लिए, .mp4, .ogv, और .webm।
    
        
एक दुर्भाग्यपूर्ण अजीब मामला: .wav ऑडियो फाइलें विशाल हैं और आंतरिक रूप से संपीड़ित नहीं हैं। यह संपीड़न के लिए अच्छा होगा ( gzip ) उन्हें, लेकिन आम तौर पर आपको ऐसा नहीं करना चाहिए क्योंकि यदि आप करते हैं, तो उपयोगकर्ता अपने ब्राउज़र में संपीड़ित फ़ाइलों को खेलने में सक्षम नहीं होंगे।
     
* टेस्ट केस: संपीड़न (साथ gzip ) 1523 ग्रिड के साथ एक डेटासेट .nc फ़ाइलें
    
    * स्रोत फ़ाइलों में डेटा sparse था (कई लापता मान) ।
    * कुल डिस्क स्थान संपीड़न से पहले 57 जीबी से उसके बाद 7 जीबी तक चला गया।
    * 1 समय बिंदु से बहुत सारे डेटा के लिए अनुरोध है&lt;संपीड़न से पहले और बाद में 1 सेकंड।
    * 365 समय बिंदुओं के लिए एक अनुरोध (सबसे खराब स्थिति) 4 से 71 तक चला गया।
         
    
मेरे लिए जो किसी भी डेटासेट के लिए एक उचित व्यापार-बंद है, और निश्चित रूप से डेटासेट के लिए जो अक्सर उपयोग किए जाते हैं।
     
* आंतरिक बनाम बाह्य संपीड़न -
द्वारा प्रस्तुत आंतरिक फ़ाइल संपीड़न की तुलना में .nc 4 और 4 .hdf 5 फाइलें, ERDDAP बाह्य रूप से संपीड़ित द्विआधारी फ़ाइलों के लिए दृष्टिकोण के फायदे और नुकसान हैं। नुकसान यह है: एक बार एक फ़ाइल का एक छोटा सा हिस्सा पढ़ने के लिए, आंतरिक संपीड़न बेहतर है क्योंकि EDDGrid FromFiles केवल कुछ ही हिस्से को डिकॉम्प करने की जरूरत है (s) फ़ाइल की पूरी फ़ाइल नहीं है। लेकिन ERDDAP कुछ फायदे हैं:
    
    *    ERDDAP™ डेटा फ़ाइलों के सभी प्रकार के संपीड़न का समर्थन करता है (बाइनरी और गैर-बाइनरी, उदाहरण के लिए, .nc 3 और csv) नहीं .nc 4 और 4 .hdf 4.
    * यदि किसी फ़ाइल के थोक को थोड़े समय में एक बार से अधिक पढ़ने की आवश्यकता होती है, तो यह एक बार फ़ाइल को डिकंप्रेस करने और इसे कई बार पढ़ने के लिए समय बचाता है। यह होता है ERDDAP™ जब कोई उपयोगकर्ता डेटासेट के लिए मेक-ए-ग्राफ का उपयोग करता है और ग्राफ में छोटे बदलावों की एक श्रृंखला बनाता है।
    * संकुचित फ़ाइलों को रखने की क्षमता और उसी संग्रह में संपीड़ित फ़ाइलों को संपीड़ित नहीं करने की क्षमता आपको अधिक नियंत्रण की अनुमति देती है, जिस पर फ़ाइलों को संकुचित किया जाता है और जो नहीं होते हैं। और यह जोड़ा गया नियंत्रण वास्तव में स्रोत फ़ाइल को संशोधित किए बिना आता है (चूंकि आप ई.जी. के साथ एक फ़ाइल को संपीड़ित कर सकते हैं, .gz और फिर इसे मूल फ़ाइल प्राप्त करने के लिए डिकंप्रेस करें) ।
    * किसी भी समय किसी दिए गए फ़ाइल को संकुचित करने की क्षमता और इसे कैसे संकुचित किया जाता है (विभिन्न एल्गोरिदम और सेटिंग्स) आपको सिस्टम के प्रदर्शन पर अधिक नियंत्रण देता है। और आप किसी भी समय मूल असंपीड़ित फ़ाइल को आसानी से ठीक कर सकते हैं।
    
जबकि न तो दृष्टिकोण सभी स्थितियों में एक विजेता है, यह स्पष्ट है कि ERDDAP बाह्य रूप से संपीड़ित फ़ाइलों से डेटा की सेवा करने की क्षमता बाहरी संपीड़न को आंतरिक संपीड़न के लिए उचित विकल्प बनाती है। .nc 4 और 4 .hdf 5. यह महत्वपूर्ण है कि आंतरिक संपीड़न मुख्य कारणों में से एक है जो लोग उपयोग करने के लिए चुनते हैं .nc 4 और 4 .hdf 5.
     
##### Decompressed कैश{#decompressed-cache} 
 ERDDAP™ किसी भी संकुचित द्विआधारी का विघटन संस्करण बनाता है (उदाहरण के लिए .nc ) जब फ़ाइल को पढ़ने की आवश्यकता होती है तो डेटा फ़ाइल। डिकंप्रेस्ड फ़ाइलों को डेटासेट की निर्देशिका में भीतर रखा जाता है *बड़ाParentDirectory* / decompressed /। हाल ही में इस्तेमाल नहीं किया गया है जो डिकंप्रेस्ड फ़ाइलों को अंतरिक्ष को मुक्त करने के लिए हटा दिया जाएगा जब संचयी फ़ाइल का आकार&gt;10GB होता है। आप इसे बदल सकते हैं&lt;DecompressedCacheMaxGB&gt; (डिफ़ॉल्ट=10) डेटासेट Xml.xml, उदाहरण के लिए,
```
        <decompressedCacheMaxGB>40</decompressedCacheMaxGB>  
```
इसके अलावा, पिछली 15 मिनट में इस्तेमाल की जाने वाली डिकंप्रेस्ड फ़ाइलों को प्रत्येक प्रमुख डेटासेट रीलोड के प्रारंभ में हटा दिया जाएगा। आप इसे बदल सकते हैं&lt;DecompressedCacheMaxMinutesपुराना&gt; (डिफ़ॉल्ट=15) डेटासेट Xml.xml, उदाहरण के लिए,
```
        <decompressedCacheMaxMinutesOld>60</decompressedCacheMaxMinutesOld>  
```
बड़ी संख्या अच्छी है, लेकिन डीकंप्रेस्ड फ़ाइलों का संचयी आकार का कारण बन सकता है *बड़ाParentDirectory* डिस्क स्पेस से बाहर निकलने के लिए, जो गंभीर समस्याओं का कारण बनता है।
     
* क्योंकि एक फ़ाइल को डीकंप्रेस करना समय की एक महत्वपूर्ण राशि ले सकता है (0.1 से 10 सेकंड) , संपीड़ित फ़ाइलों के साथ डेटासेट डेटासेट को डेटासेट सेट करने से लाभ हो सकता है [&lt;nThreads&gt; (#nthread) एक उच्च संख्या के लिए सेटिंग (2? 3? 4?) । यहां तक कि उच्च संख्या के लिए डाउनसाइड (उदाहरण के लिए, 5? 6? 7?) रिटर्न को कम कर रहे हैं और एक उपयोगकर्ता का अनुरोध तब प्रणाली के संसाधनों के उच्च प्रतिशत का उपयोग कर सकता है, इस प्रकार अन्य उपयोगकर्ता के अनुरोधों के प्रसंस्करण को काफी धीमा कर देता है। इस प्रकार, कोई आदर्श nThread सेटिंग नहीं है, विभिन्न सेटिंग्स के साथ अलग-अलग स्थितियों में सिर्फ अलग-अलग परिणाम हैं।
         
#### क्रमबद्ध आयाम मान{#sorted-dimension-values} 
प्रत्येक आयाम के लिए मान को क्रमबद्ध क्रम में होना चाहिए (पहली बार छोड़कर, आरोही या वंशज (सबसे ज्यादा) आयाम जो आरोही होना चाहिए) । मूल्यों को अनियमित रूप से स्पेस किया जा सकता है। कोई संबंध नहीं हो सकता। यह आवश्यकता है [CF मेटाडाटा मानक](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) । यदि किसी भी आयाम के मान क्रमबद्ध क्रम में नहीं हैं, तो डेटासेट को लोड नहीं किया जाएगा और लोड नहीं किया जाएगा। ERDDAP™ लॉग फाइल में प्रथम अनॉर्टेड मान की पहचान करेगा, *बड़ाParentDirectory* /logs/log.txt।
    
Unsorted आयाम मान लगभग हमेशा स्रोत डेटासेट के साथ एक समस्या का संकेत देते हैं। यह आमतौर पर तब होता है जब एकत्रीकरण में एक गलतनाम या अनुचित फ़ाइल शामिल की जाती है, जिससे एक अनधिकृत समय आयाम होता है। इस समस्या को हल करने के लिए त्रुटि संदेश देखें ERDDAP™ लॉग.txt फ़ाइल को ऑफेंडिंग टाइम वैल्यू खोजने के लिए। फिर संबंधित फ़ाइल खोजने के लिए स्रोत फ़ाइलों को देखें (पहले या एक के बाद) यह एकत्रीकरण में नहीं है।
    
#### निदेशक{#directories} 
MAY फ़ाइलों को एक निर्देशिका में, या एक निर्देशिका में और उसके उपनिर्देशन (लगातार) । यदि फ़ाइलों की एक बड़ी संख्या है (उदाहरण के लिए, &gt; 1,000) ऑपरेटिंग सिस्टम (इस प्रकार EDDGrid सेफिल) यदि आप फ़ाइलों को उपनिर्देशों की एक श्रृंखला में स्टोर करते हैं तो अधिक कुशलतापूर्वक काम करेंगे (प्रति वर्ष, या बहुत लगातार फ़ाइलों के साथ डेटासेट के लिए प्रति माह एक) इसलिए, किसी दिए गए निर्देशिका में फ़ाइलों की एक बड़ी संख्या कभी नहीं होती है।
     
#### &lt;कैशFromUrl&gt;{#cachefromurl} 
सब EDDGrid FromFiles and all EDDTableFromFiles डाटासेट एक सेट का समर्थन करते हैं जो बताते हैं ERDDAP™ सभी दूरस्थ डेटासेट फ़ाइलों की एक प्रति डाउनलोड करने और बनाए रखने के लिए, या कुछ फ़ाइलों का कैश (आवश्यकतानुसार डाउनलोड करें) । यह अविश्वसनीय रूप से उपयोगी हो सकता है देखें [कैश FromUrl प्रलेखन](#cachefromurl) ।
    
#### रिमोट डायरेक्टरीज़ और रेंज अनुरोध{#remote-directories-and-http-range-requests} 
 (AKA बाइट सर्विंग, बाइट रेंज अनुरोध, स्वीकार्य-रेंज http हेडर)   
 EDDGrid से NcFiles, EDDTableFromMultidimNcFiles, EDDTableFromNcFiles, और EDDTableFromNcCFFiles, कर सकते हैं *कभी कभी* से डेटा की सेवा .nc दूरस्थ सर्वर पर फाइलें और HTTP के माध्यम से एक्सेस अगर सर्वर समर्थन करता है [Byte](https://en.wikipedia.org/wiki/Byte_serving) HTTP रेंज अनुरोध के माध्यम से (सेवा करने के लिए HTTP तंत्र) । यह संभव है क्योंकि netcdf-java (जो ERDDAP™ पढ़ने के लिए उपयोग .nc फ़ाइलें) दूरस्थ से डेटा पढ़ने का समर्थन करता है .nc HTTP रेंज अनुरोधों के माध्यम से फ़ाइलें।

 **ऐसा मत करो&#33;** यह घातक और धीमी गति से है।
इसके बजाय, [] का उपयोग करें&lt;कैशFromUrl&gt; प्रणाली (#cachefromurl) ।

प्रवेश ERDDAP™ बाइट रेंज अनुरोधों के माध्यम से फ़ाइलों के रूप में डेटासेट --
इसे छोड़कर सामग्री पर बढ़ने के लिए (सिद्धांत) में डेटासेट के बारे में सोचना ERDDAP™ एक विशाल .nc "आवेदन" द्वारा फ़ाइल .nc "बेस ओपेन" DAP किसी दिए गए डेटासेट के लिए यूआरएल (उदाहरण के लिएhttps://myserver.org/erddap/griddap/datasetID.ncऔर इसके बाद एक सबसेट निर्दिष्ट करने के बाद एक क्वेरी जोड़कर) , शायद यह पूछने के लिए कि क्या आप netcdf-java का उपयोग कर सकते हैं, Ferret अन्य NetCDF क्लाइंट सॉफ्टवेयर के माध्यम से डेटा पढ़ने के लिए HTTP रेंज अनुरोध से ERDDAP । उत्तर नहीं है क्योंकि वास्तव में एक विशाल नहीं है " .nc "फ़ाइल"। यदि आप ऐसा करना चाहते हैं, तो इन विकल्पों में से एक करें:

* उपयोग(OPeN)DAPग्राहक सॉफ्टवेयर द्वारा दी गई ग्रिडडैप सेवाओं से कनेक्ट करने के लिए ERDDAP । यह क्या है DAP   (इस प्रकार ERDDAP ) इसके लिए डिज़ाइन किया गया था। यह बहुत कुशल है।
* या, स्रोत फ़ाइल डाउनलोड करें (s) से "files" प्रणाली (या एक सबसेट फ़ाइल के माध्यम से .nc ? क्वेरी) अपने कंप्यूटर के लिए और netcdf-java का उपयोग करें, Ferret अन्य NetCDF ग्राहक सॉफ्टवेयर पढ़ने के लिए (अब) स्थानीय फाइल (s) ।
         
#### कैश्ड फाइल जानकारी{#cached-file-information} 
जब EDDGrid FromFiles dataset पहले लोड हो रहा है, EDDGrid FromFiles प्रासंगिक फ़ाइलों के सभी से जानकारी पढ़ता है और टेबल बनाता है (प्रत्येक फ़ाइल के लिए एक पंक्ति) प्रत्येक वैध फ़ाइल और प्रत्येक "बाद" के बारे में जानकारी के साथ (अलग या अमान्य) फ़ाइल
* टेबल को डिस्क पर भी संग्रहीत किया जाता है, जैसा कि NetCDF v3 .nc फ़ाइलों में *बड़ाParentDirectory* /dataset/ *Last2CharsOfDatasetID* / * datasetID * / फ़ाइलों में नामित:
dirTable .nc   (जो अद्वितीय निर्देशिका नामों की सूची रखता है) ,
फ़ाइल टेबल .nc   (जो प्रत्येक वैध फ़ाइल की जानकारी के साथ तालिका रखता है) ,
बुराफिल .nc   (जो प्रत्येक बुरी फ़ाइल की जानकारी के साथ तालिका रखता है) ।
* पहुँच को गति देने के लिए EDDGrid डेटासेट (लेकिन अधिक स्मृति का उपयोग करने के खर्च पर) , आप उपयोग कर सकते हैं [&lt;फ़ाइलTableInMemory&gt;true&lt;/fileTableInMemory&gt; (#फ़ाइलटेबलइंमेमोरी) बताने के लिए ERDDAP™ मेमोरी में फ़ाइल सूचना तालिका की एक प्रति रखने के लिए।
* डिस्क पर फ़ाइल सूचना तालिका की प्रतिलिपि तब भी उपयोगी होती है जब ERDDAP™ बंद हो गया है और फिर से शुरू किया गया है: यह बचाता है EDDGrid FromFiles से डेटा फ़ाइलों के सभी को फिर से पढ़ने के लिए।
* जब डेटासेट को पुनः लोड किया जाता है, ERDDAP™ केवल नए फाइलों और फ़ाइलों में डेटा पढ़ने की जरूरत है जो बदल गए हैं।
* यदि किसी फ़ाइल में अन्य फ़ाइलों से एक अलग संरचना है (उदाहरण के लिए, चर में से एक के लिए एक अलग डेटा प्रकार, या "के लिए एक अलग मान [यूनिट](#units) विशेषता) , ERDDAP फ़ाइल को "bad" फ़ाइलों की सूची में जोड़ता है। फ़ाइल के साथ समस्या के बारे में जानकारी को लिखा जाएगा *बड़ाParentDirectory* /logs/log.txt फ़ाइल।
* आपको कभी भी इन फ़ाइलों के साथ हटाने या काम करने की आवश्यकता नहीं है। एक अपवाद है: यदि आप अभी भी डेटासेट में बदलाव कर रहे हैं datasets.xml सेटअप, आप इन फ़ाइलों को बल देने के लिए चाहते हैं ERDDAP™ सभी फ़ाइलों को फिर से पढ़ने के लिए क्योंकि फ़ाइलों को अलग-अलग ढंग से पढ़ा / व्याख्या किया जाएगा। यदि आपको कभी इन फ़ाइलों को हटाने की आवश्यकता है, तो आप ऐसा कर सकते हैं जब ERDDAP™ चल रहा है। (फिर सेट [झंडा](/docs/server-admin/additional-information#set-dataset-flag) डेटासेट ASAP को फिर से लोड करने के लिए।) हालांकि, ERDDAP™ आमतौर पर नोटिस करता है कि datasets.xml जानकारी फाइल से मेल नहीं खाती टेबल की जानकारी और स्वचालित रूप से फ़ाइल टेबल को हटा देता है।
* यदि आप प्रोत्साहित करना चाहते हैं ERDDAP™ संग्रहीत डेटासेट जानकारी अद्यतन करने के लिए (उदाहरण के लिए, यदि आपने अभी जोड़ा है, तो कुछ फ़ाइलों को डेटासेट के डेटा डाइरेक्टरी में बदल दिया है या बदल दिया है।) , उपयोग करें [ध्वज प्रणाली](/docs/server-admin/additional-information#flag) मजबूर होना ERDDAP™ कैश्ड फ़ाइल जानकारी अपडेट करने के लिए।
         
#### हैंडलिंग अनुरोध{#handling-requests} 
जब डेटा के लिए ग्राहक का अनुरोध संसाधित किया जाता है, EDDGrid FromFiles जल्दी से तालिका में वैध फ़ाइल जानकारी के साथ देख सकते हैं कि किस फाइल का अनुरोध डेटा है।
     
#### कैश्ड फाइल जानकारी को अद्यतन करना{#updating-the-cached-file-information} 
जब भी डेटासेट को पुनः लोड किया जाता है, तो कैश्ड फ़ाइल जानकारी अपडेट की जाती है।
    
* डेटासेट को समय-समय पर रीलोड किया जाता है जैसा कि द्वारा निर्धारित किया जाता है&lt;ReloadEveryNMinutes&gt; डेटासेट की जानकारी में datasets.xml ।
* जब भी संभव हो डेटासेट को पुनः लोड किया जाता है ERDDAP™ पता लगाता है कि आपने जोड़ा है, हटा दिया है, [स्पर्श](https://en.wikipedia.org/wiki/Touch_(Unix) ) (फ़ाइल के अंतिम परिवर्तन के लिए संशोधित समय) , या एक डेटाफ़ाइल बदल दिया।
* यदि आप उपयोग करते हैं तो डेटासेट को जल्द से जल्द लोड किया जाता है [ध्वज प्रणाली](/docs/server-admin/additional-information#flag) ।

जब डेटासेट को पुनः लोड किया जाता है, ERDDAP™ वर्तमान में उपलब्ध फ़ाइलों की तुलना कैश्ड फ़ाइल सूचना तालिका में की जाती है। नई फ़ाइलों को वैध फ़ाइलों की तालिका में पढ़ा और जोड़ा जाता है। उन फ़ाइलों को जो अब मौजूद नहीं हैं वे वैध फ़ाइलों की तालिका से हटा दिए गए हैं। जहां फ़ाइल टाइमस्टैम्प बदल गया है, वहां फ़ाइल को पढ़ा जाता है और उनकी जानकारी अपडेट की जाती है। नई तालिकाएं स्मृति में और डिस्क पर पुराने तालिकाओं को प्रतिस्थापित करती हैं।
     
#### बुरा फ़ाइलें{#bad-files} 
खराब फ़ाइलों की तालिका और कारणों से फ़ाइलों को खराब घोषित किया गया था (भ्रष्ट फ़ाइल, लापता चर आदि।) ईमेल करने के लिए ईमेल किया जाता है सब कुछ ईमेल पता (शायद आप) हर बार डेटासेट को पुनः लोड किया जाता है। आपको जितनी जल्दी हो सके इन फ़ाइलों को प्रतिस्थापित या मरम्मत करनी चाहिए।
     
#### लापता चर{#missing-variables} 
यदि कुछ फ़ाइलों में कुछ नहीं है तो कुछ फ़ाइलों में से कुछ नहीं है। dataVariable डेटासेट में परिभाषित datasets.xml वह ठीक है। कब EDDGrid FromFiles उन फ़ाइलों में से एक पढ़ता है, यह कार्य करेगा जैसे कि फ़ाइल में चर था, लेकिन सभी लापता मूल्यों के साथ।
     
#### FTP Trouble/Advice{#ftp-troubleadvice} 
यदि आप FTP नई डेटा फ़ाइलों को करने के लिए ERDDAP™ सर्वर जबकि ERDDAP™ चल रहा है, यह मौका है कि ERDDAP™ FTP प्रक्रिया के दौरान डेटासेट को फिर से लोड किया जाएगा। अक्सर ऐसा होता है जितना आप सोच सकते हैं&#33; यदि ऐसा होता है तो फ़ाइल मान्य होगी। (यह एक वैध नाम है) लेकिन फ़ाइल अभी तक मान्य नहीं है। अगर ERDDAP™ उस अमान्य फ़ाइल से डेटा पढ़ने की कोशिश करता है, जिसके परिणामस्वरूप त्रुटि फ़ाइल को अमान्य फ़ाइलों की तालिका में जोड़ा जाएगा। यह अच्छा नहीं है। इस समस्या से बचने के लिए, एक अस्थायी फ़ाइल नाम का उपयोग करें जब FTP फ़ाइल है, उदाहरण के लिए, ABC2005 .nc \\_TEMP। फिर, फ़ाइलNameRegex परीक्षण (नीचे देखें) यह संकेत देगा कि यह एक प्रासंगिक फ़ाइल नहीं है। FTP प्रक्रिया पूरी होने के बाद, फ़ाइल को सही नाम में बदलें। नामकरण प्रक्रिया फ़ाइल को तत्काल में प्रासंगिक होने का कारण बनाती है।
     
#### "0 फाइलें" त्रुटि संदेश{#0-files-error-message-1} 
यदि आप दौड़ते हैं [जनरेट DatasetXml](#generatedatasetsxml) या [दास](#dasdds) , या यदि आप लोड करने की कोशिश करते हैं EDDGrid से...फ़िल्स डेटासेट में ERDDAP™ , और आपको "0 फाइलें" त्रुटि संदेश मिलता है जो दर्शाता है कि ERDDAP™ निर्देशिका में 0 मिलान फ़ाइलों को पाया (जब आपको लगता है कि उस निर्देशिका में फ़ाइलों को मिलान करना है) :
    * जाँच करें कि वास्तव में फ़ाइलें उस निर्देशिका में हैं।
    * निर्देशिका नाम की वर्तनी की जाँच करें।
    * फ़ाइल NameRegex की जाँच करें। वास्तव में, वास्तव में regexes के साथ गलतियों को करना आसान है। परीक्षण प्रयोजनों के लिए, रेगेक्स की कोशिश करें। (इसे देखें [रेगेक्स प्रलेखन](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html) और [Regex ट्यूटोरियल](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html) ।) 
    * जांचें कि वह उपयोगकर्ता जो प्रोग्राम चला रहा है (उदाहरण के लिए, उपयोगकर्ता=tomcat (?) टॉमकैट के लिए ERDDAP ) उन फ़ाइलों के लिए 'रीड' अनुमति है।
    * कुछ ऑपरेटिंग सिस्टम में (उदाहरण के लिए, SELinux) और सिस्टम सेटिंग्स के आधार पर, जो उपयोगकर्ता ने कार्यक्रम को चलाने के लिए फ़ाइलों की निर्देशिका के लिए अग्रणी डायरेक्टरी की पूरी श्रृंखला के लिए 'रीड' अनुमति होनी चाहिए।
         
####  EDDGrid सेफिले कंकाल एक्सएमएल{#eddgridfromfiles-skeleton-xml} 
*    **कंकाल XML** सभी के लिए EDDGrid fromFiles subclasses is:

>&nbsp;&nbsp;&lt;dataset type="EDDGridFrom...Files" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaWMS>](#accessibleviawms)...&lt;/accessibleViaWMS> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;updateEveryNMillis>](#updateeverynmillis)...&lt;/updateEveryNMillis> &lt;!-- 0 or 1. For  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDDGridFromFiles subclasses, this uses Java's WatchDirectory system   
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to notice new/deleted/changed files quickly and efficiently. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;matchAxisNDigits>](#matchaxisndigits)...&lt;/matchAxisNDigits> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;nThreads>](#nthreads)...&lt;/nThreads> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dimensionValuesInMemory>](#dimensionvaluesinmemory)...&lt;/dimensionValuesInMemory> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;fileDir>...&lt;/fileDir> &lt;-- The directory (absolute) with the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data files. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;recursive>true|false&lt;/recursive> &lt;!-- 0 or 1. Indicates if  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subdirectories of fileDir have data files, too. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;pathRegex>](#pathregex)...&lt;/pathRegex>  &lt;!-- 0 or 1. Only directory names which  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match the pathRegex (default=".\\*") will be accepted. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;fileNameRegex>...&lt;/fileNameRegex> &lt;-- 0 or 1. A  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[regular expression](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html) ([tutorial](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html)) describing valid data  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file names, for example, ".\\*\\.nc" for all .nc files. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaFiles>](#accessibleviafiles)true|false(default)&lt;/accessibleViaFiles>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;metadataFrom>...&lt;/metadataFrom> &lt;-- The file to get  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metadata from ("first" or "last" (the default) based on file's  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastModifiedTime). -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fileTableInMemory>](#filetableinmemory)...&lt;/fileTableInMemory> &lt;!-- 0 or 1 (true or  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false (the default)) -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;cacheFromUrl>](#cachefromurl)...&lt;/cacheFromUrl> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;cacheSizeGB>](#cachefromurl)...&lt;/cacheSizeGB> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addAttributes>](#global-attributes)...&lt;/addAttributes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;axisVariable>](#axisvariable)...&lt;/axisVariable> &lt;!-- 1 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dataVariable>](#datavariable)...&lt;/dataVariable> &lt;!-- 1 or more -->  
>&nbsp;&nbsp;&lt;/dataset>  

### EDD*FromAudioFiles{#eddfromaudiofiles} 
 ** EDDGrid AudioFiles** और **EDDTableFromAudioFiles** स्थानीय ऑडियो फ़ाइलों के संग्रह से कुल डेटा। (पहले दिखाई दिया ERDDAP™ v1.82.) अंतर यह है कि EDDGrid FromAudioFiles डेटा को बहुआयामी डेटासेट के रूप में मानता है (आमतौर पर 2 आयामों के साथ: \\[ फ़ाइल शुरू समय \\] और \\[ Elapsed एक फ़ाइल के भीतर समय \\] ) जबकि EDDTableFromAudioFiles डेटा को सारणीबद्ध डेटा के रूप में व्यवहार करता है (आमतौर पर फ़ाइल startTime के लिए कॉलम के साथ, फ़ाइल के साथ elapsedTime, और ऑडियो चैनलों से डेटा) । EDDGrid FromAudioFiles की आवश्यकता है कि सभी फ़ाइलों में समान संख्या के नमूने हैं, इसलिए यदि यह सच नहीं है, तो आपको EDDTableFromAudioFiles का उपयोग करना होगा। अन्यथा, जिनका विकल्प EDD प्रकार का उपयोग करना पूरी तरह से आपकी पसंद है। EDDTableFromAudioFiles: आप अन्य जानकारी के साथ अन्य चर जोड़ सकते हैं, उदाहरण के लिए, stationID स्टेशन प्रकार दोनों मामलों में, एक एकीकृत समय चर की कमी इन EDD प्रकारों से डेटा के साथ काम करना मुश्किल बनाती है, लेकिन एक एकीकृत समय चर को स्थापित करने का कोई अच्छा तरीका नहीं था।

इन क्लास के सुपरक्लास देखें, [ EDDGrid सेफिल](#eddgridfromfiles) और [EDDTableFromFiles](#eddtablefromfiles) सामान्य जानकारी के लिए, यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है।

हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। चूंकि ऑडियो फ़ाइलों में ध्वनि डेटा के एन्कोडिंग से संबंधित जानकारी के अलावा कोई मेटाडाटा नहीं है, इसलिए आपको जेनरेटडाटासेट से आउटपुट संपादित करना होगा आवश्यक जानकारी प्रदान करने के लिए XML (उदाहरण के लिए, शीर्षक, सारांश, creator\\_name संस्था, इतिहास) ।

विवरण:

* बड़ी संख्या में ऑडियो फ़ाइल प्रारूप हैं। वर्तमान में, ERDDAP™ अधिकांश .wav और .au फ़ाइलों से डेटा पढ़ सकते हैं। यह वर्तमान में अन्य प्रकार की ऑडियो फ़ाइलों को नहीं पढ़ सकता है, उदाहरण के लिए, Aiff या .mp3। यदि आपको अन्य ऑडियो फ़ाइल प्रारूपों या .wav और .au के अन्य संस्करण के लिए समर्थन की आवश्यकता है, तो कृपया अपने अनुरोध को क्रिस पर ईमेल करें। जॉन at noaa.gov. या, एक वर्कराउंड के रूप में आप अभी उपयोग कर सकते हैं, आप अपने ऑडियो फ़ाइलों को PCM \\________________________________________________________________________________________________________________________________________________________________________________________________________________________________________ हस्ताक्षर (पूर्णांक डेटा के लिए) PCM (फ्लोटिंग पॉइंट डेटा के लिए) .wav फ़ाइलें ताकि ERDDAP™ उनके साथ काम कर सकते हैं।
* वर्तमान में, ERDDAP™ क्या के साथ ऑडियो फ़ाइलों को पढ़ सकते हैं Java 's AudioFormat class call PCM \\_FLOAT, PCM \\_SIGNED, PCM \\_UNSIGNED, ALAW, and ULAW encoding. ERDDAP™ पीसीएम \\_UNSIGNED मान परिवर्तित (उदाहरण के लिए, 0 से 255) हस्ताक्षरित मूल्यों में (उदाहरण के लिए -128 to 128) डेटा मूल्यों में बिट्स को पीछे छोड़ कर। ERDDAP™ ALAW और ULAW को उनके मूल एनकोडेड बाइट प्रारूप से शॉर्ट में एन्कोड किया गया (int16) मान चूंकि Java BigEndian=true डेटा चाहता है, ERDDAP™ BigEndian=false के साथ संग्रहीत डेटा के बाइट्स को पुनर्व्यवस्थित करें (थोड़ा एंडियन) मूल्यों को सही ढंग से पढ़ने के लिए। अन्य सभी एन्कोडिंग के लिए (पीसीएम) , ERDDAP™ जैसे डेटा पढ़ता है।
* कब ERDDAP™ ऑडियो फ़ाइलों से डेटा पढ़ता है, यह फ़ाइल के उपलब्ध ऑडियो मेटाडाटा को वैश्विक विशेषताओं में परिवर्तित करता है। यह हमेशा शामिल होगा (नमूना मूल्यों के साथ दिखाया गया) 
    
स्ट्रिंग ऑडियोबिंदी "false"; // झूठी या झूठी
int ऑडियो चैनल 1;
स्ट्रिंग ऑडियोएनकोडिंग "PCM \\_SIGNED";
फ्लोट ऑडियोFrameRate 96000.0; / प्रति सेकंड
Int AudioFrameSize 2; //# प्रति फ्रेम डेटा बाइट्स
फ्लोट ऑडियोSampleRate 96000.0; / प्रति सेकंड
Int AudioSampleSizeInBits 16; //# बिट्स प्रति चैनल प्रति नमूना
    
के लिए ERDDAP 'के प्रयोजनों, एक फ्रेम एक नमूना है, जो समय में एक बिंदु के लिए डेटा है के साथ समानार्थी है।
विशेषता ERDDAP™ डेटा का वर्णन करने वाली जानकारी होगी क्योंकि यह स्रोत फ़ाइलों में थी। ERDDAP™ अक्सर डेटा पढ़ने के दौरान इसे बदल दिया जाएगा, उदाहरण के लिए, पीसीएम \\_UNSIGNED, ALAW, और ULAW एन्कोडेड डेटा को पीसीएम \\_SIGNED में परिवर्तित कर दिया जाता है, और bigEndian=false डेटा को bigEndian=true डेटा में परिवर्तित किया जाता है। (क्या है Java इसे पढ़ना चाहता है) । अंत में, डेटा मान में ERDDAP™ हमेशा होगा [PCM-encoded](https://en.wikipedia.org/wiki/Pulse-code_modulation) डेटा मान (अर्थात्, ध्वनि तरंग के सरल अंकीय नमूने) ।
* कब ERDDAP™ ऑडियो फ़ाइलों से डेटा पढ़ता है, यह पूरी फ़ाइल पढ़ता है। ERDDAP™ प्रति चैनल लगभग 2 बिलियन नमूने पढ़ सकते हैं। उदाहरण के लिए, यदि नमूना दर 44,100 नमूने प्रति सेकंड है, तो 2 अरब नमूने प्रति फ़ाइल लगभग 756 मिनट ध्वनि डेटा का अनुवाद करते हैं। यदि आपके पास इस डेटा की राशि से अधिक ऑडियो फाइलें हैं, तो आपको फ़ाइलों को छोटे टुकड़ों में तोड़ने की जरूरत है ताकि फ़ाइलों को छोटे टुकड़ों में तोड़ दिया जा सके। ERDDAP™ उन्हें पढ़ सकते हैं।
* क्योंकि ERDDAP™ पूरे ऑडियो फ़ाइलों को पढ़ता है, ERDDAP™ बड़े ऑडियो फ़ाइलों के साथ काम करने के लिए स्मृति की एक बड़ी राशि तक पहुंच होना चाहिए। देखें [ ERDDAP मेमोरी सेटिंग्स](/docs/server-admin/deploy-install#memory) । फिर, यदि यह एक समस्या है, तो एक वर्कअराउंड जिसे आप अभी उपयोग कर सकते हैं, फाइलों को छोटे टुकड़ों में तोड़ना है ताकि फ़ाइलों को छोटे टुकड़ों में तोड़ दिया जा सके। ERDDAP™ उन्हें कम स्मृति के साथ पढ़ सकते हैं।
* कुछ ऑडियो फ़ाइलों को गलत तरीके से लिखा गया था। ERDDAP™ ऐसे मामलों से निपटने के लिए एक छोटा सा प्रयास करना। लेकिन सामान्य तौर पर, जब कोई त्रुटि होती है, ERDDAP™ एक अपवाद फेंकना होगा (और उस फ़ाइल को अस्वीकार) या (यदि त्रुटि अनिश्चित है) डेटा पढ़ें (लेकिन डेटा गलत हो जाएगा) ।
*    ERDDAP™ ध्वनि की मात्रा की जांच या परिवर्तन नहीं करता है। आदर्श रूप से, पूर्ण ऑडियो डेटा को डेटा प्रकार की पूरी श्रृंखला का उपयोग करने के लिए स्केल किया गया है।
* ऑडियो फ़ाइलों और ऑडियो खिलाड़ियों के पास लापता मूल्यों के लिए कोई प्रणाली नहीं है (उदाहरण के लिए, -999 या फ्लोट.NaN) । इसलिए ऑडियो डेटा में कोई लापता मान नहीं होना चाहिए। यदि कोई मूल्य लापता है (उदाहरण के लिए, यदि आपको ऑडियो फ़ाइल को लंबा करने की आवश्यकता है) , 0's की एक श्रृंखला का उपयोग करें जो सही मौन के रूप में व्याख्या की जाएगी।
* कब ERDDAP™ ऑडियो फ़ाइलों से डेटा पढ़ता है, यह हमेशा एक स्तंभ बनाता है जिसे छोड़ दिया जाता है प्रत्येक नमूना के लिए समय के साथ, सेकंड में (डबल के रूप में संग्रहीत) , पहले नमूने के सापेक्ष (जिसे सौंपा गया है elapsed समय=0.0 s) । साथ EDDGrid FromAudioFiles, यह elapsedTime अक्ष चर हो जाता है।
*    EDDGrid FromAudioFiles की आवश्यकता है कि सभी फ़ाइलों के नमूने समान हैं। तो अगर यह सच नहीं है, तो आपको EDDTableFromAudioFiles का उपयोग करना होगा।
* के लिए EDDGrid FromAudioFiles, हम अनुशंसा करते हैं कि आप सेट करें&lt;आयामValuesInMemory&gt; (#dimensionvaluesinmemory) झूठी (जैसा कि जेनरेटडाटासेट द्वारा अनुशंसित है एक्सएमएल) क्योंकि समय आयाम अक्सर मूल्यों की एक बड़ी संख्या है।
* के लिए EDDGrid FromAudioFiles, आपको लगभग हमेशा उपयोग करना चाहिए EDDGrid सेफाइल्स सिस्टम के लिए [द्वारा एकत्रीकरण फ़ाइल का नाम](#aggregation-via-file-names-or-global-metadata) , लगभग हमेशा रिकॉर्डिंग की शुरुआत की तारीख को निकालकर फ़ाइल नाम से समय। उदाहरण के लिए,
```
    <sourceName>\\*\\*\\*fileName,"timeFormat=yyyyMMdd'\\_'HHmmss",aco\\_acoustic\\.(\\[0-9\\]{8}\\_\\[0-9\\]{6})\\.wav,1</sourceName>
```
जनगणना एक्सएमएल इस को प्रोत्साहित करेगा और इससे आपकी मदद करेगा।
* EDDTableFromAudioFiles के लिए, आपको लगभग हमेशा EDDTableFromFiles प्रणाली का उपयोग करना चाहिए [\\*\\*\\* फ़ाइलनाम छद्म sourceName s](#filename-sourcenames) फ़ाइल के नाम से जानकारी निकालने के लिए (प्रारंभ तिथि रिकॉर्डिंग के लिए समय) और इसे डेटा का एक स्तंभ माना जाता है। उदाहरण के लिए,
```
    <sourceName>\\*\\*\\*fileName,aco\\_acoustic\\.(\\[0-9\\]{8}\\_\\[0-9\\]{6})\\.wav,1</sourceName>
```
इसके बाद समय प्रारूप को इकाइयों के रूप में निर्दिष्ट किया जाना चाहिए:&lt;Att name="units"&gt; YyMMdd'\\_'HHmms&lt;/att&gt;
     
###  EDDGrid FromMergeIRFiles{#eddgridfrommergeirfiles} 
 [ ** EDDGrid FromMergeIRFiles** ](#eddgridfrommergeirfiles) स्थानीय से डेटा एकत्र करना [मर्जी](https://www.cpc.ncep.noaa.gov/products/global_precip/html/README) फ़ाइलें, जो से हैं [उष्णकटिबंधीय वर्षा मापने मिशन (TRMM) ](https://trmm.gsfc.nasa.gov) , जो नासा और जापान एयरोस्पेस अन्वेषण एजेंसी के बीच एक संयुक्त मिशन है (जक्सा) । मर्ज IR फ़ाइलों से डाउनलोड किया जा सकता है [नासा](ftp://disc2.nascom.nasa.gov/data/s4pa/TRMM_ANCILLARY/MERG/) ।

 EDDGrid FromMergeIRFiles.java को लिखा गया और योगदान दिया गया था। ERDDAP™ प्रोजेक्ट बाय जोनाथन लाफाइट एंड फिलिप मकोव्स्की ऑफ आर.टेक इंजीनियरिंग (लाइसेंस: कॉपीराइट ओपन सोर्स) ।

 EDDGrid FromMergeIRFiles is a little:

*    EDDGrid सेMergeIRFiles संपीड़ित या uncompressed स्रोत डेटा फ़ाइलों का समर्थन करता है, किसी भी संयोजन में, एक ही डेटासेट में। यह आपको अनुमति देता है, उदाहरण के लिए, पुरानी फ़ाइलों को संपीड़ित करने के लिए जो शायद ही कभी एक्सेस किए जाते हैं, लेकिन उन नई फ़ाइलों को अनकंप्रेस करें जो अक्सर एक्सेस किए जाते हैं। या, आप मूल से संपीड़न के प्रकार को बदल सकते हैं। उदाहरण के लिए, .gz ।
* यदि आप एक ही निर्देशिका में उसी डेटा फ़ाइलों के संकुचित और असंपीड़ित संस्करण हैं, तो कृपया सुनिश्चित करें कि आप एक ही निर्देशिका में उसी डेटा फ़ाइलों के संकुचित और असंपीड़ित संस्करण हैं।&lt;अपने डेटासेट के लिए फ़ाइलNameRegex&gt; उस फ़ाइल नाम से मेल खाता है जिसे आप चाहते हैं कि वह मिलान करें और फ़ाइल नामों से मेल नहीं खाता है कि आप इसे मैच नहीं करना चाहते हैं।
* Uncompressed स्रोत डेटा फ़ाइलों में फ़ाइल एक्सटेंशन नहीं होना चाहिए (i.e., फ़ाइल नाम में कोई "." नहीं) ।
* संपीड़ित स्रोत डेटा फ़ाइलों में फ़ाइल एक्सटेंशन होना चाहिए, लेकिन ERDDAP™ फ़ाइल की सामग्री का निरीक्षण करके संपीड़न के प्रकार को निर्धारित करता है, न कि फ़ाइल के फ़ाइल एक्सटेंशन को देख (उदाहरण के लिए, ".Z") । समर्थित संपीड़न प्रकारों में "gz", "bzip2", "xz", "lzma", "snappy-raw", "snappy-framed", "pack200", और "z" शामिल हैं। कब ERDDAP™ संपीड़ित फ़ाइलों को पढ़ा जाता है, यह एक अस्थायी फ़ाइल को लिखने के बिना, ऑन-द-फ्लाई को रोकता है।
* सभी स्रोत डेटा फ़ाइलों को मूल फ़ाइल नामकरण प्रणाली का उपयोग करना चाहिए: यानी, merg \\_ *YYYMMDDH* 4km पिक्सेल (कहाँ *YYYMMDDH* फ़ाइल में डेटा से जुड़े समय को इंगित करता है) यदि फ़ाइल संकुचित हो जाती है, तो फ़ाइल एक्सटेंशन भी साथ ही।

इस वर्ग के सुपरक्लास को देखें, [ EDDGrid सेफिल](#eddgridfromfiles) सामान्य जानकारी के लिए, यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है।

हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं।
 
###  EDDGrid FromNcFiles{#eddgridfromncfiles} 
 [ ** EDDGrid FromNcFiles** ](#eddgridfromncfiles) स्थानीय, ग्रिड से डेटा एकत्र करना [GRIB .grb और .grb2](https://en.wikipedia.org/wiki/GRIB) फ़ाइलें, [ HDF   (v4 or v5)   .hdf ](https://www.hdfgroup.org/) फ़ाइलें, [ .nc एमएल](#ncml-files) फ़ाइलें, [ NetCDF   (v3)   .nc ](https://www.unidata.ucar.edu/software/netcdf/) फ़ाइलें, और [जैर](https://github.com/zarr-developers/zarr-python) फ़ाइलें (संस्करण 2.25) । Zarr फ़ाइलों में थोड़ा अलग व्यवहार होता है और या तो फ़ाइलNameRegex या pathRegex को "zarr" शामिल करने की आवश्यकता होती है।

में नया ERDDAP™ संस्करण 2.29.0 डेटा चर के लिए प्रयोगात्मक समर्थन है जो सभी अक्ष चरों का समर्थन नहीं करता है (या कुछ के रूप में यह एक ही डेटासेट में 1D और 2D डेटा कहा है) । कृपया GitHub पर पहुंचें (चर्चा या मुद्दे) प्रतिक्रिया और बग के साथ।

यह अन्य फ़ाइल प्रकारों के साथ काम कर सकता है (उदाहरण के लिए, BUFR) , हम सिर्फ यह परीक्षण नहीं किया है - कृपया हमें कुछ नमूना फ़ाइलों को भेजें।

* GRIB फ़ाइलों के लिए, ERDDAP™ एक .gbx सूचकांक फ़ाइल बनाने के लिए पहली बार यह प्रत्येक GRIB फ़ाइल पढ़ा होगा। इसलिए GRIB फ़ाइलों को एक निर्देशिका में होना चाहिए जहां "उपयोगकर्ता" जो टॉमकैट को चलाने के लिए + लिखने की अनुमति है।
* इस वर्ग के सुपरक्लास को देखें, [ EDDGrid सेफिल](#eddgridfromfiles) यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है, इस बारे में जानकारी के लिए।
* शुरू ERDDAP™ v2.12, EDDGrid FromNcFiles and fromNcFiles. EDDGrid FromNcFiles अनपैक्ड में "संरचना" से डेटा पढ़ सकते हैं .nc 4 और 4 .hdf 4 फाइलें। एक चर की पहचान करने के लिए जो एक संरचना से है,&lt; sourceName &gt; प्रारूप का उपयोग करना चाहिए: *पूर्ण संरचनानाम*  |  *सदस्यनाम* , उदाहरण के लिए समूह1/myStruct | मेरा सदस्य
* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं।
    
#### ग्रिडड एनसी फाइल्स में समूह{#groups-in-gridded-nc-files} 
     [Netcdf4 फ़ाइलों में समूह शामिल हो सकते हैं।](#groups-in-gridded-nc-files)   ERDDAP™ केवल एक समूह और उसके सभी मूल समूहों में चर से डेटासेट बनाता है। आप GenerateDatasets में एक विशिष्ट समूह का नाम निर्दिष्ट कर सकते हैं एक्सएमएल (ट्रेलिंग स्लैश को छोड़ दें) जेनरेटडाटासेट करने के लिए "" का उपयोग करें Xml उन चरों के लिए सभी समूहों की खोज करते हैं जो सबसे अधिक आयामों का उपयोग करते हैं, या " का उपयोग करते हैं \\[ जड़ \\] "GenDatasets सिर्फ जड़ समूह में चर के लिए देखने के लिए।
    
पहली चीज GenDatasetsXml इस प्रकार के डेटासेट के लिए करता है जब आप जवाब देते हैं तो सवाल नमूना फ़ाइल की एनसीडंप जैसी संरचना को प्रिंट करता है। तो अगर आप जनरेटडाटासेट के माध्यम से पहले पाश के लिए कुछ गौफी जवाब में प्रवेश करते हैं Xml, कम से कम आप देख सकते हैं कि क्या ERDDAP™ फ़ाइल को पढ़ सकते हैं और देख सकते हैं कि कौन से आयाम और चर फाइल में हैं। फिर आप जेनरेटडाटासेटएक्सएमएल के माध्यम से दूसरे लूप के लिए बेहतर जवाब दे सकते हैं।
    

###  EDDGrid से NcFilesUnpacked{#eddgridfromncfilesunpacked} 
 [ ** EDDGrid से NcFilesUnpacked** ](#eddgridfromncfilesunpacked) का एक प्रकार है [ EDDGrid FromNcFiles](#eddgridfromncfiles) जो स्थानीय, ग्रिड से डेटा एकत्र करता है NetCDF   (v3)   .nc और संबंधित फ़ाइलें। अंतर यह है कि यह वर्ग पहले प्रत्येक डेटा फ़ाइल को अनपैक करता है EDDGrid FromFiles फ़ाइलों को देखता है:

* यह उन चर को अनपैक करता है जो पैक किए जाते हैं [ scale\\_factor और/or add\\_offset ](#scale_factor) ।
* यह \\_FillValue परिवर्तित करता है और missing\\_value NAN का मान (Integer डेटा प्रकार के लिए या Max \\_VALUE) ।
* यह समय और समय-समय पर मूल्यों को परिवर्तित करता है "seconds since 1970-01-01T00:00:00Z" ।

इस वर्ग का बड़ा लाभ यह है कि यह विभिन्न मूल्यों के साथ सौदा करने का एक तरीका प्रदान करता है। scale\\_factor , add\\_offset , \\_FillValue, missing\\_value एक संग्रह में विभिन्न स्रोत फ़ाइलों में या समय इकाइयों। अन्यथा, आपको एक उपकरण का उपयोग करना होगा जैसे [एनसीएमएल](#ncml-files) या [ NCO ](#netcdf-operators-nco) प्रत्येक फ़ाइल को अंतर को हटाने के लिए संशोधित करने के लिए ताकि फ़ाइलों को नियंत्रित किया जा सके EDDGrid सेंकिअल इस वर्ग के लिए ठीक से काम करने के लिए, फ़ाइलों को संबंधित विशेषताओं के लिए CF मानकों का पालन करना चाहिए।

* यदि कोशिश करना EDDGrid FromNcFiles फ़ाइलों के एक समूह से अनपैक किया गया जिसके साथ आपने पहले कोशिश की और उपयोग करने में विफल रहा। EDDGrid से NcFiles, सीडी करने के लिए
     *बड़ाParentDirectory* /dataset/ *Last2Letters* / * datasetID * /
कहाँ *Last2Letters* अंतिम 2 अक्षर है datasetID ,
और उस निर्देशिका में सभी फ़ाइलों को हटा दें।
* शुरू ERDDAP™ v2.12, EDDGrid FromNcFiles and fromNcFiles. EDDGrid FromNcFiles अनपैक्ड में "संरचना" से डेटा पढ़ सकते हैं .nc 4 और 4 .hdf 4 फाइलें। एक चर की पहचान करने के लिए जो एक संरचना से है,&lt; sourceName &gt; प्रारूप का उपयोग करना चाहिए: *पूर्ण संरचनानाम*  |  *सदस्यनाम* , उदाहरण के लिए समूह1/myStruct | मेरा सदस्य
* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं।
    
Netcdf4 फ़ाइलों में समूह शामिल हो सकते हैं। देखें [यह दस्तावेज़ीकरण](#groups-in-gridded-nc-files) ।
    
पहली चीज GenDatasetsXml इस प्रकार के डेटासेट के लिए करता है जब आप जवाब देते हैं तो सवाल नमूना फ़ाइल की एनसीडंप जैसी संरचना को प्रिंट करता है। **पहले** यह unpacked है। तो अगर आप जनरेटडाटासेट के माध्यम से पहले पाश के लिए कुछ goofy जवाब में प्रवेश करते हैं Xml, कम से कम आप देख सकते हैं कि क्या ERDDAP™ फ़ाइल को पढ़ सकते हैं और देख सकते हैं कि कौन से आयाम और चर फाइल में हैं। फिर आप जेनरेटडाटासेटएक्सएमएल के माध्यम से दूसरे लूप के लिए बेहतर जवाब दे सकते हैं।
    
###  EDDGrid LonPM180{#eddgridlonpm180} 
 [ ** EDDGrid LonPM180** ](#eddgridlonpm180) एक बच्चे के अक्षांश मूल्यों को संशोधित करता है (संलग्न)   EDDGrid डेटासेट जिसमें 180 से अधिक से अधिक लम्बाई मान होते हैं (उदाहरण के लिए, 0 से 360) इतना है कि वे रेंज में हैं -180 से 180 (Longitude Plus or Minus 180, इसलिए इसका नाम) ।

* यह डेटासेट बनाने का एक तरीका प्रदान करता है जिसमें 180 से अधिक अनुरूप/साथ लंबे समय तक मूल्य होते हैं। OGC सेवाएं (उदाहरण के लिए WMS सर्वर ERDDAP ) सबके बाद OGC सेवाओं को 180 से 180 के भीतर लम्बाई मान की आवश्यकता होती है।
* असंतुष्टता के पास काम करने से समस्याएं होती हैं, चाहे वह असंतुष्टता 0 या 180 के अक्षांश पर हो। यह डेटासेट प्रकार आपको उसी डेटासेट के दो संस्करणों की पेशकश करके हर किसी के लिए उन समस्याओं से बचने देता है:
रेंज 0 से 360 में लम्बाई मान के साथ ("Pacificentric"?) ,
रेंज -180 से 180 ("Atlanticentric"?) ।
* 180 से अधिक सभी देशांतर मूल्यों के साथ चाइल्ड डेटासेट के लिए, सभी नए देशांतर मान केवल 360 डिग्री कम हैं। उदाहरण के लिए, 180 से 240 के अक्षांश मान के साथ एक डेटासेट -180 से -120 के अक्षांश मान के साथ डेटासेट बन जाएगा।
* बाल डेटासेट के लिए जो पूरे ग्लोब के लिए अक्षांश मान है (मोटे तौर पर 0 से 360) , नए देशांतर मूल्य को पुनर्निर्मित किया जाएगा (मोटे तौर पर) -180 से 180:
मूल 0 से लगभग 180 मान अपरिवर्तित हैं।
मूल 180 से 360 मानों को -180 से 0 में परिवर्तित किया जाता है और देशांतर सरणी की शुरुआत में स्थानांतरित किया जाता है।
* बच्चे के डेटासेट के लिए जो 180 स्पैन होते हैं लेकिन ग्लोब को कवर नहीं करते हैं, ERDDAP™ एक डेटासेट बनाने की आवश्यकता के रूप में लापता मान डालें जो दुनिया को कवर करता है। उदाहरण के लिए, 140 से 200 के अक्षांश मान के साथ एक बच्चा डेटासेट -180 से 180 के अक्षांश मान के साथ एक डेटासेट बन जाएगा।
180 से 200 के बच्चे का मूल्य -180 से -160 हो जाएगा।
नए देशांतर मूल्यों को -160 से 140 तक डाला जाएगा। संबंधित डेटा मान \\_FillValues होगा।
140 से लगभग 180 के बच्चे का मूल्य अपरिवर्तित होगा।
लापता मूल्यों का सम्मिलन अजीब लग सकता है, लेकिन यह कई समस्याओं से बच जाता है जिसके परिणामस्वरूप देशांतर मूल्यों को अचानक कूदना पड़ता है। (उदाहरण के लिए, -160 से 140) ।
* में [जनरेट DatasetXml](#generatedatasetsxml) , एक विशेष "डेटासेट प्रकार" है, EDDGrid LonPM180FromErddapCatalog, जो आपको उत्पन्न करने देता है datasets.xml के लिए EDDGrid प्रत्येक से LonPM180 डेटासेट EDDGrid एक में डेटासेट ERDDAP इसमें 180 से अधिक लम्बाई मान होते हैं। यह इन डेटासेट के दो संस्करणों की पेशकश की सुविधा देता है:
मूल, सीमा 0 से 360 में अक्षांश मान के साथ,
और नए डेटासेट, रेंज -180 से 180 में देशांतर मूल्यों के साथ।
    
प्रत्येक के भीतर बच्चा डेटासेट EDDGrid LonPM180 डेटासेट एक होगा EDDGrid FromErddap dataset जो मूल डेटासेट को इंगित करता है।
नया डेटासेट datasetID मूल डेटासेट प्लस "\\_LonPM180" का नाम होगा।
उदाहरण के लिए,
```
    <dataset type="EDDGridLonPM180" datasetID="erdMBsstdmday\\_LonPM180" active="true">
      <dataset type="EDDGridFromErddap" datasetID="erdMBsstdmday\\_LonPM180Child">
        <!-- SST, Aqua MODIS, NPP, 0.025 degrees, Pacific Ocean, Daytime 
          (Monthly Composite) minLon=120.0 maxLon=320.0 -->
        <sourceUrl>https://coastwatch.pfeg.noaa.gov/erddap/griddap/erdMBsstdmday
        </sourceUrl>
      </dataset>
    </dataset> 
```
रखना EDDGrid LonPM180 डेटासेट **नीचे** में मूल डेटासेट datasets.xml । यह कुछ संभावित समस्याओं से बचा है।
    
वैकल्पिक रूप से, आप बदल सकते हैं EDDGrid मूल डेटासेट के साथ Erddap बच्चे डेटासेट से datasets.xml । फिर, डेटासेट का केवल एक संस्करण होगा: एक -180 से 180 के भीतर देशांतर मूल्यों के साथ। जब डेटासेट का प्रत्येक संस्करण अधिक सुविधाजनक होता है तो हम इसे हतोत्साहित करते हैं।
    
* यदि आप एक डेटासेट के दो संस्करणों की पेशकश करते हैं, उदाहरण के लिए, एक अक्षांश 0 से 360 और एक के साथ देशांतर -180 से 180:
    * आप वैकल्पिक उपयोग कर सकते हैं [&lt;सुलभ वाया WMS &gt; झूठ&lt;स्वीकार्य वाया WMS &gt; (#accessibleviawms) 0-360 डेटासेट के साथ to forcibly निष्क्रिय WMS उस डेटासेट के लिए सेवा। फिर, केवल डेटासेट का LonPM180 संस्करण सुलभ होगा WMS ।
    * अंतर्निहित डेटासेट में परिवर्तन के साथ LonPM180 डेटासेट अप-टू-डेट रखने के कुछ तरीके हैं:
        * यदि बच्चा डेटासेट एक है EDDGrid FromErddap डेटासेट जो एक ही डेटासेट को संदर्भित करता है ERDDAP™ , LonPM180 डेटासेट सीधे अंतर्निहित डेटासेट की सदस्यता लेने की कोशिश करेगा ताकि यह हमेशा अद्यतन हो। प्रत्यक्ष सदस्यता ईमेल उत्पन्न नहीं करते हैं जो आपको सदस्यता को मान्य करने के लिए कहते हैं - सत्यापन स्वचालित रूप से किया जाना चाहिए।
        * यदि बच्चा डेटासेट नहीं है EDDGrid FromErddap dataset that is on the same. ERDDAP™ , LonPM180 डेटासेट अंतर्निहित डेटासेट की सदस्यता के लिए नियमित सदस्यता प्रणाली का उपयोग करने की कोशिश करेगा। यदि आपके पास आपकी सदस्यता प्रणाली है ERDDAP™ बदल गया, आपको ईमेल प्राप्त करना चाहिए जो आपको सदस्यता को मान्य करने के लिए कहता है। कृपया ऐसा करें।
        * यदि आपके पास आपकी सदस्यता प्रणाली है ERDDAP™ बंद कर दिया, LonPM180 डाटासेट कभी कभी मेटाडाटा outdated हो सकता है जब तक LonPM180 डाटासेट reloaded है। तो अगर सदस्यता प्रणाली बंद हो जाती है, तो आपको सेट करना चाहिए [&lt;रीलोड हरNMinutes (#reloadeverynminutes) एक छोटी संख्या में LonPM180 डेटासेट की सेटिंग, ताकि जल्द ही बच्चे के डेटासेट में बदलाव की संभावना बढ़ सके।

* अधिकतम अक्षांश&gt; 360 के साथ डेटासेट के लिए, अधिकतम मान निर्धारित करने के लिए निम्नलिखित वैकल्पिक विन्यास का उपयोग करें और डेटासेट -180 से 180 तक सही हो जाएगा।
```
    <maxSourceLon>540</maxSourceLon>
```

####  EDDGrid LonPM180 कंकाल एक्सएमएल{#eddgridlonpm180-skeleton-xml} 

>&nbsp;&nbsp;&lt;dataset type="EDDGridLonPM180" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;updateEveryNMillis>](#updateeverynmillis)...&lt;/updateEveryNMillis> &lt;!-- 0 or 1. For  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDDGridFromDap, this gets the remote .dds and then gets the new  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftmost (first) dimension values. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaWMS>](#accessibleviawms)...&lt;/accessibleViaWMS> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;nThreads>](#nthreads)...&lt;/nThreads> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dimensionValuesInMemory>](#dimensionvaluesinmemory)...&lt;/dimensionValuesInMemory> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dataset>...&lt;/dataset> &lt;!-- The child EDDGrid dataset. -->  
>&nbsp;&nbsp;&lt;/dataset>  

###  EDDGrid Lon0360{#eddgridlon0360} 
 [ ** EDDGrid Lon0360** ](#eddgridlon0360) एक बच्चे के अक्षांश मूल्यों को संशोधित करता है (संलग्न)   EDDGrid डेटासेट जिसमें कुछ हद तक मान 0 से कम है (उदाहरण के लिए -180 से 180) ताकि वे 0 से 360 रेंज में हों (इसलिए नाम) ।

* असंतुष्टता के पास काम करने से समस्याएं होती हैं, चाहे वह असंतुष्टता 0 या 180 के अक्षांश पर हो। यह डेटासेट प्रकार आपको उसी डेटासेट के दो संस्करणों की पेशकश करके हर किसी के लिए उन समस्याओं से बचने देता है:
रेंज -180 से 180 ("Atlanticentric"?) ।
रेंज 0 से 360 में लम्बाई मान के साथ ("Pacificentric"?) ,
* 0 से कम सभी देशांतर मूल्यों के साथ चाइल्ड डेटासेट के लिए, सभी नए देशांतर मान केवल 360 डिग्री अधिक हैं। उदाहरण के लिए, -180 से -120 के अक्षांश मान के साथ एक डेटासेट 180 से 240 के अक्षांश मान के साथ एक डेटासेट बन जाएगा।
* बाल डेटासेट के लिए जो पूरे ग्लोब के लिए अक्षांश मान है (मोटे तौर पर -180 से 180) , नए देशांतर मूल्य को पुनर्निर्मित किया जाएगा (मोटे तौर पर) 0 से 360:
मूल -180 से 0 मान 180 से 360 में परिवर्तित होते हैं और देशांतर सारणी के अंत में स्थानांतरित होते हैं।
मूल 0 से लगभग 180 मान अपरिवर्तित हैं।
* बच्चे के डेटासेट के लिए जो lon = 0 स्पैन करते हैं लेकिन ग्लोब को कवर नहीं करते हैं, ERDDAP™ एक डेटासेट बनाने की आवश्यकता के रूप में लापता मान डालें जो दुनिया को कवर करता है। उदाहरण के लिए, -40 से 20 के अक्षांश मान के साथ एक बच्चा डेटासेट 0 से 360 के अक्षांश मान के साथ एक डेटासेट बन जाएगा।
0 से 20 के बच्चे का मूल्य अपरिवर्तित होगा।
20 से 320 तक नए देशांतर मूल्यों को सम्मिलित किया जाएगा। संबंधित डेटा मान \\_FillValues होगा।
-40 से 0 के बच्चे का मूल्य 320 से 360 हो जाएगा।
लापता मूल्यों का सम्मिलन अजीब लग सकता है, लेकिन यह कई समस्याओं से बच जाता है जिसके परिणामस्वरूप देशांतर मूल्यों को अचानक कूदना पड़ता है। (उदाहरण के लिए, 20 से 320 तक) ।
* में [जनरेट DatasetXml](#generatedatasetsxml) , एक विशेष "डेटासेट प्रकार" है, EDDGrid Lon0360From ErddapCatalog, जो आपको उत्पन्न करने देता है datasets.xml के लिए EDDGrid प्रत्येक से Lon0360 डेटासेट EDDGrid एक में डेटासेट ERDDAP इसमें 180 से अधिक लम्बाई मान होते हैं। यह इन डेटासेट के दो संस्करणों की पेशकश की सुविधा देता है:
मूल, सीमा 0 से 360 में अक्षांश मान के साथ,
और नए डेटासेट, रेंज -180 से 180 में देशांतर मूल्यों के साथ।
    
प्रत्येक के भीतर बच्चा डेटासेट EDDGrid Lon0360 डेटासेट एक होगा EDDGrid FromErddap dataset जो मूल डेटासेट को इंगित करता है।
नया डेटासेट datasetID मूल डेटासेट प्लस "\\_Lon0360" का नाम होगा।
उदाहरण के लिए,
```
    <dataset type="EDDGridLon0360" datasetID="erdMBsstdmday\\_Lon0360" active="true">
      <dataset type="EDDGridFromErddap" datasetID="erdMBsstdmday\\_Lon0360Child">
        <!-- SST, Aqua MODIS, NPP, 0.025 degrees, Pacific Ocean, Daytime 
          (Monthly Composite) minLon=-40.0 maxLon=20.0 -->
        <sourceUrl>https://coastwatch.pfeg.noaa.gov/erddap/griddap/erdMBsstdmday
        </sourceUrl>
      </dataset>
    </dataset> 
```
रखना EDDGrid Lon0360 डेटासेट **नीचे** में मूल डेटासेट datasets.xml । यह कुछ संभावित समस्याओं से बचा है।
    
वैकल्पिक रूप से, आप बदल सकते हैं EDDGrid मूल डेटासेट के साथ Erddap बच्चे डेटासेट से datasets.xml । फिर, डेटासेट का केवल एक संस्करण होगा: 0 से 360 के भीतर देशांतर मूल्यों वाला एक। जब डेटासेट का प्रत्येक संस्करण अधिक सुविधाजनक होता है तो हम इसे हतोत्साहित करते हैं।
    
* यदि आप एक डेटासेट के दो संस्करणों की पेशकश करते हैं, उदाहरण के लिए, एक अक्षांश 0 से 360 और एक के साथ देशांतर -180 से 180:
    * आप वैकल्पिक उपयोग कर सकते हैं [&lt;सुलभ वाया WMS &gt; झूठ&lt;स्वीकार्य वाया WMS &gt; (#accessibleviawms) 0 से 360 डेटासेट के साथ to forcibly निष्क्रिय WMS उस डेटासेट के लिए सेवा। फिर, डेटासेट का केवल -180 से 180 संस्करण सुलभ होगा WMS ।
    * अंतर्निहित डेटासेट में परिवर्तन के साथ Lon0360 डेटासेट अप-टू-डेट रखने के कुछ तरीके हैं:
        * यदि बच्चा डेटासेट एक है EDDGrid FromErddap डेटासेट जो एक ही डेटासेट को संदर्भित करता है ERDDAP™ , Lon0360 डेटासेट सीधे अंतर्निहित डेटासेट की सदस्यता लेने की कोशिश करेगा ताकि यह हमेशा अद्यतन हो। प्रत्यक्ष सदस्यता ईमेल उत्पन्न नहीं करते हैं जो आपको सदस्यता को मान्य करने के लिए कहते हैं - सत्यापन स्वचालित रूप से किया जाना चाहिए।
        * यदि बच्चा डेटासेट नहीं है EDDGrid FromErddap dataset that is on the same. ERDDAP™ , Lon0360 डेटासेट अंतर्निहित डेटासेट की सदस्यता के लिए नियमित सदस्यता प्रणाली का उपयोग करने की कोशिश करेगा। यदि आपके पास आपकी सदस्यता प्रणाली है ERDDAP™ बदल गया, आपको ईमेल प्राप्त करना चाहिए जो आपको सदस्यता को मान्य करने के लिए कहता है। कृपया ऐसा करें।
        * यदि आपके पास आपकी सदस्यता प्रणाली है ERDDAP™ बंद कर दिया गया, Lon0360 डेटासेट कभी कभी मेटाडाटा outdated हो सकता है जब तक Lon0360 डाटासेट reloaded है। तो अगर सदस्यता प्रणाली बंद हो जाती है, तो आपको सेट करना चाहिए [&lt;रीलोड हरNMinutes (#reloadeverynminutes) Lon0360 डेटासेट की एक छोटी संख्या में सेटिंग, ताकि जल्द ही बच्चे के डेटासेट में बदलाव की संभावना बढ़ सके।
####  EDDGrid Lon0360 कंकाल एक्सएमएल{#eddgridlon0360-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDGridLon0360" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;updateEveryNMillis>](#updateeverynmillis)...&lt;/updateEveryNMillis> &lt;!-- 0 or 1. For  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDDGridFromDap, this gets the remote .dds and then gets the new  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leftmost (first) dimension values. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaWMS>](#accessibleviawms)...&lt;/accessibleViaWMS> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;nThreads>](#nthreads)...&lt;/nThreads> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dimensionValuesInMemory>](#dimensionvaluesinmemory)...&lt;/dimensionValuesInMemory> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dataset>...&lt;/dataset> &lt;!-- The child EDDGrid dataset. -->  
>&nbsp;&nbsp;&lt;/dataset>  

###  EDDGrid साइडबायसाइड{#eddgridsidebyside} 
 [ ** EDDGrid साइडबायसाइड** ](#eddgridsidebyside) दो या अधिक EDDGrid डेटासेट (बच्चे) पक्ष में।

* परिणामस्वरूप डेटासेट में सभी बच्चे डेटासेट से सभी चर हैं।
* माता-पिता डेटासेट और सभी बच्चे डेटासेट MUST अलग है datasetID S. यदि किसी परिवार में कोई नाम बिल्कुल समान है, तो डेटासेट लोड होने में विफल हो जाएगा (त्रुटि संदेश के साथ कि कुल अक्ष के मान क्रमबद्ध क्रम में नहीं हैं) ।
* सभी बच्चों के लिए MUST के समान स्रोत मान हैं axisVariable s \\[ 1+ \\]   (उदाहरण के लिए, अक्षांश, देशांतर) । परीक्षण की परिशुद्धता द्वारा निर्धारित की जाती है [मैच AxisNDigits](#matchaxisndigits) ।
* बच्चों के पास विभिन्न स्रोत मान हो सकते हैं axisVariable s \\[ 0 \\]   (उदाहरण के लिए, समय) लेकिन वे आम तौर पर काफी हद तक समान होते हैं।
* माता-पिता डेटासेट सभी के पास दिखाई देगा axisVariable s \\[ 0 \\] सभी बच्चों से स्रोत मान।
* उदाहरण के लिए, यह आपको वेक्टर के u-component और एक अन्य स्रोत डेटासेट के साथ एक स्रोत डेटासेट को एक वेक्टर के v-component के साथ जोड़ती है, इसलिए संयुक्त डेटा परोसा जा सकता है।
* इस विधि द्वारा निर्मित बच्चे निजी तौर पर आयोजित किए जाते हैं। वे अलग से सुलभ डेटासेट नहीं हैं (उदाहरण के लिए, ग्राहक डेटा अनुरोधों या द्वारा [झंडा फाइलें](/docs/server-admin/additional-information#flag) ) ।
* वैश्विक मेटाडाटा और माता-पिता के लिए सेटिंग्स वैश्विक मेटाडाटा और पहले बच्चे के लिए सेटिंग्स से आता है।
* यदि पहले बच्चे का निर्माण करते समय अपवाद होता है, तो माता-पिता का निर्माण नहीं किया जाएगा।
* यदि अन्य बच्चे पैदा करते समय अपवाद है, तो यह ईमेल करने के लिए एक ईमेल भेजता है (यथा निर्दिष्ट [साइटमैप](/docs/server-admin/deploy-install#setupxml) ) और अन्य बच्चों के साथ जारी रहता है।
####  EDDGrid साइडबायसाइड कंकाल एक्सएमएल{#eddgridsidebyside-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDGridSideBySide" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaWMS>](#accessibleviawms)...&lt;/accessibleViaWMS> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;matchAxisNDigits>](#matchaxisndigits)...&lt;/matchAxisNDigits> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;nThreads>](#nthreads)...&lt;/nThreads> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dimensionValuesInMemory>](#dimensionvaluesinmemory)...&lt;/dimensionValuesInMemory> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dataset>...&lt;/dataset> &lt;!-- 2 or more -->  
>&nbsp;&nbsp;&lt;/dataset>  

###  EDDGrid समग्र आयाम{#eddgridaggregateexistingdimension} 
 [ ** EDDGrid समग्र आयाम** ](#eddgridaggregateexistingdimension) दो या अधिक EDDGrid उनमें से प्रत्येक में पहले आयाम के लिए मूल्यों की एक अलग श्रृंखला है, लेकिन अन्य आयामों के लिए समान मान।

* उदाहरण के लिए, एक चाइल्ड डेटासेट में 366 मान हो सकते हैं (2004 के लिए) समय आयाम और दूसरे बच्चे के लिए 365 मान हो सकते हैं (2005 के लिए) समय आयाम के लिए।
* अन्य सभी आयामों के लिए सभी मान (उदाहरण के लिए, अक्षांश, देशांतर) MUST सभी बच्चों के लिए समान है। परीक्षण की परिशुद्धता द्वारा निर्धारित की जाती है [मैच AxisNDigits](#matchaxisndigits) ।
* क्रमबद्ध आयाम मान - प्रत्येक आयाम के लिए मान को क्रमबद्ध क्रम में होना चाहिए (चढ़ना या उतरना) । मूल्यों को अनियमित रूप से स्पेस किया जा सकता है। कोई संबंध नहीं हो सकता है। यह आवश्यकता है [CF मेटाडाटा मानक](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) । यदि किसी भी आयाम के मान क्रमबद्ध क्रम में नहीं हैं, तो डेटासेट को लोड नहीं किया जाएगा और लोड नहीं किया जाएगा। ERDDAP™ लॉग फाइल में प्रथम अनॉर्टेड मान की पहचान करेगा, *बड़ाParentDirectory* /logs/log.txt।
    
Unsorted आयाम मान लगभग हमेशा स्रोत डेटासेट के साथ एक समस्या का संकेत देते हैं। यह आमतौर पर तब होता है जब एकत्रीकरण में एक गलतनाम या अनुचित फ़ाइल शामिल की जाती है, जिससे एक अनधिकृत समय आयाम होता है। इस समस्या को हल करने के लिए त्रुटि संदेश देखें ERDDAP™ लॉग.txt फ़ाइल को ऑफेंडिंग टाइम वैल्यू खोजने के लिए। फिर संबंधित फ़ाइल खोजने के लिए स्रोत फ़ाइलों को देखें (पहले या एक के बाद) यह एकत्रीकरण में नहीं है।
    
* माता-पिता डेटासेट और बच्चे डेटासेट MUST अलग है datasetID S. यदि किसी परिवार में कोई नाम बिल्कुल समान है, तो डेटासेट लोड होने में विफल हो जाएगा (त्रुटि संदेश के साथ कि कुल अक्ष के मान क्रमबद्ध क्रम में नहीं हैं) ।
* वर्तमान में, चाइल्ड डेटासेट एक होना चाहिए EDDGrid FromDap dataset और MUST में कुल आयाम का सबसे कम मान है (आमतौर पर सबसे पुराना समय मान) । अन्य सभी बच्चे MUST लगभग समान डेटासेट हो सकते हैं (पहले आयाम के लिए मूल्यों में सिर्फ भिन्न) और सिर्फ उनके द्वारा निर्दिष्ट कर रहे हैं sourceUrl ।
* कुल डेटासेट को पहले बच्चे से अपना मेटाडाटा मिलता है।
* The The most of the [जनगणना Xml कार्यक्रम](#generatedatasetsxml) किसी न किसी प्रारूप का निर्माण कर सकते हैं datasets.xml के लिए EDDGrid कुल मौजूदा आयाम एक द्वारा सेवा की गई फ़ाइलों के एक सेट के आधार पर Hyrax या THREDDS सर्वर। उदाहरण के लिए, कार्यक्रम के लिए इस इनपुट का उपयोग करें (यूआरएल में "/1988" उदाहरण तेजी से चल रहा है) :
    ```
      EDDType? EDDGridAggregateExistingDimension  
      Server type (hyrax, thredds, or dodsindex)? hyrax  
      Parent URL (for example, for hyrax, ending in "contents.html";  
        for thredds, ending in "catalog.xml")  
      ? https://opendap.jpl.nasa.gov/opendap/ocean\\_wind/ccmp/L3.5a/data/  
        flk/1988/contents.html  
      File name regex (for example, ".\\*\\.nc")? month.\\*flk\\.nc\\.gz  
      ReloadEveryNMinutes (for example, 10080)? 10080  
    ```
आप परिणामस्वरूप का उपयोग कर सकते हैं&lt; sourceUrl &gt; टैग या उन्हें हटाने और uncommented&lt; sourceUrl &gt; टैग (जैसा कि प्रत्येक बार नई फ़ाइलों को डेटासेट रीलोड किया जाता है)।
####  EDDGrid कुल मिलाकर आयाम कंकाल एक्सएमएल{#eddgridaggregateexistingdimension-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDGridAggregateExistingDimension" [datasetID](#datasetid)\\="..."  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dataset>...&lt;/dataset> &lt;!-- This is a regular [EDDGridFromDap](#eddgridfromdap) dataset  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description child with the lowest values for the aggregated  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dimensions. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceUrl>](#sourceurl)...&lt;/sourceUrl> &lt;!-- 0 or many; the sourceUrls for  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other children.  These children must be listed in order of  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascending values for the aggregated dimension. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;sourceUrls serverType="..." regex="..." recursive="true"  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[pathRegex](#pathregex)\\=".\\*"  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;>https://*someServer/someDirectory/someSubdirectory*/catalog.xml&lt;/sourceUrls>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- 0 or 1. This specifies how to find the other children,  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instead of using separate sourceUrl tags for each child.  The  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;advantage of this is: new children will be detected each time  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the dataset is reloaded. The serverType must be "thredds",  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"hyrax", or "dodsindex". 
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An example of a [regular expression](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html) (regex)  ([tutorial](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html)) is .\\*\\.nc  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recursive can be "true" or "false".  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only directory names which match the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;pathRegex>](#pathregex)  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(default=".\\*") will be accepted.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A thredds catalogUrl MUST include "/thredds/catalog/".  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An example of a thredds catalogUrl is  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[https://thredds1.pfeg.noaa.gov/thredds/catalog/Satellite/aggregsatMH/  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chla/catalog.xml](https://thredds1.pfeg.noaa.gov/thredds/catalog/Satellite/aggregsatMH/chla/catalog.xml)  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An example of a hyrax catalogUrl is  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[https://opendap.jpl.nasa.gov/opendap/allData/ccmp/L3.5a/monthly/  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flk/1988/contents.html](https://opendap.jpl.nasa.gov/opendap/allData/ccmp/L3.5a/monthly/flk/1988/contents.html)  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An example of a dodsindex URL is  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[https://opendap.jpl.nasa.gov/opendap/GeodeticsGravity/tellus/L3/mascon/RL06/JPL/v02/CRI/netcdf/contents.html](https://opendap.jpl.nasa.gov/opendap/GeodeticsGravity/tellus/L3/mascon/RL06/JPL/v02/CRI/netcdf/contents.html)  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Note the "OPeNDAP logo at the top of the page.)  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When these children are sorted by filename, they must be in  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;order of ascending values for the aggregated dimension. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaWMS>](#accessibleviawms)...&lt;/accessibleViaWMS> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;matchAxisNDigits>](#matchaxisndigits)...&lt;/matchAxisNDigits> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;nThreads>](#nthreads)...&lt;/nThreads> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dimensionValuesInMemory>](#dimensionvaluesinmemory)...&lt;/dimensionValuesInMemory> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&lt;/dataset>  

###  EDDGrid कॉपी{#eddgridcopy} 
 [ ** EDDGrid कॉपी** ](#eddgridcopy) किसी अन्य की स्थानीय प्रति बनाता है और बनाए रखता है EDDGrid 's डेटा और स्थानीय प्रतिलिपि से डेटा कार्य करता है।

*    EDDGrid कॉपी (और सारणीबद्ध डेटा के लिए, [EDDTableCopy](#eddtablecopy) ) उपयोग करना बहुत आसान है और एक बहुत प्रभावी है
     **दूरस्थ डेटा स्रोत से डेटा की सेवा के साथ कुछ सबसे बड़ी समस्याओं का समाधान:** 
    * दूरस्थ डेटा स्रोत से डेटा तक पहुंच धीमी हो सकती है।
        * यह धीमा हो सकता है क्योंकि यह स्वाभाविक रूप से धीमा है (उदाहरण के लिए, सर्वर का एक अक्षम प्रकार) ,
        * क्योंकि यह बहुत सारे अनुरोधों से अभिभूत है,
        * या क्योंकि आपका सर्वर या रिमोट सर्वर बैंडविड्थ सीमित है।
    * दूरस्थ डेटासेट कभी-कभी अनुपलब्ध है (फिर, विभिन्न कारणों के लिए) ।
    * डेटा के लिए एक स्रोत पर निर्भर करना अच्छी तरह से स्केल नहीं करता है (उदाहरण के लिए, जब कई उपयोगकर्ता और कई ERDDAP इसका उपयोग) ।
         
* यह कैसे काम करता है - EDDGrid प्रतिलिपि स्वचालित रूप से डेटा की एक स्थानीय प्रतिलिपि बनाने और स्थानीय प्रतिलिपि से डेटा की सेवा करके इन समस्याओं को हल करती है। ERDDAP™ बहुत जल्दी स्थानीय प्रतिलिपि से डेटा की सेवा कर सकते हैं। और स्थानीय प्रतिलिपि बनाने से रिमोट सर्वर पर बोझ को राहत मिलती है। और स्थानीय प्रतिलिपि मूल का बैकअप है, जो स्थिति में कुछ मूल होता है।
    
डेटासेट की स्थानीय प्रतिलिपि बनाने के बारे में कुछ नया नहीं है। यहाँ नया क्या है कि यह वर्ग इसे बनाता है\\*आसान\\*बनाना और बनाना\\*रखरखाव\\*डेटा की एक स्थानीय प्रतिलिपि\\*विविधता\\*दूरस्थ डेटा स्रोतों के प्रकार और\\*मेटाडाटा\\*डेटा की प्रतिलिपि बनाते समय।
    
* डेटा के चक -- EDDGrid प्रतिलिपि दूरस्थ से डेटा के टुकड़ों का अनुरोध करके डेटा की स्थानीय प्रतिलिपि बनाती है&lt;डेटासेट&gt;। बाएं के प्रत्येक मूल्य के लिए एक हिस्सा होगा (पहला) अक्ष चर। EDDGrid प्रतिलिपि अक्ष के लिए दूरस्थ डेटासेट के इंडेक्स नंबर पर भरोसा नहीं करती है - वे बदल सकते हैं।
    
चेतावनी: यदि डेटा के एक हिस्से का आकार इतना बड़ा है (&gt; 2GB) यह समस्या का कारण बनता है, EDDGrid प्रतिलिपि का उपयोग नहीं किया जा सकता है। (Sorry, हम भविष्य में इस समस्या के लिए एक समाधान की उम्मीद है।) 
    
*    \\[ विकल्प EDDGrid प्रतिलिपि -
यदि दूरस्थ डेटा डाउनलोड करने योग्य फ़ाइलों के माध्यम से उपलब्ध है, तो वेब सेवा नहीं, उपयोग करें [कैश FromUrl विकल्प for EDDGrid सेफिल](#cachefromurl) , जो दूरस्थ फ़ाइलों की एक स्थानीय प्रतिलिपि बनाता है और स्थानीय फ़ाइलों से डेटा प्रदान करता है। \\] 
* स्थानीय फाइलें -- डेटा का प्रत्येक हिस्सा एक अलग में संग्रहीत किया जाता है NetCDF एक subdirectory में फ़ाइल *बड़ाParentDirectory* साइटमैप * datasetID * / (यथा निर्दिष्ट [साइटमैप](/docs/server-admin/deploy-install#setupxml) ) । अक्ष मानों से बनाई गई फ़ाइल नामों को उन्हें फ़ाइल नाम-सुरक्षित बनाने के लिए संशोधित किया गया है (उदाहरण के लिए, हाइफेंस को "x2D" द्वारा प्रतिस्थापित किया जाता है।) - यह वास्तविक डेटा को प्रभावित नहीं करता है।
     
* नया डेटा -- हर बार EDDGrid प्रतिलिपि को पुनः लोड किया गया है, यह दूरस्थ जाँच करता है&lt;डेटासेट&gt; यह देखने के लिए कि कौन से हिस्से उपलब्ध हैं। यदि डेटा के एक हिस्से के लिए फ़ाइल पहले से मौजूद नहीं है, तो एक अनुरोध प्राप्त करने के लिए चंक को एक कतार में जोड़ा जाता है। ERDDAP 'टास्कथ्रेड डेटा के टुकड़ों, एक-एक-एक-एक-एक-एक के लिए सभी प्रश्न अनुरोधों को संसाधित करता है। आप कार्य के लिए आंकड़े देख सकते हैंथ्रेड की गतिविधि पर [स्थिति पृष्ठ](/docs/server-admin/additional-information#status-page) और में [दैनिक रिपोर्ट](/docs/server-admin/additional-information#daily-report) । (हाँ, ERDDAP™ इस प्रक्रिया के लिए कई कार्यों को असाइन कर सकता है, लेकिन यह बहुत सारे दूरस्थ डेटा स्रोत की बैंडविड्थ, मेमोरी और सीपीयू समय का उपयोग करेगा, और स्थानीय लोगों के बहुत सारे ERDDAP बैंडविड्थ, मेमोरी और सीपीयू समय, जिनमें से कोई भी अच्छा विचार नहीं है।) 
    
ध्यान दें: पहली बार EDDGrid प्रतिलिपि भरी हुई है, (अगर सब ठीक हो जाता है) डेटा के बहुत सारे अनुरोधों को टाटथ्रेड के कतार में जोड़ा जाएगा, लेकिन कोई स्थानीय डेटा फ़ाइलों का निर्माण नहीं किया जाएगा। इसलिए निर्माता विफल हो जाएगा लेकिन टास्कथ्रेड स्थानीय फ़ाइलों को काम करने और बनाने के लिए जारी रहेगा। यदि सब ठीक हो जाता है, तो टास्कथ्रेड कुछ स्थानीय डेटा फाइलें बना देगा और डेटासेट को फिर से लोड करने का अगला प्रयास करेगा। (~15 मिनट) शुरू में डेटा की एक सीमित राशि के साथ सफल होगा।
    
नोट: स्थानीय डेटासेट के कुछ डेटा होते हैं और आपके डेटा में दिखाई देते हैं ERDDAP यदि दूरस्थ डेटासेट अस्थायी रूप से या स्थायी रूप से सुलभ नहीं है, तो स्थानीय डेटासेट अभी भी काम करेगा।
    
चेतावनी: यदि दूरस्थ डेटासेट बड़ा है और/या दूरस्थ सर्वर धीमी है (यह समस्या नहीं है?) , यह एक पूर्ण स्थानीय प्रतिलिपि बनाने के लिए एक लंबे समय तक ले जाएगा। कुछ मामलों में, आवश्यक समय अस्वीकार्य होगा। उदाहरण के लिए, T1 लाइन पर 1 टीबी डेटा को ट्रांसमिट करना (0.15 जीबी / एस) इष्टतम परिस्थितियों में कम से कम 60 दिन लगते हैं। इसके अलावा, यह दूरस्थ और स्थानीय कंप्यूटर पर बैंडविड्थ, मेमोरी और सीपीयू टाइम का उपयोग करता है। समाधान दूरस्थ डेटा सेट के प्रशासक को एक हार्ड ड्राइव मेल करना है ताकि वह डेटासेट की एक प्रति बना सके और हार्ड ड्राइव को आपके पास भेज सकें। उस डेटा को शुरुआती बिंदु के रूप में उपयोग करें और EDDGrid कॉपी इसमें डेटा जोड़ देगा। (यह एक रास्ता है कि [अमेज़न की EC2 क्लाउड सर्विस](https://aws.amazon.com/importexport/) इस समस्या को संभालती है, भले ही उनके सिस्टम में बैंडविड्थ बहुत अधिक हो।) 
    
WARNING: यदि बाएं के लिए कोई मूल्य दिया जाता है (पहला) अक्ष चर दूरस्थ डेटासेट से गायब हो जाता है, EDDGrid प्रतिलिपि स्थानीय कॉपी की गई फ़ाइल को नहीं हटाती है। यदि आप चाहते हैं, तो आप इसे स्वयं हटा सकते हैं।
    
#### ग्रिड कॉपी चेकसोर्स डेटा{#grid-copy-checksourcedata} 
The The most of the datasets.xml इस डेटासेट के लिए एक वैकल्पिक टैग हो सकता है
```
    <checkSourceData>true</checkSourceData>  
```
डिफ़ॉल्ट मान सही है। यदि आप इसे झूठ में सेट करते हैं, तो डेटासेट कभी भी यह देखने के लिए स्रोत डेटासेट की जांच नहीं करेगा कि क्या अतिरिक्त डेटा उपलब्ध है।

#### केवल{#onlysince} 
आप कह सकते हैं EDDGrid पूरे स्रोत डेटासेट के बजाय स्रोत डेटासेट के एक सबसेट की एक प्रति बनाने के लिए कॉपी करें, फॉर्म में एक टैग जोड़कर&lt;एकमात्रSince&gt; *कुछ मूल्य* &lt;/onlySince&gt; डेटासेट के लिए datasets.xml भाग। EDDGrid प्रतिलिपि केवल पहले आयाम के मूल्यों से संबंधित डेटा मानों को डाउनलोड करेगी (आमतौर पर समय आयाम) जो अधिक से अधिक है *कुछ मूल्य* । *कुछ मूल्य* हो सकता है:
    * द्वारा निर्दिष्ट एक सापेक्ष समय now-  *n* ।
उदाहरण के लिए,&lt;एकमात्रSince&gt; now- 2 साल&lt;/onlySince&gt; डेटासेट को केवल डेटा के लिए डेटा की स्थानीय प्रतियां बनाने के लिए कहता है जहां बाहरी आयाम का मान (आमतौर पर समय मान) पिछले 2 वर्षों में हैं (जो हर बार डेटासेट को पुनः लोड किया जाता है, जो तब होता है जब यह कॉपी करने के लिए नए डेटा की तलाश करता है) । देखें [ now-  *n* वाक्यविन्यास](https://coastwatch.pfeg.noaa.gov/erddap/tabledap/documentation.html#now) । यह उपयोगी है यदि पहले आयाम में टाइम डेटा होता है, जो आमतौर पर करता है।
        
         EDDGrid प्रतिलिपि स्थानीय डेटा फ़ाइलों को नष्ट नहीं करती है, जिसमें डेटा होता है, समय के साथ, तुलना में पुराना हो जाता है now-  *n* । यदि आप चुनते हैं तो आप उन फ़ाइलों को किसी भी समय हटा सकते हैं। यदि आप करते हैं, तो हम दृढ़ता से अनुशंसा करते हैं कि आप एक सेट करें [झंडा](/docs/server-admin/additional-information#flag) बाद में आप फ़ाइलों को हटाने के लिए EDDGrid कैश्ड फ़ाइलों की सूची को अद्यतन करने के लिए कॉपी करें।
        
    * आईएसओ 8601 स्ट्रिंग के रूप में निर्दिष्ट समय में एक निश्चित बिंदु yyyy-MM-ddTHH:mm:ssZ ।
उदाहरण के लिए,&lt;onlySince&gt;2000-01-01T00:00:00Z&lt;/onlySince&gt; डेटासेट को केवल डेटा की स्थानीय प्रतियां बनाने के लिए कहता है जहां पहला आयाम का मान \\&gt; = 2000-01T00:00Z है। यह उपयोगी है यदि पहले आयाम में टाइम डेटा होता है, जो आमतौर पर करता है।
         
    * एक अस्थायी बिंदु संख्या।
उदाहरण के लिए,&lt;onlySince&gt;946684800.0&lt;/onlySince&gt;। यूनिट पहले आयाम की गंतव्य इकाई होगी। उदाहरण के लिए, समय आयाम के लिए, इकाइयों में ERDDAP™ हमेशा "seconds since 1970-01-01T00:00:00Z" । तो 946684800.0 "seconds since 1970-01-01T00:00:00Z" 2000-01-01T00:00Z के बराबर है। यह हमेशा एक उपयोगी विकल्प है, लेकिन विशेष रूप से उपयोगी है जब पहले आयाम में समय डेटा नहीं होता है।

####  EDDGrid Recomended use{#eddgridcopy-recomended-use} 
1. बनाना&lt;डेटासेट&gt; प्रवेश (मूल प्रकार, नहीं EDDGrid कॉपी) दूरस्थ डेटा स्रोत के लिए।
     **यह सही ढंग से काम कर रहा है, जिसमें सभी वांछित मेटाडाटा शामिल हैं।** 
2. यदि यह बहुत धीमा है, तो XML कोड को एक में लपेटने के लिए जोड़ें EDDGrid डेटासेट कॉपी करें।
    * एक अलग datasetID   (शायद बदलकर datasetID पुराने datasetID थोड़ा) ।
    * कॉपी करें&lt;सुलभ To&gt;&lt;ReloadEveryNMinutes&gt; और&lt;onChange&gt; दूरस्थ से EDDGrid XML EDDGrid प्रतिलिपि XML (उनके मूल्य EDDGrid विषय की प्रतिलिपि बनाएँ; आंतरिक डेटासेट के लिए उनका मूल्य अप्रासंगिक हो जाता है।) 
3.   ERDDAP™ डेटा की एक स्थानीय प्रतिलिपि बनाने और बनाए रखने के लिए।
         
* चेतावनी: EDDGrid प्रतिलिपि मानती है कि प्रत्येक भाग के लिए डेटा मान कभी नहीं बदलता है। अगर वे करते हैं, तो आपको मैन्युअल रूप से चंकने वाली फ़ाइलों को हटाने की आवश्यकता है *बड़ाParentDirectory* साइटमैप * datasetID * / जो बदल गया है और [झंडा](/docs/server-admin/additional-information#flag) डेटासेट को फिर से लोड किया जाना चाहिए ताकि हटाए गए हिस्से को प्रतिस्थापित किया जा सके। यदि आपके पास डेटासेट के लिए एक ईमेल सदस्यता है, तो आपको दो ईमेल मिलेंगे: एक जब डेटासेट पहली बार फिर से लोड हो जाता है और डेटा कॉपी करना शुरू कर देता है, और दूसरा जब डेटासेट फिर से लोड हो जाता है (स्वचालित रूप से) और नए स्थानीय डेटा फ़ाइलों का पता लगाता है।
     
* सभी अक्ष मान बराबर होना चाहिए।
प्रत्येक अक्ष के लिए छोड़कर बाईं ओर (पहला) सभी मूल्यों को सभी बच्चों के लिए बराबर होना चाहिए। परीक्षण की परिशुद्धता द्वारा निर्धारित की जाती है [मैच AxisNDigits](#matchaxisndigits) ।
     
* सेटिंग्स, मेटाडाटा, चर -- EDDGrid कॉपी संलग्न स्रोत डेटासेट से सेटिंग्स, मेटाडाटा और चर का उपयोग करता है।
     
* मेटाडाटा बदलें -- यदि आपको कोई बदलाव करना है addAttributes या स्रोत डेटासेट से जुड़े चर के आदेश को बदलने:
    1. परिवर्तन addAttributes में स्रोत डेटासेट के लिए datasets.xml , आवश्यकतानुसार।
    2. प्रतिलिपिबद्ध फ़ाइलों में से एक को हटा दें।
    3. एक सेट [झंडा](/docs/server-admin/additional-information#flag) तुरंत डेटासेट को पुनः लोड करने के लिए। यदि आप एक ध्वज का उपयोग करते हैं और आपके पास डेटासेट के लिए एक ईमेल सदस्यता है, तो आपको दो ईमेल मिलेंगे: एक जब डेटासेट पहली बार फिर से लोड हो जाता है और डेटा कॉपी करना शुरू कर देता है, और दूसरा जब डेटासेट फिर से लोड हो जाता है (स्वचालित रूप से) और नए स्थानीय डेटा फ़ाइलों का पता लगाता है।
    4. हटाई गई फ़ाइल को नए मेटाडाटा के साथ फिर से बनाया जाएगा। यदि स्रोत डेटासेट कभी अनुपलब्ध है, तो डेटासेट कभी अनुपलब्ध नहीं है। EDDGrid प्रतिलिपि डेटासेट को पुनर्जन्मित फ़ाइल से मेटाडाटा प्राप्त होगा, क्योंकि यह सबसे छोटी फ़ाइल है।
####  EDDGrid कंकाल कॉपी करें एक्सएमएल{#eddgridcopy-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDGridCopy" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaFiles>](#accessibleviafiles)true|false(default)&lt;/accessibleViaFiles>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaWMS>](#accessibleviawms)...&lt;/accessibleViaWMS> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;matchAxisNDigits>](#matchaxisndigits)...&lt;/matchAxisNDigits> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fileTableInMemory>](#filetableinmemory)...&lt;/fileTableInMemory> &lt;!-- 0 or 1 (true or false   
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(the default)) -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;checkSourceData>](#grid-copy-checksourcedata)...&lt;/checkSourceData> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onlySince>](#onlysince)...&lt;/onlySince> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dataset>...&lt;/dataset> &lt;!-- 1 -->  
>&nbsp;&nbsp;&lt;/dataset>  

### EDDTableFromCassandra{#eddtablefromcassandra} 
 [ **EDDTableFromCassandra** ](#eddtablefromcassandra) एक से डेटा संभालती है [Cassandra](https://cassandra.apache.org/) तालिका। Cassandra एक NoSQL डेटाबेस है।

*    ERDDAP™ Cassandra v2 और v3 के साथ कोई परिवर्तन या सेटअप में अंतर के साथ काम कर सकते हैं। हमने परीक्षण किया है [Cassandra v2 और v3 से अपाचे](https://cassandra.apache.org/download/) । यह संभावना है कि ERDDAP™ यह भी डेटास्टैक्स से डाउनलोड Cassandra के साथ काम कर सकते हैं।
     
* अगस्त 2019 के लिए - मई 2021, हमें अपनाओपनजड्क के साथ काम करने के लिए Cassandra प्राप्त करने में परेशानी थी Java v8. यह एक परीक्षा \\_ACCESS \\_VIOLATION threw। लेकिन अब (मई 2021) हम सफलतापूर्वक Cassandra v2.1.22 का उपयोग कर सकते हैं।
     
#### एक टेबल{#one-table} 
Cassandra उस तरीके से "joins" का समर्थन नहीं करता है जिस तरह से संबंधिक डेटाबेस करते हैं। एक ERDDAP™ EDDTableFromCassandra डेटासेट नक्शे एक करने के लिए (शायद एक सबसेट) Cassandra तालिका।

#### Cassandra datasets.xml  {#cassandra-datasetsxml} 
*    ERDDAP™ Cassandra साथ आता है Java इसलिए आपको इसे अलग से स्थापित करने की आवश्यकता नहीं है।
* EDDTableFromCassandra के बारे में इस दस्तावेज़ की सभी जानकारी ध्यान से पढ़ें। कुछ विवरण बहुत महत्वपूर्ण हैं।
* Cassandra Java ड्राइवर अपाचे Cassandra के साथ काम करने का इरादा रखता है (1.2+) DataStax Enterprise (3.1+) । यदि आप अपाचे Cassandra 1.2.x का उपयोग कर रहे हैं, तो आपको शुरू करने के लिए प्रत्येक नोड के लिए cassandra.yaml फ़ाइल को संपादित करना होगा।
* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। फिर आप इसे ठीक करने के लिए संपादित कर सकते हैं (विशेष रूप से)&lt;विभाजन कीसोर्सेनाम (#partitionkeysourcename) ). आप एक EDDTableFromCassandra Dataset के लिए XML बनाने के लिए आवश्यक अधिकांश जानकारी इकट्ठा कर सकते हैं, जो Cassandra प्रशासक से संपर्क करके और वेब खोज कर सकते हैं।
    
जनगणना XML EDDTableFromCassandra के लिए दो विशेष विकल्प हैं:
    
    1. यदि आप "&#123;&#123;&#123;&#123;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123; (उद्धरण के बिना) कुंजीस्पेस के लिए, कार्यक्रम कुंजीस्पेस की एक सूची प्रदर्शित करेगा
    2. यदि आप एक विशिष्ट कुंजीस्पेस में प्रवेश करते हैं और फिर "&#33;&#33;&#33;List&#33;&#33;&#33;" में प्रवेश करते हैं (उद्धरण के बिना) तालिका नाम के लिए, कार्यक्रम उस keyspace और उनके स्तंभों में तालिकाओं की एक सूची प्रदर्शित करेगा।
##### केस संवेदनशीलता{#case-sensitivity} 
* केस-असंवेदनशील कीस्पेस और टेबल नाम -
Cassandra एक मामले के प्रति संवेदनशील तरीके से keyspace और टेबल नामों का इलाज करता है। इस वजह से, आप NEVER एक आरक्षित शब्द का उपयोग करते हैं (लेकिन एक अलग मामले के साथ) एक Cassandra keyspace या टेबल नाम के रूप में।
* केस-असंवेदनशील कॉलम नाम --
डिफ़ॉल्ट रूप से, Cassandra एक मामले के प्रति संवेदनशील तरीके से स्तंभ नामों का इलाज करता है। यदि आप एक स्तंभ नाम के रूप में Cassandra के आरक्षित शब्दों में से एक का उपयोग करते हैं (कृपया नहीं&#33;) , आप उपयोग करना चाहते हैं
```
        <columnNameQuotes>"<columnNameQuotes>  
```
में datasets.xml इस डेटासेट के लिए ताकि Cassandra और ERDDAP™ एक मामले के प्रति संवेदनशील तरीके से स्तंभ नामों का इलाज करेगा। यह संभवतः आपके लिए एक बड़ा सिरदर्द होगा, क्योंकि स्तंभ नामों के मामले-संवेदनशील संस्करणों को निर्धारित करना मुश्किल है - Cassandra लगभग हमेशा कॉलम नामों को सभी निचले-मामले के रूप में प्रदर्शित करता है, भले ही सही मामला हो।
* Cassandra प्रशासक, जो प्रासंगिक अनुभव हो सकता है के साथ मिलकर काम करते हैं। यदि डेटासेट लोड करने में विफल रहता है, तो पढ़ें [त्रुटि संदेश](#troubleshooting-tips) ध्यान से पता लगाने के लिए क्यों।
         
#### Cassandra&lt;कनेक्शन संपत्ति&gt;{#cassandra-connectionproperty} 
Cassandra कनेक्शन गुण है जो में निर्दिष्ट किया जा सकता है datasets.xml । इनमें से कई Cassandra के प्रदर्शन को प्रभावित करेंगे- ERDDAP™ कनेक्शन। दुर्भाग्य से, Cassandra गुणों को प्रोग्रामेटिक रूप से सेट किया जाना चाहिए Java इसलिए ERDDAP™ प्रत्येक संपत्ति के लिए कोड होना चाहिए ERDDAP™ समर्थन वर्तमान में, ERDDAP™ इन गुणों का समर्थन करता है:
 (दिखाए गए डिफ़ॉल्ट हम क्या देखते हैं। आपका सिस्टम डिफ़ॉल्ट अलग हो सकता है।) 

*    **सामान्य विकल्प**   
    &lt;कनेक्शन संपत्ति का नाम **संपीड़न** &gt;&gt; *कोई नहीं | LZ4 | स्नैपी* &lt;/कनेक्शन संपत्ति&gt; (मामले के प्रति संवेदनशील, डिफ़ॉल्ट = none)   
     (सामान्य संपीड़न सलाह: अगर Cassandra और के बीच संबंध है तो 'कोई नहीं' का उपयोग करें ERDDAP™ स्थानीय / तेज है और यदि कनेक्शन दूरस्थ / धीमी है तो 'LZ4' का उपयोग करता है।)   
    &lt;कनेक्शन संपत्ति का नाम **credentials** &gt;&gt; *उपयोगकर्ता नाम / पासवर्ड* &lt;/कनेक्शन संपत्ति&gt; (यह एक शाब्दिक है '/' )   
    &lt;कनेक्शन संपत्ति का नाम **मीट्रिक** &gt;&gt; *सच | झूठ* &lt;/कनेक्शन संपत्ति&gt; (2021-01-25 डिफ़ॉल्ट=true था, अब अनदेखा और हमेशा झूठा)   
    &lt;कनेक्शन संपत्ति का नाम **बंदरगाह** &gt;&gt; *an integer* &lt;/कनेक्शन संपत्ति&gt; (मूल द्विआधारी प्रोटोकॉल = 9042 के लिए डिफ़ॉल्ट)   
    &lt;कनेक्शन संपत्ति का नाम **एसएसएल** &gt;&gt; *सच | झूठ* &lt;/कनेक्शन संपत्ति&gt; (डिफ़ॉल्ट = झूठ)   
     (मेरा त्वरित प्रयास असफल रहा। यदि आप सफल हों, तो कृपया मुझे बताएं कि आपने कैसे किया था।) 
*    **क्वेरी विकल्प**   
    &lt;कनेक्शन संपत्ति का नाम **स्थिरता स्तर** &gt;&gt; *सब | कोई | प्रत्येक | स्थानीय | स्थानीय | स्थानीय | एक | कोरम | धारावाहिक | तीन | दो* &lt;/कनेक्शन संपत्ति&gt; (मामले के प्रति संवेदनशील, डिफ़ॉल्ट = एक)   
    &lt;कनेक्शन संपत्ति का नाम **इकट्ठा करना** &gt;&gt; *an integer* &lt;/कनेक्शन संपत्ति&gt; (डिफ़ॉल्ट=5000)   
     (एक छोटे से मूल्य के लिए नहीं मिलता।)   
    &lt;कनेक्शन संपत्ति का नाम **क्रमिक संगतता स्तर** &gt;&gt; *सब | कोई | प्रत्येक | स्थानीय | स्थानीय | स्थानीय | एक | कोरम | धारावाहिक | तीन | दो* &lt;/कनेक्शन संपत्ति&gt; (मामले के प्रति संवेदनशील, डिफ़ॉल्ट=SERIAL) 
*    **सॉकेट विकल्प**   
    &lt;कनेक्शन संपत्ति का नाम **कनेक्टटाइमआउटमिली** &gt;&gt; *an integer* &lt;/कनेक्शन संपत्ति&gt; (डिफ़ॉल्ट=5000)   
     (कनेक्ट न करें टाइमआउटमिलिस एक छोटे से मूल्य के लिए।)   
    &lt;कनेक्शन संपत्ति का नाम **जीना** &gt;&gt; *सच | झूठ* &lt;/कनेक्शन संपत्ति&gt;
    &lt;कनेक्शन संपत्ति का नाम **readTimeoutMillis** &gt;&gt; *an integer* &lt;/कनेक्शन संपत्ति&gt;
     (Cassandra डिफ़ॉल्ट readTimeoutMillis 12000 है, लेकिन ERDDAP™ डिफ़ॉल्ट को 120000 में बदल देता है। यदि Cassandra readTimeouts फेंक रहा है, तो यह मदद नहीं कर सकता क्योंकि Cassandra कभी-कभी इस समय से पहले उन्हें फेंकता है। समस्या अधिक संभावना है कि आप प्रति विभाजन बहुत ज्यादा डेटा संग्रहीत कर रहे हैं कुंजी संयोजन।)   
    &lt;कनेक्शन संपत्ति का नाम **Bufferआकार** &gt;&gt; *an integer* &lt;/कनेक्शन संपत्ति&gt;
     (यह स्पष्ट नहीं है कि क्या डिफ़ॉल्ट प्राप्त होता है BufferSize। इसे एक छोटा सा मूल्य पर सेट न करें।)   
    &lt;कनेक्शन संपत्ति का नाम **सॉलिंगर** &gt;&gt; *an integer* &lt;/कनेक्शन संपत्ति&gt;
    &lt;कनेक्शन संपत्ति का नाम **TcpNoDelay** &gt;&gt; *सच | झूठ* &lt;/कनेक्शन संपत्ति&gt; (डिफ़ॉल्ट = शून्य) 

यदि आपको अन्य कनेक्शन गुणों को सेट करने में सक्षम होना है, तो हमारे देखें [अतिरिक्त समर्थन प्राप्त करने पर अनुभाग](/docs/intro#support) ।

टॉमकैट के दिए गए स्टार्टअप के लिए, कनेक्शनप्रस्तावों का उपयोग केवल पहली बार किया जाता है जब किसी दिए गए Cassandra URL के लिए डेटासेट बनाया जाता है। उस डेटासेट के सभी रीलोड और उसके बाद के सभी डेटासेट जो उसी URL को साझा करते हैं वे उन मूल कनेक्शनप्रस्तावों का उपयोग करेंगे।
    
#### सीक्यूएल{#cql} 
Cassandra Query Language (सीक्यूएल) विशेष रूप से SQL की तरह है, पारंपरिक डेटाबेस द्वारा उपयोग की जाने वाली क्वेरी भाषा। क्योंकि OPeNDAP एसक्यूएल टैबुलर डेटा अनुरोधों को नकल करने के लिए डिज़ाइन किया गया था, यह संभव है ERDDAP™ सारणीबद्ध डेटा अनुरोधों को CQL बाउंड/PreparedStatements में परिवर्तित करने के लिए। ERDDAP™ में बयान लॉग इन [लॉग-इन](/docs/server-admin/additional-information#log) जैसा
पाठ के रूप में बयान: *स्टेटमेंट AsText*   
आपके द्वारा देखे गए बयान का संस्करण बयान का एक पाठ प्रतिनिधित्व होगा और केवल "?" होगा जहां विवादित मूल्यों को रखा जाएगा।
       
इतना सरल नहीं -- दुर्भाग्य से, CQL में कई प्रतिबंध हैं, जिस पर स्तंभों को किस प्रकार के बाधाओं के साथ पूछताछ की जा सकती है, उदाहरण के लिए, विभाजन कुंजी स्तंभों को = और IN के साथ विभाजित किया जा सकता है, इसलिए ERDDAP™ Cassandra के लिए कुछ बाधाएं भेजता है और Cassandra से डेटा प्राप्त होने के बाद सभी बाधाओं को लागू करता है। मदद ERDDAP™ Cassandra के साथ कुशलतापूर्वक सौदा, आपको निर्दिष्ट करने की आवश्यकता है [&lt;विभाजन कीसोर्सेनाम (#partitionkeysourcename) []&lt;क्लस्टर कॉलमसोर्सेनाम (#clustercolumnsourcename) []&lt;अनुक्रमणिका (#Institutecolumnsourcename) में datasets.xml इस डेटासेट के लिए। ये मदद करने के लिए सबसे महत्वपूर्ण तरीके हैं ERDDAP™ Cassandra साथ कुशलतापूर्वक काम करते हैं। यदि आप नहीं बोलते हैं ERDDAP™ यह जानकारी, डेटासेट दर्दनाक रूप से धीमा हो जाएगा ERDDAP™ और Cassandra संसाधनों के टन का उपयोग करें।
     
#### &lt;विभाजन KeySourceNames&gt;{#partitionkeysourcenames} 
क्योंकि विभाजन कुंजी Cassandra टेबल में एक केंद्रीय भूमिका निभाते हैं, ERDDAP™ उनके बारे में जानने की जरूरत sourceName यदि प्रासंगिक हो, तो उनके साथ काम करने के बारे में अन्य जानकारी।
* आप MUST में विभाजन कुंजी स्रोत स्तंभ नामों की एक comma-separated सूची निर्दिष्ट datasets.xml माध्यम&lt;विभाजन KeySourceNames
उदाहरण
```
        <partitionKeySourceNames>station, deviceid<partitionKeySourceNames>  
```
अधिक जटिल उदाहरण
```
        <partitionKeySourceNames>deviceid=1007, date/sampletime/1970-01-01<partitionKeySourceNames>
```
* टाइमस्टैम्प विभाजन कुंजी -- यदि विभाजन कुंजी कॉलम में से एक एक टाइमस्टैम्प कॉलम है जिसमें किसी अन्य टाइमस्टैम्प कॉलम का मोटे संस्करण है, तो इसे इसके माध्यम से निर्दिष्ट करें
     *विभाजन कुंजीSourcName/otherColumnSourceName/ time\\_precision *   
कहाँ time\\_precision एक है [ time\\_precision ](#time_precision) कहीं और इस्तेमाल किया तार ERDDAP ।
Z in the trailing time\\_precision स्ट्रिंग डिफ़ॉल्ट है, इसलिए यह कोई फर्क नहीं पड़ता कि क्या है time\\_precision स्ट्रिंग Z में समाप्त होती है या नहीं।
उदाहरण के लिए, ERDDAP™ दिनांक / नमूना / 1970-01-01 की व्याख्या करेगा "इसका उपयोग करके नमूना समय पर बाधाओं से तारीख के लिए संयम का निर्माण किया जा सकता है time\\_precision " बाधाओं का वास्तविक रूपांतरण अधिक जटिल है, लेकिन यह अवलोकन है।
     **जब भी यह प्रासंगिक हो इसका प्रयोग करें।** यह सक्षम बनाता है ERDDAP™ Cassandra के साथ कुशलतापूर्वक काम करने के लिए। यदि स्तंभों के बीच यह संबंध एक Cassandra तालिका में मौजूद है और आप नहीं बताते ERDDAP™ डेटासेट दर्दनाक रूप से धीमा हो जाएगा ERDDAP™ और Cassandra संसाधनों के टन का उपयोग करें।
* एकल मूल्य विभाजन कुंजी यदि आप चाहते हैं ERDDAP™ एक विभाजन कुंजी के केवल एक मान के साथ काम करने के लिए डेटासेट, निर्दिष्ट करें *विभाजनKeySourceName=value* ।
एक संख्यात्मक स्तंभ के लिए उद्धरण का उपयोग न करें, उदाहरण के लिए, deviceid=1007
उदाहरण के लिए, स्ट्रिंग कॉलम के लिए उद्धरण का उपयोग करें, स्थिर = "पॉइंट पिनोस"
* डेटासेट डिफ़ॉल्ट क्रम -- विभाजन कुंजी का आदेश&lt; dataVariable &gt; datasets.xml Cassandra से परिणामों के डिफ़ॉल्ट प्रकार के आदेश को निर्धारित करता है। बेशक, उपयोगकर्ता अपील करके परिणामों के दिए गए सेट के लिए अलग-अलग ऑर्डर का अनुरोध कर सकते हैं और orderBy  (" *चरों की अल्पसंख्यक सूची* ") उनके प्रश्नों के अंत तक।
* डिफ़ॉल्ट रूप से, Cassandra और ERDDAP™ एक मामले के प्रति संवेदनशील तरीके से स्तंभ नामों का इलाज करें। लेकिन अगर आप सेट करते हैं [स्तंभनाम Quotes](#case-sensitivity) to " ERDDAP™ Cassandra स्तंभ नामों को मामले के प्रति संवेदनशील तरीके से व्यवहार करेगा।
         
#### &lt;विभाजन KeyCSV&gt;{#partitionkeycsv} 
यदि यह निर्दिष्ट है, ERDDAP™ विभाजन के लिए Cassandra पूछने के बजाय इसका उपयोग करेगा प्रत्येक बार डेटासेट को पुनः लोड किया जाता है। यह अलग विभाजन कुंजी मूल्यों की सूची प्रदान करता है, आदेश में वे इस्तेमाल किया जाएगा। एक बार 1970-01-01T00:00:00Z के बाद से सेकंड के रूप में निर्दिष्ट किया जाना चाहिए। लेकिन समय निर्दिष्ट करने के लिए दो विशेष वैकल्पिक तरीके भी हैं (प्रत्येक स्ट्रिंग के रूप में एन्कोड किया गया) :

1) समय (AISO8601 समय)   (MAY को स्ट्रिंग के रूप में एन्कोड किया जा सकता है)   
2) "समय (anISO8601StartTime, strideSeconds, स्टॉपटाइम) " (MUST को स्ट्रिंग के रूप में कोडित किया जाना चाहिए)   
रुकना समय ISO8601 हो सकता है समय now- nUnits" समय (उदाहरण के लिए, " now- 3 मिनट) ।
रुकना समय शुरू करने का एक सटीक मैच नहीं होना चाहिए समय + x strideSeconds।
एक बार के साथ एक पंक्ति () मूल्य हर क्वेरी से पहले कई पंक्तियों में विस्तारित हो जाता है, इसलिए विभाजन की सूची कुंजी हमेशा पूरी तरह से अद्यतन हो सकती है।
उदाहरण के लिए,
```
    <partitionKeyCSV>
    deviceid,date
    1001,"times(2014-11-01T00:00:00Z, 86400, 2014-11-02T00:00:00Z)"
    1007,"time(2014-11-07T00:00:00Z)"
    1008,time(2014-11-08T00:00:00Z)
    1009,1.4154912E9
    </partitionKeyCSV>
```
विभाजन कुंजी संयोजन की इस तालिका में विस्तार:
```
    deviceid,date
    1001,1.4148E9
    1001,1.4148864E9
    1007,1.4153184E9
    1008,1.4154048E9
    1009,1.4154912E9 
```
#### &lt;क्लस्टरColumnSourceNames&gt;{#clustercolumnsourcenames} 
Cassandra क्लस्टर कॉलम पर SQL-like बाधाओं को स्वीकार करता है, जो स्तंभ हैं जो प्राथमिक कुंजी का दूसरा हिस्सा बनाते हैं (विभाजन कुंजी के बाद (s) ) । इसलिए, यह आवश्यक है कि आप इन स्तंभों को माध्यम से पहचानें&lt;क्लस्टर कॉलमसोर्सेनाम यह सक्षम ERDDAP™ Cassandra के साथ कुशलतापूर्वक काम करने के लिए। यदि वहाँ क्लस्टर कॉलम हैं और आप नहीं बताते हैं ERDDAP डेटासेट दर्दनाक रूप से धीमा हो जाएगा ERDDAP™ और Cassandra संसाधनों के टन का उपयोग करें।
    * उदाहरण के लिए,&lt;क्लस्टर कॉलमसोर्सेनाम *MyClusterColumn1, myClusterColumn2* &lt;/clusterColumnSourceNames&gt;
    * यदि एक Cassandra तालिका में कोई क्लस्टर कॉलम नहीं है, तो या तो निर्दिष्ट नहीं है&lt;क्लस्टरColumnSourceNames
    * डिफ़ॉल्ट रूप से, Cassandra और ERDDAP™ एक मामले के प्रति संवेदनशील तरीके से स्तंभ नामों का इलाज करें। लेकिन अगर आप सेट करते हैं [स्तंभनाम Quotes](#case-sensitivity) to " ERDDAP™ एक मामले के प्रति संवेदनशील तरीके से Cassandra स्तंभ नामों का इलाज करेगा।
         
#### &lt;अनुक्रमणिका{#indexcolumnsourcenames} 
Cassandra स्वीकार करता है '=' माध्यमिक सूचकांक स्तंभों पर बाधाएं, जो स्तंभ हैं जिन्हें आपने स्पष्ट रूप से अनुक्रमित किया है
```
    CREATE INDEX *indexName* ON *keyspace.tableName* (*columnName*);  
```
 (हाँ, माता-पिता की आवश्यकता होती है।)   
तो, यह बहुत उपयोगी है अगर आप इन स्तंभों के माध्यम से पहचानते हैं&lt;अनुक्रमणिका यह सक्षम ERDDAP™ Cassandra के साथ कुशलतापूर्वक काम करने के लिए। यदि अनुक्रमणिका हैं और आप नहीं बताते हैं ERDDAP , कुछ प्रश्नों की आवश्यकता होती है, दर्दनाक रूप से धीमी गति से ERDDAP™ और Cassandra संसाधनों के टन का उपयोग करें।
* उदाहरण के लिए,&lt;अनुक्रमणिका *myIndexColumn1, myIndexColumn2* &lt;/ indexColumnSourceNames&gt;
* यदि एक Cassandra तालिका में कोई इंडेक्स कॉलम नहीं है, तो या तो निर्दिष्ट नहीं है&lt;indexColumnSourceNames&gt;, या इसे बिना किसी मूल्य के निर्दिष्ट करें।
* WARNING: Cassandra इंडेक्स डेटाबेस इंडेक्स की तरह नहीं हैं। Cassandra इंडेक्स केवल मदद के साथ '=' बाधाएं वे केवल हैं [अनुशंसित](https://cassandra.apache.org/doc/latest/cql/indexes.html) उन स्तंभों के लिए जो कुल मानों की तुलना में बहुत कम विशिष्ट मान हैं।
* डिफ़ॉल्ट रूप से, Cassandra और ERDDAP™ एक मामले के प्रति संवेदनशील तरीके से स्तंभ नामों का इलाज करें। लेकिन अगर आप सेट करते हैं [स्तंभनाम Quotes](#case-sensitivity) to " ERDDAP™ एक मामले के प्रति संवेदनशील तरीके से Cassandra स्तंभ नामों का इलाज करेगा।
         
#### &lt;MaxRequestFraction&gt;{#maxrequestfraction} 
कब ERDDAP™   (फिर) डेटासेट लोड करता है, ERDDAP™ Cassandra से विभाजन कुंजी के विभिन्न संयोजनों की सूची मिलती है। एक विशाल डेटासेट के लिए, संयोजन की संख्या बहुत बड़ी होगी। यदि आप उपयोगकर्ताओं को अधिकांश या सभी डेटासेट का अनुरोध करने से रोकना चाहते हैं (या यहां तक कि एक अनुरोध जो पूछता है ERDDAP™ इसे आगे बढ़ाने के लिए अधिकांश या सभी डेटा डाउनलोड करने के लिए) , आप कह सकते हैं ERDDAP™ केवल उन अनुरोधों को अनुमति देने के लिए जो कुछ राशियों द्वारा संयोजनों की संख्या को कम करते हैं&lt;MaxRequestFraction&gt;, जो 1e-10 के बीच एक फ्लोटिंग पॉइंट नंबर है (जिसका मतलब है कि अनुरोध को अरबों में 1 से अधिक संयोजन की आवश्यकता नहीं है) और 1 (डिफ़ॉल्ट, जिसका मतलब है कि अनुरोध पूरे डेटासेट के लिए हो सकता है) ।
उदाहरण के लिए, यदि किसी डेटासेट में विभाजन कुंजी के 10000 अलग-अलग संयोजन हैं और मैक्सRequestFraction को 0.1 पर सेट किया गया है।
इसके बाद 1001 या उससे अधिक संयोजनों से डेटा की आवश्यकता वाले अनुरोध त्रुटि संदेश उत्पन्न करेंगे,
लेकिन 1000 या उससे कम संयोजनों से डेटा की आवश्यकता वाले अनुरोधों को अनुमति दी जाएगी।
    
आम तौर पर, डेटासेट जितना बड़ा होता है, उतना कम आपको सेट करना चाहिए&lt;MaxRequestFraction&gt; इसलिए आप इसे एक छोटे से डेटासेट के लिए सेट कर सकते हैं, एक मध्यम आकार के डेटासेट के लिए 0.1, एक बड़े डेटासेट के लिए 0.01 और एक विशाल डेटासेट के लिए 0.0001।
    
यह दृष्टिकोण सही से दूर है। यह कुछ उचित अनुरोधों को अस्वीकार कर दिया जाएगा और कुछ बहुत बड़े अनुरोधों की अनुमति दी जा रही है। लेकिन यह एक मुश्किल समस्या है और यह समाधान कुछ भी नहीं से बेहतर है।
    
#### Cassandra subsetVariables  {#cassandra-subsetvariables} 
अन्य EDDTable डेटासेट के साथ, आप एक अल्पायोजित सूची को निर्दिष्ट कर सकते हैं&lt; dataVariable &gt; destinationName " नामक वैश्विक विशेषता में एस [ subsetVariables ](#subsetvariables) " वेरिएबल्स की पहचान करने के लिए जिनका मूल्य सीमित है। इसके बाद डेटासेट में एक .subset वेब पेज होगा और कई वेब पृष्ठों पर ड्रॉप-डाउन सूचियों में उन चरों के लिए अलग-अलग मूल्यों की सूची दिखाएंगी।
    
सूची में सिर्फ विभाजन कुंजी चर और स्थैतिक स्तंभों को शामिल करना STRONGLY E है NCO URAGED. Cassandra विशिष्ट संयोजनों की सूची को बहुत जल्दी और आसानी से हर बार डेटासेट को पुनः लोड किया जाता है। एक अपवाद टाइमस्टैम्प विभाजन कुंजी है जो कुछ अन्य टाइमस्टैम्प कॉलम के मोटे संस्करण हैं - शायद इन की सूची से बाहर निकलना सबसे अच्छा है subsetVariables चूंकि बड़ी संख्या में मूल्य हैं और वे उपयोगकर्ताओं के लिए बहुत उपयोगी नहीं हैं।
    
यदि आप सूची में गैर-विभाग कुंजी, गैर-स्थिर चर शामिल हैं, तो शायद यह होगा **बहुत** प्रत्येक बार Cassandra के लिए कम्प्यूटेशनल रूप से महंगा डेटासेट को फिर से लोड किया जाता है, क्योंकि ERDDAP™ सूचना उत्पन्न करने के लिए डेटासेट की हर पंक्ति को देखना है। वास्तव में, क्वेरी विफल होने की संभावना है। इसलिए, बहुत छोटे डेटासेट के अलावा, यह STRONGLY DISCOURAGED है।
    
#### Cassandra Datatypes{#cassandra-datatypes} 
क्योंकि कुछ अस्पष्टता है जिसके बारे में [Cassandra डेटा प्रकार](https://cassandra.apache.org/doc/latest/cql/types.html) जिसके लिए नक्शा ERDDAP™ डेटा प्रकार, आपको निर्दिष्ट करने की आवश्यकता है [&lt;Datatype&gt; (#datatype) प्रत्येक के लिए टैग&lt; dataVariable &gt; (#datavariable) बताने के लिए ERDDAP™ कौन सा डेटाटाइप उपयोग करने के लिए। मानक ERDDAP™ डेटा प्रकार (और सबसे आम संगत Cassandra डेटा प्रकार) हैं:
    
*    [बोरान](#boolean-data)   (बोरान) जो ERDDAP™ तो स्टोर बाइट के रूप में
* बाइट (Int, यदि रेंज -128 से 127 है) 
* छोटा (Int, यदि सीमा -32768 से 32767 है) 
* int (Int, counter?, varint?, यदि रेंज -2147483648 से 2147483647 है) 
* लंबा (Bigint, counter?, varint?, यदि सीमा है -9223372036854775808 to 9223372036854775807) 
* फ्लोट (फ्लोट) 
* डबल (डबल, दशमलव (परिशुद्धता के संभावित नुकसान के साथ) टाइमस्टैम्प) 
* char (अगर उनके पास 1 से अधिक चरित्र नहीं है, तो Ascii या पाठ) 
* स्ट्रिंग (Ascii, पाठ, varchar, inet, uuid, timeuid, blob, नक्शा, सेट, सूची?) 

Cassandra [टाइमस्टैम्प](#cassandra-timestamp-data) एक विशेष मामला है: उपयोग ERDDAP दोहरे डेटा प्रकार

यदि आप स्ट्रिंग डेटाटाइप को निर्दिष्ट करते हैं ERDDAP™ एक Cassandra नक्शा, सेट या सूची के लिए, प्रत्येक Cassandra पंक्ति पर मानचित्र, सेट या सूची को एकल पंक्ति में परिवर्तित किया जाएगा। ERDDAP™ तालिका। ERDDAP™ सूची के लिए एक वैकल्पिक प्रणाली है; नीचे देखें।

 *प्रकार* सूची - ERDDAP [e]&lt;Datatype&gt; (#datatype) Cassandra के लिए टैग dataVariable नियमित रूप से शामिल कर सकते हैं ERDDAP™ डेटा प्रकार (ऊपर देखें) साथ ही कई विशेष डेटाप्रकार जिन्हें Cassandra सूची कॉलम के लिए इस्तेमाल किया जा सकता है: booleanList, बाइटलिस्ट, ubyteList, shortList, ushortList, intList, uintList, LongList, ulongList, फ्लोटलिस्ट, डबललिस्ट, चारलिस्ट, स्ट्रिंगलिस्ट। जब इन सूची कॉलम में से एक को पारित होने के परिणामों में होता है ERDDAP™ , स्रोत डेटा की प्रत्येक पंक्ति सूची में विस्तार किया जाएगा। आकार () डेटा की पंक्तियों में ERDDAP सरल; डेटा प्रकार (उदाहरण के लिए, int) उस स्रोत डेटा पंक्ति में डुप्लिकेट सूची होगी। आकार () समय। यदि परिणामों में एक से अधिक सूची चर होते हैं, तो सभी डेटा की एक निर्धारित पंक्ति पर सूचीबद्ध होते हैं MUST में समान आकार होता है और MUST को "parallel" सूची, या होना चाहिए। ERDDAP™ त्रुटि संदेश उत्पन्न करेगा। उदाहरण के लिए, एक ADCP से वर्तमान माप के लिए,
गहराई \\[ 0 \\] , uCurrent \\[ 0 \\] , vCurrent \\[ 0 \\] , और zCurrent \\[ 0 \\] सभी संबंधित हैं, और
गहराई \\[ 1 \\] , uCurrent \\[ 1 \\] , vCurrent \\[ 1 \\] , और zCurrent \\[ 1 \\] सभी संबंधित हैं, ...
वैकल्पिक रूप से, यदि आप नहीं चाहते हैं ERDDAP™ एकाधिक पंक्तियों में एक सूची का विस्तार करने के लिए ERDDAP™ तालिका, स्ट्रिंग को निर्दिष्ट करें dataVariable डेटा इसलिए पूरी सूची को एक पंक्ति में एक स्ट्रिंग के रूप में दर्शाया जाएगा ERDDAP ।
    
#### Cassandra TimeStamp डेटा{#cassandra-timestamp-data} 
Cassandra का टाइमस्टैम्प डेटा हमेशा समय क्षेत्र के बारे में जागरूक है। यदि आप टाइमज़ोन को निर्दिष्ट किए बिना टाइमस्टैम्प डेटा में प्रवेश करते हैं, तो Cassandra टाइमस्टैम्प स्थानीय समय क्षेत्र का उपयोग करता है।
    
 ERDDAP™ टाइमस्टैम्प डेटा का समर्थन करता है और हमेशा डेटा प्रस्तुत करता है Zulu /GMT समय क्षेत्र। यदि आप Cassandra में टाइमस्टैम्प डेटा में प्रवेश करते हैं तो इसके अलावा एक समय क्षेत्र का उपयोग करके Zulu /GMT, याद रखें कि आपको टाइमस्टैम्प डेटा के लिए सभी क्वेरी करने की आवश्यकता है ERDDAP™ उपयोग करना Zulu /GMT समय क्षेत्र। इसलिए आश्चर्य नहीं है कि जब टाइमस्टैम्प मान निकलते हैं ERDDAP स्थानीय से स्थानीय समय क्षेत्र स्विच के कारण कई घंटों तक स्थानांतरित हो जाते हैं Zulu /GMT समय।

* में ERDDAP ' datasets.xml , में&lt; dataVariable &gt; एक टाइमस्टैम्प चर के लिए टैग, सेट
```
          <dataType>double</dataType>  
```
और&lt; addAttributes &gt; सेट
```
          <att name="units">seconds since 1970-01-01T00:00:00Z</att>
```
* सुझाव: यदि डेटा एक समय सीमा है, तो टाइमस्टैम्प मानों को निहित समय सीमा के केंद्र को संदर्भित करने के लिए उपयोगी है। (उदाहरण के लिए, दोपहर) । उदाहरण के लिए, यदि किसी उपयोगकर्ता के पास किसी अन्य डेटासेट से 2010-03-26T13:00Z के लिए डेटा है और वे इस Cassandra डेटासेट से निकटतम डेटा चाहते हैं जिसमें प्रत्येक दिन के लिए डेटा है, तो 2010-03-26T12:00Z के लिए डेटा (उस तारीख के लिए Cassandra डेटा का प्रतिनिधित्व करना) जाहिर है सबसे अच्छा (पहले या बाद में मध्य रात के विपरीत, जहां यह कम स्पष्ट है जो सबसे अच्छा है) ।
*    ERDDAP™ इसमें उपयोगिता है [एक न्यूमेरिक कनवर्ट करें समय-समय पर स्ट्रिंग टाइम से](https://coastwatch.pfeg.noaa.gov/erddap/convert/time.html) ।
* देखें [कैसे ERDDAP™ समय के साथ सौदे](https://coastwatch.pfeg.noaa.gov/erddap/convert/time.html#erddap) ।
         
#### पूर्णांक{#integer-nulls} 
Cassandra in Cassandra int ( ERDDAP™ int) और bigint ( ERDDAP™ लंबा) स्तंभ, लेकिन ERDDAP™ किसी भी पूर्ण डेटा प्रकार के लिए वास्तविक nulls का समर्थन नहीं करता है।
डिफ़ॉल्ट रूप से, Cassandra पूर्णांक नल में परिवर्तित किया जाएगा ERDDAP™ 2147483647 लंबे स्तंभों के लिए int कॉलम, या 9223372036854775807 के लिए। ये कुछ प्रकार के टेक्स्ट आउटपुट फ़ाइलों में "NaN" के रूप में दिखाई देंगे (उदाहरण के लिए, csv) पाठ आउटपुट फ़ाइलों के अन्य प्रकारों में "" (उदाहरण के लिए, .htmlTable ) , और विशिष्ट संख्या (2147483647 लापता मूल्यों के लिए) अन्य प्रकार की फाइलों में (उदाहरण के लिए, बाइनरी फाइल जैसे .nc चटाई) । उपयोगकर्ता इस प्रकार के लापता मान के साथ डेटा की पंक्तियों की खोज "NaN", जैसे "&windSpeed=NaN" का जिक्र करके कर सकते हैं।
    
यदि आप अपने Cassandra तालिका में लापता मानों को इंगित करने के लिए कुछ अन्य पूर्णांक मान का उपयोग करते हैं, तो कृपया उस मान की पहचान करें datasets.xml :

>    &lt;att name="missing\\_value" [type="int"](#attributetype)\\>-999&lt;/att>

Cassandra फ्लोटिंग पॉइंट कॉलम के लिए, nulls को NaNs में बदल दिया जाता है ERDDAP । Cassandra डेटा प्रकारों के लिए जो स्ट्रिंग्स में परिवर्तित होते हैं ERDDAP™ , nulls खाली स्ट्रिंग में परिवर्तित हो जाते हैं। यह समस्या नहीं होनी चाहिए।
    
#### "WARNING: पहले से तैयार क्वेरी को फिर से तैयार करना"{#warning-re-preparing-already-prepared-query} 
* "WARNING: पहले से ही तैयार क्वेरी की मरम्मत" में *tomcat* /logs/catalina.out (या कुछ अन्य टॉमकैट लॉग फाइल)   
Cassandra प्रलेखन का कहना है कि अगर एक ही क्वेरी को दो बार तैयार स्टेटमेंट में बनाया जाता है तो परेशानी होती है। (या अधिक) । (इसे देखें [बग रिपोर्ट](https://datastax-oss.atlassian.net/browse/JAVA-236) ।) Cassandra Mad बनाने से बचने के लिए, ERDDAP™ सभी तैयारराज्यों को कैश करें ताकि यह उन्हें फिर से इस्तेमाल कर सके। अगर / जब टॉमकैट / ERDDAP™ फिर से शुरू किया गया है, लेकिन मुझे लगता है कि ठीक है क्योंकि तैयार किए गए बयान दिए गए सत्र के साथ जुड़े हुए हैं (बीच Java Cassandra) , जो भी खो गया है। इसलिए, आप इन संदेशों को देख सकते हैं। मुझे कोई अन्य समाधान नहीं मिला। दुर्भाग्यवश, यह एक चेतावनी है, कोई त्रुटि नहीं है (हालांकि Cassandra ने यह धमकी दी कि यह प्रदर्शन समस्याओं का कारण बन सकता है) ।
    
Cassandra का दावा है कि तैयारी स्टेटमेंट हमेशा के लिए अच्छे हैं, इसलिए ERDDAP ' कैश्ड तैयारी स्टेटमेंट कभी भी आउट-ऑफ-डेट / अवैध नहीं होना चाहिए। यदि यह सच नहीं है, और आपको कुछ निश्चित तैयारी के बारे में त्रुटियां प्राप्त होती हैं, तो आपको फिर से शुरू करने की आवश्यकता होती है। ERDDAP™ स्पष्ट करना ERDDAP तैयारी स्टेटमेंट्स का कैश।
    
#### Cassandra सुरक्षा{#cassandra-security} 
देखें [Cassandra सुरक्षित](https://cassandra.apache.org/doc/latest/operating/security.html) 

जब Cassandra के साथ काम करते हैं, तो आपको अपने Cassandra को नुकसान पहुंचाने या डेटा तक पहुंच प्राप्त करने की अनुमति देने से बचने के लिए सुरक्षित रूप से और सुरक्षित रूप से चीजों को करने की आवश्यकता है। ERDDAP™ यह भी सुरक्षित तरीके से काम करने की कोशिश करता है।

* हम आपको स्थापित करने के लिए प्रोत्साहित करते हैं ERDDAP™ एक Cassandra उपयोगकर्ता के रूप में Cassandra से कनेक्ट करने के लिए, जिसमें केवल एक ही उपयोगकर्ता तक पहुंच है। **प्रासंगिक** टेबल (s) और केवल READ विशेषाधिकार है।
* हम आपको कनेक्शन सेट करने के लिए प्रोत्साहित करते हैं ERDDAP™ इतना है कि यह
    * हमेशा एसएसएल का उपयोग करते हैं,
    * केवल एक आईपी पते से कनेक्शन की अनुमति देता है (या पते का एक ब्लॉक) और एक से ERDDAP™ उपयोगकर्ता, और
    * केवल अपने MD5 हैश्ड फॉर्म में पासवर्ड ट्रांसफर करता है।
*    \\[ ज्ञानकोश \\] कनेक्शनप्रस्ताव (पासवर्ड सहित&#33;) में सादे पाठ के रूप में संग्रहीत किया जाता है datasets.xml । हमें प्रशासक को Cassandra पासवर्ड में प्रवेश करने की अनुमति देने का कोई तरीका नहीं मिला है ERDDAP टॉमकैट में स्टार्टअप (जो उपयोगकर्ता इनपुट के बिना होता है) इसलिए पासवर्ड एक फ़ाइल में सुलभ होना चाहिए। इसे सुरक्षित बनाने के लिए:
    * आप (The number of the ERDDAP™ व्यवस्थापक) का मालिक होना चाहिए datasets.xml और READ और WRITE पहुँच है।
    * एक समूह बनाएं जिसमें केवल उपयोगकर्ता = परमाणु शामिल है। बनाने के लिए chgrp का उपयोग करें कि समूह के लिए datasets.xml , सिर्फ READ विशेषाधिकार के साथ।
    * o-rwx विशेषाधिकार निर्दिष्ट करने के लिए chmod का उपयोग करें ("अन्य" उपयोगकर्ताओं के लिए कोई READ या WRITE एक्सेस नहीं) के लिए datasets.xml ।
* कब ERDDAP™ पासवर्ड और अन्य कनेक्शन गुण "निजी" में संग्रहीत होते हैं Java चर।
* ग्राहकों से अनुरोधों को Cassandra के लिए CQL अनुरोध उत्पन्न करने से पहले वैधता के लिए parsed और जाँच की जाती है।
* CQL इंजेक्शन को रोकने के लिए Cassandra को CQL बाउंड / PreparedStatements के साथ अनुरोध किया गया है। किसी भी मामले में, Cassandra स्वाभाविक रूप से पारंपरिक डेटाबेस की तुलना में CQL इंजेक्शन के लिए कम संवेदनशील है। [SQL इंजेक्शन](https://en.wikipedia.org/wiki/SQL_injection) ।
         
#### Cassandra स्पीड{#cassandra-speed} 
Cassandra तेजी से या धीमा हो सकता है। कुछ चीजें आप इसे तेजी से बनाने के लिए कर सकते हैं:
* सामान्य में -
CQL की प्रकृति यह है कि प्रश्न हैं [घोषणा](https://en.wikipedia.org/wiki/Declarative_programming) । वे सिर्फ निर्दिष्ट करते हैं कि उपयोगकर्ता क्या चाहता है। उनमें एक विनिर्देश या संकेत शामिल नहीं हैं कि कैसे क्वेरी को संभालने या अनुकूलित करने के लिए है। इसलिए कोई रास्ता नहीं है ERDDAP™ इस तरह से क्वेरी उत्पन्न करने के लिए कि यह Cassandra क्वेरी को अनुकूलित करने में मदद करता है (या किसी भी तरह से निर्दिष्ट करता है कि कैसे क्वेरी को संभालना है) । सामान्य तौर पर, यह Cassandra प्रशासक तक है जो चीजों को सेट करने के लिए है (उदाहरण के लिए, सूचकांक) कुछ प्रकार के प्रश्नों का अनुकूलन करना।
     
* उन टाइमस्टैम्प कॉलम को निर्दिष्ट करना जो मोटे-सटीक टाइमस्टैम्प विभाजन कुंजी से संबंधित हैं।&lt;विभाजन कीसोर्सेनाम (#partitionkeysourcename) मदद करने का सबसे महत्वपूर्ण तरीका है ERDDAP™ Cassandra साथ कुशलतापूर्वक काम करते हैं। यदि यह संबंध एक Cassandra तालिका में मौजूद है और आप नहीं बताते ERDDAP™ डेटासेट दर्दनाक रूप से धीमा हो जाएगा ERDDAP™ और Cassandra संसाधनों के टन का उपयोग करें।
     
* के माध्यम से क्लस्टर स्तंभों को निर्दिष्ट करना&lt;क्लस्टर कॉलमसोर्सेनाम (#clustercolumnsourcename) मदद करने का दूसरा सबसे महत्वपूर्ण तरीका है ERDDAP™ Cassandra साथ कुशलतापूर्वक काम करते हैं। यदि वहाँ क्लस्टर कॉलम हैं और आप नहीं बताते हैं ERDDAP डेटा के लिए संभावित प्रश्नों का एक बड़ा सेट अनावश्यक रूप से, दर्दनाक रूप से धीमा हो जाएगा ERDDAP™ और Cassandra संसाधनों के टन का उपयोग करें।
     
* बनाना [सूचकांक](https://cassandra.apache.org/doc/latest/cql/indexes.html) आम तौर पर प्रतिबंधित चर के लिए --
आप Cassandra स्तंभों के लिए अनुक्रमणिका बनाकर कुछ प्रश्नों को गति दे सकते हैं जो अक्सर "=" बाधाओं के साथ बाधित होते हैं।
    
Cassandra सूची, सेट, या मानचित्र स्तंभों के लिए अनुक्रमित नहीं कर सकते हैं।
    
* के माध्यम से सूचकांक स्तंभों को निर्दिष्ट करना&lt;अनुक्रमणिका (#Institutecolumnsourcename) मदद करने का एक महत्वपूर्ण तरीका है ERDDAP™ Cassandra साथ कुशलतापूर्वक काम करते हैं। यदि अनुक्रमणिका हैं और आप नहीं बताते हैं ERDDAP डेटा के लिए कुछ प्रश्नों की आवश्यकता नहीं होगी, दर्दनाक रूप से धीमी गति से ERDDAP™ और Cassandra संसाधनों के टन का उपयोग करें।
     
#### Cassandra Stats{#cassandra-stats} 
*    ["Cassandra stats" नैदानिक संदेश](#cassandra-stats) -- प्रत्येक के लिए ERDDAP™ एक Cassandra dataset के लिए उपयोगकर्ता क्वेरी, ERDDAP™ लॉग फ़ाइल में एक लाइन प्रिंट करेगा, *बड़ाParentDirectory* /logs/log.txt, क्वेरी से संबंधित कुछ आंकड़ों के साथ, उदाहरण के लिए,
```
        \\* Cassandra stats: partitionKeyTable: 2/10000=2e-4 < 0.1 nCassRows=1200 nErddapRows=12000 nRowsToUser=7405  
```
उपरोक्त उदाहरण में संख्याओं का उपयोग करना, इसका मतलब है:

* कब ERDDAP™ अंतिम (फिर) इस डेटासेट को लोड किया गया, Cassandra ने कहा ERDDAP™ कि विभाजन कुंजी के 10000 अलग संयोजन थे। ERDDAP™ एक फ़ाइल में सभी अलग संयोजनों को कैश किया।
* उपयोगकर्ता की बाधाओं के कारण, ERDDAP™ पहचाने गए 2 संयोजन 10000 में से जो वांछित डेटा हो सकता है। तो, ERDDAP™ कैसांड्रा को 2 कॉल करेगा, जो विभाजन कुंजी के प्रत्येक संयोजन के लिए एक है। (यही कारण है कि Cassandra की आवश्यकता क्या है।) स्पष्ट रूप से, यह समस्याग्रस्त है अगर एक बड़े डेटासेट में विभाजन कुंजी के संयोजन की एक बड़ी संख्या है और एक दिए गए अनुरोध में काफी हद तक इसे कम नहीं किया गया है। आपको आवश्यकता हो सकती है कि प्रत्येक अनुरोध सेटिंग द्वारा कुंजी स्थान को कम कर देता है [&lt;MaxRequestFraction&gt; (#maxrequest) । यहां, 2/10000=2e-4, जो अधिकतम RequestFraction से कम है (0.1) इसलिए अनुरोध की अनुमति दी गई थी।
* विभाजन कुंजी पर बाधाओं को लागू करने के बाद, [क्लस्टर कॉलम](#clustercolumnsourcenames) , और [सूचकांक स्तंभ](#indexcolumnsourcenames) जिसके द्वारा भेजा गया था ERDDAP™ , Cassandra ने डेटा की 1200 पंक्तियों को वापस कर दिया ERDDAP™ परिणाम सेट में।
* परिणाम होना चाहिए [डेटा टाइप *कुछ प्रकार* सूची](#cassandra-datatypes) स्तंभ (प्रति सूची 10 आइटम का औसत) क्योंकि ERDDAP™ Cassandra से 1200 पंक्तियों का विस्तार 12000 पंक्तियों में ERDDAP ।
*    ERDDAP™ हमेशा Cassandra से डेटा के लिए उपयोगकर्ता की सभी बाधाओं को लागू करता है। इस मामले में, जो बाधाएं कैसंड्रा ने संभाली नहीं थी, ने पंक्तियों की संख्या को 7405 कर दिया था। यह उपयोगकर्ता को भेजे गए पंक्तियों की संख्या है।

इन नैदानिक संदेशों का सबसे महत्वपूर्ण उपयोग यह सुनिश्चित करना है कि ERDDAP™ क्या आप सोचते हैं कि यह क्या कर रहा है? अगर यह नहीं है (उदाहरण के लिए, क्या यह उम्मीद के अनुसार अलग-अलग संयोजनों की संख्या को कम नहीं करता है?) , फिर आप गलत होने के बारे में जानने की कोशिश करने के लिए जानकारी का उपयोग कर सकते हैं।
 
* अनुसंधान और प्रयोग बेहतर खोजने के लिए&lt;कनेक्शनProperty&gt; (#cassandra-connectionproperty) '
 
* Cassandra के बीच नेटवर्क कनेक्शन की गति की जांच करें और ERDDAP । यदि कनेक्शन धीमी है, तो देखें कि क्या आप इसे सुधार सकते हैं। जब सबसे अच्छी स्थिति होती है ERDDAP™ उसी से जुड़े सर्वर पर चल रहा है (तेज) सर्वर के रूप में स्विच करें Cassandra नोड को चलाने के लिए जिसे आप कनेक्ट कर रहे हैं।
 
* कृपया रोगी बनें। यहाँ और Cassandra प्रलेखन में ध्यान से जानकारी पढ़ें। प्रयोग। अपना काम चेक करें। अगर Cassandra ERDDAP™ कनेक्शन अभी भी आप उम्मीद की तुलना में धीमी है, कृपया अपने Cassandra तालिका की स्कीमा और अपने शामिल हैं ERDDAP™ का हिस्सा datasets.xml और देखें [अतिरिक्त समर्थन प्राप्त करने पर अनुभाग](/docs/intro#support) ।
 
* यदि सब कुछ विफल रहता है,
डेटा को संग्रह में संग्रहीत करने पर विचार करें NetCDF v3 .nc फ़ाइलें (विशेष रूप से .nc फ़ाइलें जो उपयोग करती हैं [CF Discrete Sampling Geometries (DSG) ](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries) Contiguous Ragged Array डेटा संरचनाओं और इतने के साथ संभाला जा सकता है ERDDAP ' [EDDTableFromNcCFFiles](#eddtablefromnccffiles) ) । यदि वे तार्किक रूप से व्यवस्थित हैं (प्रत्येक अंतरिक्ष और समय के एक हिस्से के लिए डेटा के साथ) , ERDDAP™ उनमें से बहुत जल्दी डेटा निकाल सकते हैं।
         
#### EDDTableFromCassandra कंकाल XML{#eddtablefromcassandra-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDTableFromCassandra" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;ipAddress>](#sourceurl)...&lt;/ipAddress>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- The Cassandra URL without the port number, for example,  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;127.0.0.1 REQUIRED. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;[connectionProperty](#cassandra-connectionproperty) name="*name*">*value*&lt;/connectionProperty>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- The names (for example, "readTimeoutMillis") and values  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of the Cassandra properties that ERDDAP™ needs to change.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 or more. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;keyspace>...&lt;/keyspace> &lt;!-- The name of the keyspace that has  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the table. REQUIRED. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tableName>...&lt;/tableName> &lt;!-- The name of the table, default = "".  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REQUIRED. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;partitionKeySourceNames>](#partitionkeysourcenames)...&lt;partitionKeySourceNames>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- REQUIRED. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;clusterColumnSourceNames>](#clustercolumnsourcenames)...&lt;clusterColumnSourceNames>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- OPTIONAL. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;indexColumnSourceNames>](#indexcolumnsourcenames)...&lt;indexColumnSourceNames> &lt;!-- OPTIONAL. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;maxRequestFraction>](#maxrequestfraction)...&lt;maxRequestFraction>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- OPTIONAL double between 1e-10 and 1 (the default). -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;columnNameQuotes>](#case-sensitivity)...&lt;columnNameQuotes> &lt;!-- OPTIONAL.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Options: \\[nothing\\] (the default) or ". -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceNeedsExpandedFP\\_EQ>](#sourceneedsexpandedfp_eq)true(default)|false&lt;/sourceNeedsExpandedFP\\_EQ>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addVariablesWhere>](#addvariableswhere)...&lt;/addVariablesWhere> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addAttributes>](#global-attributes)...&lt;/addAttributes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dataVariable>](#datavariable)...&lt;/dataVariable> &lt;!-- 1 or more.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Each dataVariable MUST include a [&lt;dataType>](#datatype) tag. See  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Cassandra DataTypes](#cassandra-datatypes).  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For [Cassandra timestamp columns](#cassandra-timestamp-data), set dataType=double and  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; units=seconds since 1970-01-01T00:00:00Z -->  
>&nbsp;&nbsp;&lt;/dataset>  

### EDDTableFromDapSequence{#eddtablefromdapsequence} 
 [ **EDDTableFromDapSequence** ](#eddtablefromdapsequence) 1- और 2-स्तर अनुक्रमों के भीतर चर संभालती है [ DAP ](https://www.opendap.org/) जैसे सर्वर DAP प्रति व्यक्ति (पर थाhttps://www.pmel.noaa.gov/epic/software/dapper/अब बंद) ।

* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं। आप अपने ब्राउज़र में स्रोत डेटासेट के डीडीएस और डीएएस फ़ाइलों को देखकर आवश्यक जानकारी एकत्र कर सकते हैं (dads और .dds को जोड़कर) sourceUrl (a उदाहरण)https://dapper.pmel.noaa.gov/dapper/epic/tao\\_time\\_series.cdp.dds).
    
* एक चर में है DAP यदि .dds प्रतिक्रिया इंगित करती है कि चर धारण करने वाली डेटा संरचना एक "अनुक्रम" है। (असंवेदनशील) ।
* कुछ मामलों में, आप एक अनुक्रम के भीतर एक अनुक्रम देखेंगे, एक 2-स्तरीय अनुक्रम - EDDTableFromDapSequence इन को भी संभालती है।
#### EDDTableFromDapSequence कंकाल एक्सएमएल{#eddtablefromdapsequence-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDTableFromDapSequence" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceUrl>](#sourceurl)...&lt;/sourceUrl>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addVariablesWhere>](#addvariableswhere)...&lt;/addVariablesWhere> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;outerSequenceName>...&lt;/outerSequenceName>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- The name of the outer sequence for DAP sequence data.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This tag is REQUIRED. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;innerSequenceName>...&lt;/innerSequenceName>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- The name of the inner sequence for DAP sequence data.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This tag is OPTIONAL; use it if the DAP data is a two level  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sequence. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceNeedsExpandedFP\\_EQ>](#sourceneedsexpandedfp_eq)true(default)|false&lt;/sourceNeedsExpandedFP\\_EQ>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceCanConstrainStringEQNE>](#sourcecanconstrainstringeqne)true|false&lt;/sourceCanConstrainStringEQNE>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceCanConstrainStringGTLT>](#sourcecanconstrainstringgtlt)true|false&lt;/sourceCanConstrainStringGTLT>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceCanConstrainStringRegex>](#sourcecanconstrainstringregex)...&lt;/sourceCanConstrainStringRegex>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;skipDapperSpacerRows>...&lt;/skipDapperSpacerRows>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- skipDapperSpacerRows specifies whether the dataset  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;will skip the last row of each innerSequence other than the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last innerSequence (because Dapper servers put NaNs in the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row to act as a spacer).  This tag is OPTIONAL. The default  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is false.  It is recommended that you set this to true for  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all Dapper sources and false for all other data sources. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addAttributes>](#global-attributes)...&lt;/addAttributes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dataVariable>](#datavariable)...&lt;/dataVariable> &lt;!-- 1 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dataset>  

### EDDTableFromDatabase{#eddtablefromdatabase} 
 [ **EDDTableFromDatabase** ](#eddtablefromdatabase) डेटा को एक रिलेशनल डेटाबेस टेबल से संभालता है या [दृष्टिकोण](https://en.wikipedia.org/wiki/View_(database) ).

#### एक तालिका या देखें{#one-table-or-view} 
यदि आप जिस डेटा को सेवा करना चाहते हैं वह दो या दो से अधिक तालिकाओं में है (और इस प्रकार दोनों तालिकाओं से डेटा निकालने के लिए एक जॉइन की आवश्यकता होती है) , आपको एक बनाना होगा [सामान्यीकृत](https://en.wikipedia.org/wiki/Denormalization)   (पहले) टेबल या टेबल [दृष्टिकोण](https://en.wikipedia.org/wiki/View_(SQL) ) उन सभी डेटा के साथ जिन्हें आप एक डेटासेट के रूप में उपलब्ध करना चाहते हैं ERDDAP ।

बड़े, जटिल डेटाबेस के लिए, यह विभिन्न प्रकार के डेटा के साथ अलग-अलग टेबल्स के रूप में अलग करने के लिए समझ सकता है, जो अलग-अलग डेटासेट बन जाएगा। ERDDAP ।

उपयोग के लिए एक असामान्य तालिका बनाना ERDDAP™ आप के लिए एक पागल विचार की तरह लग सकता है। कृपया हमें विश्वास करें। कई कारण क्यों हैं ERDDAP™ denormalized टेबल के साथ काम करता है:

* यह उपयोगकर्ताओं के लिए बहुत आसान है।
कब ERDDAP™ डेटासेट को एक, सरल, denormalized, एकल तालिका के रूप में प्रस्तुत करता है, डेटा को समझने के लिए किसी के लिए बहुत आसान है। अधिकांश उपयोगकर्ताओं ने कभी सामान्य तालिका के बारे में नहीं सुना है, और बहुत कम कुंजी, विदेशी कुंजी, या टेबल में शामिल होने को समझते हैं, और वे लगभग निश्चित रूप से विभिन्न प्रकार के शामिल होने का विवरण नहीं जानते हैं, या SQL को एक जुड़ने के लिए कैसे निर्दिष्ट करें (या एकाधिक जुड़ना) सही ढंग से। एक असामान्य तालिका का उपयोग उन सभी समस्याओं से बचा जाता है। यह कारण अकेले डेटासेट की प्रस्तुति के लिए एक denormalized एकल तालिका के उपयोग को सही ठहराता है ERDDAP™ उपयोगकर्ता
     
* सामान्यीकृत तालिका (कुंजी स्तंभों से संबंधित कई तालिकाएं) डेटाबेस में डेटा संग्रहीत करने के लिए बहुत अच्छा है।
लेकिन SQL में भी, परिणाम जो उपयोगकर्ता को लौटा दिया जाता है, एक denormalized है (शामिल) एकल तालिका। इसलिए उपयोगकर्ताओं को डेटासेट को एक विशाल, denormalized, एकल तालिका के रूप में पेश करना उचित लगता है, जिसके बाद वे सबसेट का अनुरोध कर सकते हैं। (उदाहरण के लिए, मुझे टेबल की पंक्तियों को दिखाएं जहां तापमान&gt; 30) ।
     
* आप बदलाव कर सकते हैं ERDDAP™ अपनी तालिका बदलने के बिना।
     ERDDAP™ कुछ आवश्यकताएं हैं जो आपके डेटाबेस को कैसे सेट किया गया है, से अलग हो सकती हैं।
उदाहरण के लिए, ERDDAP™ उस टाइमस्टैम्प डेटा को 'टाइमस्टैम्प विद टाइमज़ोन' फ़ील्ड में संग्रहीत किया जाना चाहिए।
के लिए एक अलग टेबल/view बनाने के द्वारा ERDDAP™ यदि आप इन बदलावों को बना सकते हैं, तो आप इन बदलावों को तब कर सकते हैं जब आप असामान्य तालिका बनाते हैं ERDDAP । इस प्रकार, आपको अपनी सारणी में कोई बदलाव नहीं करना पड़ता है।
     
*    ERDDAP™ सामान्यीकृत तालिकाओं की संरचना में से कुछ को फिर से बनाया जाएगा।
आप यह निर्दिष्ट कर सकते हैं कि कौन से कॉलम डेटा 'बाहरी' टेबल से आते हैं और इसलिए इसमें सीमित संख्या में विशिष्ट मान होते हैं। ERDDAP™ इन स्तंभों में मूल्यों के सभी विभिन्न संयोजनों को इकट्ठा करेगा और उन्हें एक विशेष पर उपयोगकर्ताओं को पेश करेगा। सबसेट वेब पेज जो उपयोगकर्ताओं को डेटासेट के सबसेट का चयन करने में मदद करता है। प्रत्येक स्तंभ के लिए अलग-अलग मूल्यों को डेटासेट के अन्य वेब पृष्ठों पर ड्रॉप-डाउन सूचियों में भी दिखाया गया है।
     
* एक denormalized तालिका आप से डेटा हाथ से बंद करने के लिए बनाता है ERDDAP व्यवस्थापक आसान।
आप इस डेटासेट के विशेषज्ञ हैं, इसलिए यह समझ में आता है कि आप किस टेबल और कौन से कॉलम में शामिल होने के बारे में निर्णय लेते हैं। इसलिए हमें हाथ नहीं देना चाहिए (या बदतर, अंतिम उपयोगकर्ता) कई तालिकाओं और उनके साथ जुड़ने के लिए विस्तृत निर्देश, आपको बस हमें denormalized तालिका तक पहुंच देना होगा।
     
* एक denormalized तालिका डेटा तक कुशल पहुंच की अनुमति देती है।
सामान्यीकृत रूप आमतौर पर सामान्यीकृत रूप से उपयोग करने के लिए तेजी से होता है। जुड़ना धीमा हो सकता है। एकाधिक जुड़ना बहुत धीमा हो सकता है।
     

डेटाबेस में दो या अधिक तालिकाओं से डेटा प्राप्त करने के लिए ERDDAP™ तीन विकल्प हैं:
 

* अनुशंसित विकल्प:
आप एक कॉमा- या टैब-सेपरेटेड-वैल्युम फ़ाइल बना सकते हैं, जिसमें डेटा को denormalized टेबल से जोड़ा जा सकता है।
यदि डेटासेट विशाल है, तो यह कई फ़ाइलों को बनाने के लिए समझ में आता है, प्रत्येक में denormalized तालिका का एक सामंजस्यपूर्ण सबसेट होता है। (उदाहरण के लिए, एक छोटी समय सीमा से डेटा) ।
    
यहाँ बड़ा लाभ यह है कि ERDDAP™ अपने डेटाबेस द्वारा किसी भी आगे प्रयास के बिना डेटा के लिए उपयोगकर्ता अनुरोधों को संभालने में सक्षम होगा। तो ERDDAP™ अपने डेटाबेस या सुरक्षा जोखिम पर बोझ नहीं होगा। यह लगभग सभी परिस्थितियों में सबसे अच्छा विकल्प है क्योंकि ERDDAP™ आमतौर पर डेटाबेस से तेज़ फ़ाइलों से डेटा प्राप्त कर सकते हैं (यदि हम .csv फ़ाइलों को परिवर्तित करते हैं .nc CF फ़ाइलें) । (कारण का हिस्सा यह है कि ERDDAP + फाइलें एक पठनीय प्रणाली है और इसमें परिवर्तन करने के साथ सौदा नहीं करना पड़ता है जबकि प्रदान करना [एसीआईडी](https://en.wikipedia.org/wiki/ACID)   (Atomicity, Consistency, अलगाव, स्थायित्व) ।) इसके अलावा, आपको शायद एक अलग सर्वर की आवश्यकता नहीं होगी क्योंकि हम अपने RAIDs में से एक पर डेटा स्टोर कर सकते हैं और इसे मौजूदा के साथ एक्सेस कर सकते हैं। ERDDAP™ मौजूदा सर्वर पर।
    
* ओके विकल्प:
आप केवल denormalized तालिका के साथ एक अलग कंप्यूटर पर एक नया डेटाबेस स्थापित किया है।
चूंकि उस डेटाबेस को मारिया डीबी, MySQL और PostgreSQL जैसे एक मुक्त और खुला स्रोत डेटाबेस हो सकता है, इसलिए इस विकल्प को बहुत ज्यादा खर्च नहीं करना चाहिए।
    
यहाँ बड़ा लाभ यह है कि ERDDAP™ अपने वर्तमान डेटाबेस द्वारा किसी भी आगे प्रयास के बिना डेटा के लिए उपयोगकर्ता अनुरोधों को संभालने में सक्षम होगा। तो ERDDAP™ अपने वर्तमान डेटाबेस पर बोझ नहीं होगा। इससे सुरक्षा चिंताओं को भी समाप्त हो जाता है ERDDAP™ आपके वर्तमान डेटाबेस तक पहुंच नहीं होगी।
    
* प्रकटीकरण विकल्प:
हम कनेक्ट कर सकते हैं ERDDAP™ अपने वर्तमान डेटाबेस में।
ऐसा करने के लिए, आपको इसकी आवश्यकता है:
    
    * एक अलग तालिका बनाएं या डेटा की denormalized तालिका के साथ देखें।
    * एक "erddap" उपयोगकर्ता बनाएं, जिन्होंने केवल denormalized टेबल तक पहुंच हासिल की है (s) ।
         
    
यह एक विकल्प है यदि डेटा बहुत बार बदलता है और आप देना चाहते हैं ERDDAP™ उपयोगकर्ताओं को उन परिवर्तनों तक तत्काल पहुंच; हालांकि, यहां तक कि, यह ऊपर और समय-समय पर फ़ाइल विकल्प का उपयोग करने के लिए समझ सकता है (हर 30 मिनट?) उस फाइल को प्रतिस्थापित करें जिसका आज का डेटा है।
इस दृष्टिकोण का विशाल नुकसान यह है कि ERDDAP™ उपयोगकर्ता अनुरोध शायद आपके डेटाबेस पर एक बेहद बड़ा बोझ होगा और यह कि ERDDAP™ कनेक्शन एक सुरक्षा जोखिम है (हालांकि हम जोखिम को कम / प्रबंधित कर सकते हैं) ।

denormalized टेबल बनाना या देखने के लिए ERDDAP™ कुछ बदलाव करने का एक अच्छा अवसर है ERDDAP™ जरूरत है, एक तरह से जो आपकी मूल तालिका को प्रभावित नहीं करता है:

* डेटा टाइप का उपयोग करने के लिए तारीख और टाइमस्टैम्प फ़ील्ड / कॉलम बदलें जो पोस्टग्रेस कॉल करता है [समय क्षेत्र के साथ टाइमस्टैम्प](#database-date-time-data)   (या अपने डेटाबेस में बराबर) ।
टाइम ज़ोन सूचना के बिना टाइमस्टैम्प सही ढंग से काम नहीं करते हैं ERDDAP ।
* उन स्तंभों के लिए सूचकांक बनाना जो उपयोगकर्ता अक्सर खोजते हैं।
* बहुत जागरूक होना [क्षेत्र / स्तंभ नाम का मामला](#quotes-for-names-and-case-sensitivity)   (उदाहरण के लिए, सभी लोअरकेस का उपयोग करें) जब आप उन्हें टाइप करते हैं।
* तालिका के लिए और फ़ील्ड / कॉलम नाम के लिए आरक्षित शब्दों का उपयोग न करें।

यदि आपको denormalized टेबल बनाने या देखने में मदद की आवश्यकता है, तो कृपया अपने डेटाबेस प्रशासक से संपर्क करें।
यदि आप इस पूरे दृष्टिकोण के बारे में बात करना चाहते हैं या इसे करने का सबसे अच्छा तरीका बताते हैं, तो कृपया क्रिस को ईमेल करें। जॉन at noaa.gov.
    
#### डेटाबेस datasets.xml  {#database-in-datasetsxml} 
सही बनाना मुश्किल है datasets.xml के लिए आवश्यक जानकारी ERDDAP™ डेटाबेस से कनेक्शन स्थापित करने के लिए। रोगी बनें व्यवस्थित रहें।
* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं।
        
जनगणना Xml में EDDTableFromDatabase के लिए तीन विशेष विकल्प हैं:
1. यदि आप "&#123;&#123;&#123;&#123;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123; (उद्धरण के बिना) सूची नाम के लिए, कार्यक्रम सूची नामों की एक सूची प्रदर्शित करेगा।
2. यदि आप "&#123;&#123;&#123;&#123;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123; (उद्धरण के बिना) स्कीमा नाम के लिए, कार्यक्रम स्कीमा नामों की एक सूची प्रदर्शित करेगा।
3. यदि आप "&#123;&#123;&#123;&#123;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123; (उद्धरण के बिना) तालिका नाम के लिए, कार्यक्रम टेबल और उनके स्तंभों की सूची प्रदर्शित करेगा। पहले "&#33;&#33;&#33;List&#33;&#33;&#33;" प्रविष्टि जिसे आप बनाते हैं वह है जिसका उपयोग किया जाएगा।
* EDDTableFromDatabase के बारे में इस दस्तावेज़ की सभी जानकारी को ध्यान से पढ़ें।
* आप डेटाबेस प्रशासक से संपर्क करके और वेब खोज करके एक EDDTableFromDatabase डेटासेट के लिए XML बनाने के लिए आवश्यक अधिकांश जानकारी इकट्ठा कर सकते हैं।
* हालांकि डेटाबेस अक्सर एक मामले के प्रति संवेदनशील तरीके से कॉलम नाम और टेबल नामों का इलाज करते हैं, वे मामले-संवेदनशील होते हैं ERDDAP । इसलिए यदि डेटाबेस से त्रुटि संदेश का कहना है कि स्तंभ का नाम अज्ञात है (उदाहरण के लिए, "अज्ञात पहचानकर्ता= ' *कॉलम \\_name* ') हालांकि आप जानते हैं कि यह मौजूद है, सभी पूंजीयों का उपयोग करने की कोशिश करें, उदाहरण के लिए, *COLUMN_NAME* , जो अक्सर स्तंभ नाम का सही, केस-संवेदनशील संस्करण होता है।
* डेटाबेस प्रशासक के साथ मिलकर काम करें, जिनके पास प्रासंगिक अनुभव हो सकता है। यदि डेटासेट लोड करने में विफल रहता है, तो पढ़ें [त्रुटि संदेश](#troubleshooting-tips) ध्यान से पता लगाने के लिए क्यों।
         
#### JDBC ड्राइवर{#jdbc-driver} 
* [JDBC Driver]&lt;ड्राइवर नाम&gt; (#jdbc-driver) -- आपको अपने डेटाबेस के लिए उपयुक्त JDBC 3 या JDBC 4 ड्राइवर .jar फ़ाइल प्राप्त करनी होगी और
इसे अंदर रखें *tomcat* / Webapps/erddap/WEB-INF/lib स्थापित करने के बाद ERDDAP । फिर, अपने आप में datasets.xml इस डेटासेट के लिए आपको निर्दिष्ट करना होगा&lt;ड्राइवरनाम (दुर्भाग्य से) फ़ाइल नाम से अलग। अपने डेटाबेस और ड्राइवर नाम के लिए JDBC ड्राइवर के लिए वेब पर खोजें Java इसका उपयोग करने की जरूरत है।
    
    * मारिया डीबी के लिए, प्रयास करें [https://mariadb.com/kb/en/about-the-mariadb-java-client/](https://mariadb.com/kb/en/about-the-mariadb-java-client/)   
The The most of the&lt;चालकनाम&gt; में उपयोग करने के लिए datasets.xml   (नीचे देखें) शायद org.mariadb.jdbc है। चालक
    * MySQL और Amazon RDS के लिए, कोशिश करें [https://dev.mysql.com/downloads/connector/j/](https://dev.mysql.com/downloads/connector/j/)   
The The most of the&lt;चालकनाम&gt; में उपयोग करने के लिए datasets.xml   (नीचे देखें) शायद com.mysql.jdbc है। चालक
    * के लिए Oracle कोशिश करो [https://www.oracle.com/database/technologies/appdev/jdbc-downloads.html](https://www.oracle.com/database/technologies/appdev/jdbc-downloads.html) ।
The The most of the&lt;चालकनाम&gt; में उपयोग करने के लिए datasets.xml   (नीचे देखें) शायद oracle.jdbc.driver है। Oracle चालक
    * Postgresql के लिए, हमें JDBC 4 ड्राइवर से मिला [https://mvnrepository.com/artifact/org.postgresql/postgresql](https://mvnrepository.com/artifact/org.postgresql/postgresql)   
The The most of the&lt;चालकनाम&gt; में उपयोग करने के लिए datasets.xml   (नीचे देखें) शायद org.postgresql है। चालक
    * SQL सर्वर के लिए, आप JTDS JDBC ड्राइवर से प्राप्त कर सकते हैं [https://jtds.sourceforge.net](https://jtds.sourceforge.net) ।
The The most of the&lt;चालकनाम&gt; में उपयोग करने के लिए datasets.xml   (नीचे देखें) शायद net.sourceforge.jtds.jdbc है। चालक
    
बाद में आप JDBC ड्राइवर .jar डाल दिया ERDDAP™ lib डायरेक्टरी, आपको उस .jar फ़ाइल के लिए एक संदर्भ जोड़ने की आवश्यकता है। Xml, DasDds, और पुरालेखADataset जो में हैं *tomcat* /webapps/erddap/WEB-INF/ निर्देशिका; अन्यथा, जब आप उन लिपियों को चलाते हैं तो आपको ClassNotFoundException मिलेगा।
    
दुर्भाग्य से, JDBC कभी-कभी परेशानी का स्रोत होता है। अपनी भूमिका में बीच के बीच मध्यस्थ के रूप में ERDDAP™ और डेटाबेस, यह कभी-कभी मानक / सामान्य डेटाबेस SQL अनुरोध पर सूक्ष्म परिवर्तन करता है कि ERDDAP™ बनाता है, जिससे समस्याएं पैदा होती हैं (उदाहरण के लिए, संबंधित [ऊपरी / निचले पहचानकर्ता](#quotes-for-names-and-case-sensitivity) और संबंधित [तारीख / समय](#database-date-time-data) ) । कृपया रोगी बनें, जानकारी को ध्यान से पढ़ें, अपने काम की जांच करें और हमारे बारे में देखें [अतिरिक्त समर्थन प्राप्त करने पर अनुभाग](/docs/intro#support) ।
    
#### डेटाबेस&lt;कनेक्शन संपत्ति&gt;{#database-connectionproperty} 
* [&lt;कनेक्शनProperty&gt; (#database-connectionproperty) -- में datasets.xml अपने डेटासेट के लिए, आपको कई कनेक्शन परिभाषित करना होगा संपत्ति टैग बताने के लिए ERDDAP™ अपने डेटाबेस से कैसे कनेक्ट करें (उदाहरण के लिए, उपयोगकर्ता नाम, पासवर्ड, एसएसएल कनेक्शन और निर्दिष्ट करने के लिए [आकार](#set-the-fetch-size) ) । ये हर स्थिति के लिए अलग-अलग होते हैं और यह समझने में थोड़ा मुश्किल होता है। अपने डेटाबेस से जुड़ने के लिए JDBC ड्राइवर का उपयोग करने के उदाहरणों के लिए वेब खोजें। The The most of the&lt;कनेक्शनProperty&gt; नाम (उदाहरण के लिए, "उपयोगकर्ता", "पासवर्ड", और "ssl") , और कुछ कनेक्शनProperty मान "JDBC कनेक्शन गुण के लिए वेब खोजकर पाया जा सकता है *डेटाबेस प्रकार* " (उदाहरण के लिए, Oracle , MySQL, Amazon RDS, MariaDB, PostgreSQL) ।
     
#### नाम और केस संवेदनशीलता के लिए उद्धरण{#quotes-for-names-and-case-sensitivity} 
*    [फील्ड / कॉलम नाम के लिए उद्धरण; केस संवेदनशीलता](#quotes-for-names-and-case-sensitivity) डिफ़ॉल्ट रूप से, EDDTableFromDatabase ने SELECT स्टेटमेंट में फ़ील्ड / कॉलम नामों के आसपास ANSI-SQL-standard डबल उद्धरणों को रखा है, अगर आपने फ़ील्ड / कॉलम नाम के रूप में आरक्षित शब्द का उपयोग किया है, या फ़ील्ड / कॉलम नाम में एक विशेष चरित्र। डबल उद्धरण भी SQL इंजेक्शन हमलों के कुछ प्रकार thwart। आप बता सकते हैं ERDDAP™ उपयोग करने के लिए ", ', या कोई उद्धरण के माध्यम से&lt;स्तंभनाम Quotes&gt; में datasets.xml इस डेटासेट के लिए।
    
कई डेटाबेस के लिए, किसी भी प्रकार के उद्धरणों का उपयोग करके डेटाबेस को किसी मामले में संवेदनशील तरीके से फ़ील्ड / कॉलम नामों के साथ काम करने का कारण बनता है। (डिफ़ॉल्ट डेटाबेस मामले के बजाय असंवेदनशील तरीके से) । डेटाबेस अक्सर फ़ाइल / कॉलम नाम को सभी ऊपरी-मामले के रूप में प्रदर्शित करते हैं, जब वास्तव में मामला संवेदनशील रूप अलग होता है। में ERDDAP™ , कृपया हमेशा डेटाबेस कॉलम नामों को मामले संवेदनशील मानते हैं।
    
    * मारिया के लिए डीबी, आपको डेटाबेस को चलाने की आवश्यकता है [\\-sql-mode=ANSI \\_QUOTES](https://mariadb.com/kb/en/mysql-command-line-client/) ।
    * MySQL और Amazon RDS के लिए, आपको डेटाबेस को चलाने की आवश्यकता है [\\-sql-mode=ANSI \\_QUOTES](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_ansi_quotes) ।
    *    Oracle ANSI-SQL मानक डबल उद्धरण का समर्थन करता है [डिफ़ॉल्ट रूप से](https://docs.oracle.com/database/121/SQLRF/sql_elements008.htm#SQLRF00223) ।
    * PostgreSQL डिफ़ॉल्ट रूप से ANSI-SQL मानक डबल उद्धरण का समर्थन करता है।
    
      
डेटाबेस, कैटलॉग, स्कीमा या टेबल के नाम के लिए आरक्षित शब्द का उपयोग न करें। ERDDAP™ उनके आसपास उद्धरण नहीं डालता है।
    
यदि संभव हो तो डेटाबेस टेबल बनाते समय डेटाबेस, कैटलॉग, स्कीमा, टेबल नाम और फील्ड नामों के लिए सभी लोअर-केस का उपयोग करें (या राय) और जब फ़ील्ड / कॉलम नामों को संदर्भित करता है datasets.xml में ERDDAP । अन्यथा, आपको डेटाबेस, कैटलॉग, स्कीमा, टेबल और/या फ़ील्ड कहकर त्रुटि संदेश मिल सकता है। यदि आप उस त्रुटि संदेश प्राप्त करते हैं, तो केस-संवेदनशील संस्करण का उपयोग करने का प्रयास करें, सभी ऊपरी-मामले संस्करण और नाम के सभी निचले-मामले संस्करण ERDDAP । उनमें से एक काम कर सकता है। यदि नहीं, तो आपको डेटाबेस, कैटलॉग, स्कीमा और/या तालिका के नाम को सभी लोअर-केस में बदलने की आवश्यकता है।
    
#### डेटाबेस&lt;डेटा प्रकार&gt;{#database-datatype} 
*    [डेटाबेस](#database-datatype) [&lt;Datatype&gt; (#datatype) टैग क्योंकि कुछ अस्पष्टता है जिसके बारे में [डेटाबेस डेटा प्रकार](https://www.w3schools.com/sql/sql_datatypes_general.asp) जिसके लिए नक्शा ERDDAP™ डेटा प्रकार, आपको निर्दिष्ट करने की आवश्यकता है [&lt;Datatype&gt; (#datatype) प्रत्येक के लिए टैग&lt; dataVariable &gt; (#datavariable) बताने के लिए ERDDAP™ कौन सा डेटाटाइप उपयोग करने के लिए। समस्या का हिस्सा यह है कि विभिन्न डेटासेट विभिन्न डेटा प्रकारों के लिए अलग-अलग शब्दों का उपयोग करते हैं - इसलिए हमेशा परिभाषाओं से मेल खाने की कोशिश करते हैं, न केवल नाम। विवरण देखें [मानक ERDDAP™ डेटा प्रकार](#data-types) , जिसमें संबंधित SQL डेटा प्रकारों के संदर्भ शामिल हैं। [तारीख और टाइमस्टैम्प](#database-date-time-data) विशेष मामले हैं: उपयोग ERDDAP दोहरे डेटा प्रकार
     
#### डेटाबेस दिनांक समय डेटा{#database-date-time-data} 
कुछ डेटाबेस तारीख समय स्तंभों में कोई स्पष्ट समय क्षेत्र नहीं है। ऐसे स्तंभों के लिए परेशानी होती है ERDDAP । डेटाबेस किसी तारीख की अवधारणा का समर्थन करते हैं (बिना समय के) एक समय क्षेत्र के बिना, समय की अनुमानित सीमा के रूप में। लेकिन Java   (इस प्रकार ERDDAP ) केवल एक टाइमज़ोन के साथ तात्कालिक तारीख + समय से संबंधित है। इसलिए आपको पता चल सकता है कि डेट टाइम डेटा एक स्थानीय समय क्षेत्र पर आधारित है। (डेलाइट सेविंग टाइम के साथ या बिना) या GMT/ Zulu समय क्षेत्र, लेकिन Java   (और ERDDAP ) नहीं हमने मूल रूप से सोचा कि हम इस समस्या के बारे में काम कर सकते हैं (उदाहरण के लिए, स्तंभ के लिए एक समय क्षेत्र निर्दिष्ट करके) , लेकिन डेटाबेस+JDBC+ Java बातचीत ने यह एक अविश्वसनीय समाधान बनाया।
* तो, ERDDAP™ की आवश्यकता है कि आप डेटाबेस तालिका में सभी तारीख और दिनांक समय डेटा को डेटाबेस डेटा प्रकार के साथ स्टोर करते हैं जो JDBC प्रकार "समय क्षेत्र के साथ टाइमस्टैम्प" से मेल खाती है। (आदर्श रूप से, यह GMT/ का उपयोग करता है Zulu समय क्षेत्र) ।
* में ERDDAP ' datasets.xml , में&lt; dataVariable &gt; एक टाइमस्टैम्प चर के लिए टैग, सेट
    >     [&lt;dataType>double&lt;/dataType>](#datatype)  

और&lt; addAttributes &gt; सेट
```
          <att name="units">seconds since 1970-01-01T00:00:00Z</att>
```
* सुझाव: यदि डेटा एक समय सीमा है, तो टाइमस्टैम्प मानों को निहित समय सीमा के केंद्र को संदर्भित करने के लिए उपयोगी है। (उदाहरण के लिए, दोपहर) । उदाहरण के लिए, यदि किसी उपयोगकर्ता के पास किसी अन्य डेटासेट से 2010-03-26T13:00Z के लिए डेटा है और वे प्रत्येक दिन के लिए डेटा रखने वाले डेटाबेस डेटासेट से निकटतम डेटा चाहते हैं, तो 2010-03-26T12:00Z के लिए डेटाबेस डेटा (उस तारीख के लिए डेटा का प्रतिनिधित्व करना) जाहिर है सबसे अच्छा (पहले या बाद में मध्य रात के विपरीत, जहां यह कम स्पष्ट है जो सबसे अच्छा है) ।
*    ERDDAP™ इसमें उपयोगिता है [एक न्यूमेरिक कनवर्ट करें समय-समय पर स्ट्रिंग टाइम से](https://coastwatch.pfeg.noaa.gov/erddap/convert/time.html) ।
* देखें [कैसे ERDDAP समय के साथ सौदे](https://coastwatch.pfeg.noaa.gov/erddap/convert/time.html#erddap) ।
       
#### पूर्णांक{#integer-nulls-1} 
डेटाबेस integer में nulls समर्थन (int, smallint, smallint) स्तंभ, लेकिन ERDDAP™ यह सच नहीं है।
डेटाबेस nulls में परिवर्तित किया जाएगा ERDDAP™ बाइट कॉलम के लिए 127, Ubyte कॉलम के लिए 255, लघु स्तंभों के लिए 32767, 65535 ushort स्तंभों के लिए, 2147483647 int स्तंभों के लिए, 4294967295 Uint स्तंभों के लिए, 9,223,372,036,854,775,807 लंबे स्तंभों के लिए, या 18446744073709551615 ulong स्तंभों के लिए। यदि आप उन डिफ़ॉल्ट का उपयोग करते हैं, तो कृपया उन लोगों की पहचान करें missing\\_value डेटासेट के उपयोगकर्ताओं के लिए ERDDAP™ साथ

>    &lt;att name="\\_FillValue" [type="int"](#attributetype)\\>2147483647&lt;/att>  

या

>    &lt;att name="\\_FillValue" [type="short"](#attributetype)\\>32767&lt;/att>  

वैकल्पिक रूप से, आप " missing\\_value "\\_FillValue" के बजाय विशेषता।
जनगणना Xml स्वचालित रूप से इन \\_FillValue विशेषताओं को जोड़ता है जब यह सुझाव उत्पन्न करता है datasets.xml डेटाबेस डेटासेट के लिए।

डेटाबेस फ्लोटिंग पॉइंट कॉलम के लिए, nulls को NaNs में बदल दिया जाता है ERDDAP ।
डेटाबेस डेटा प्रकारों के लिए जो स्ट्रिंग्स में परिवर्तित होते हैं ERDDAP™ , nulls खाली स्ट्रिंग में परिवर्तित हो जाते हैं।
    
#### डेटाबेस सुरक्षा{#database-security} 
* डेटाबेस के साथ काम करते समय, आपको अपने डेटाबेस को नुकसान पहुंचाने या डेटा तक पहुंच प्राप्त करने के लिए एक दुर्भावनापूर्ण उपयोगकर्ता को अनुमति देने से बचने के लिए सुरक्षित रूप से और सुरक्षित रूप से चीजों को करने की आवश्यकता है। ERDDAP™ यह भी सुरक्षित तरीके से काम करने की कोशिश करता है।
    * दोहराने पर विचार करें, एक अलग कंप्यूटर पर, डेटाबेस और डेटाबेस तालिकाओं के साथ डेटा जिसे आप चाहते हैं ERDDAP™ सेवा करने के लिए (हाँ, व्यावसायिक डेटाबेस के लिए जैसे Oracle इसमें अतिरिक्त लाइसेंसिंग शुल्क शामिल है। लेकिन ओपन सोर्स डेटाबेस के लिए, जैसे PostgreSQL, MySQL, Amazon RDS, और MariaDB, यह लागत कुछ भी नहीं है।) यह आपको सुरक्षा का एक उच्च स्तर देता है और यह भी रोकता है ERDDAP™ मूल डेटाबेस को धीमा करने के अनुरोध।
    * हम आपको स्थापित करने के लिए प्रोत्साहित करते हैं ERDDAP™ डेटाबेस से कनेक्ट करने के लिए एक डेटाबेस उपयोगकर्ता के रूप में जो केवल एक्सेस है **प्रासंगिक** डेटाबेस (s) और केवल READ विशेषाधिकार है।
    * हम आपको कनेक्शन सेट करने के लिए प्रोत्साहित करते हैं ERDDAP™ डेटाबेस के लिए इतना है कि यह
        * हमेशा एसएसएल का उपयोग करते हैं,
        * केवल एक आईपी पते से कनेक्शन की अनुमति देता है (या पते का एक ब्लॉक) और एक से ERDDAP™ उपयोगकर्ता, और
        * केवल अपने MD5 हैश्ड फॉर्म में पासवर्ड ट्रांसफर करता है।
    *    \\[ ज्ञानकोश \\] कनेक्शनप्रस्ताव (पासवर्ड सहित&#33;) में सादे पाठ के रूप में संग्रहीत किया जाता है datasets.xml । हमें व्यवस्थापक को डेटाबेस पासवर्ड में प्रवेश करने की अनुमति देने का कोई तरीका नहीं मिला है ERDDAP टॉमकैट में स्टार्टअप (जो उपयोगकर्ता इनपुट के बिना होता है) इसलिए पासवर्ड एक फ़ाइल में सुलभ होना चाहिए। इसे सुरक्षित बनाने के लिए:
        * आप (The number of the ERDDAP™ व्यवस्थापक) का मालिक होना चाहिए datasets.xml और READ और WRITE पहुँच है।
        * एक समूह बनाएं जिसमें केवल उपयोगकर्ता = परमाणु शामिल है। बनाने के लिए chgrp का उपयोग करें कि समूह के लिए datasets.xml , सिर्फ READ विशेषाधिकार के साथ।
        * o-rwx विशेषाधिकार निर्दिष्ट करने के लिए chmod का उपयोग करें ("अन्य" उपयोगकर्ताओं के लिए कोई READ या WRITE एक्सेस नहीं) के लिए datasets.xml ।
    * कब ERDDAP™ पासवर्ड और अन्य कनेक्शन गुण "निजी" में संग्रहीत होते हैं Java चर।
    * ग्राहकों से अनुरोधों को डेटाबेस के लिए SQL अनुरोध उत्पन्न करने से पहले वैधता के लिए parsed और जाँच की जाती है।
    * डेटाबेस के लिए अनुरोध SQL PreparedStatements के साथ किया जाता है, रोकने के लिए [SQL इंजेक्शन](https://en.wikipedia.org/wiki/SQL_injection) ।
    * डेटाबेस के लिए अनुरोध निष्पादित के साथ प्रस्तुत कर रहे हैं क्वेरी (कार्यान्वयन नहीं) केवल पढ़ने के लिए अनुरोध को सीमित करने के लिए (इसलिए डेटाबेस को बदलने के लिए SQL इंजेक्शन का प्रयास इस कारण से विफल हो जाएगा, बहुत) ।
         
#### SQL{#sql} 
* क्योंकि OPeNDAP एसक्यूएल टैबुलर डेटा अनुरोधों को नकल करने के लिए डिज़ाइन किया गया था, इसके लिए आसान है ERDDAP™ सारणीबद्ध डेटा अनुरोधों को सरल SQL PreparedStatements में परिवर्तित करने के लिए। उदाहरण के लिए, ERDDAP™ अनुरोध
```
    time,temperature&time>=2008-01-01T00:00:00Z&time&lt;=2008-02-01T00:00:00Z  
```
SQL PreparedStatement में परिवर्तित किया जाएगा
```
    SELECT "time", "temperature" FROM *tableName*  
    WHERE "time" >= 2008-01-01T00:00:00Z AND "time" &lt;= 2008-02-01T00:00:00Z  
```
 ERDDAP™ अनुरोध के साथ & distinct () और / या orderBy  ( *चर* ) DISTINCT और / या ORDER BY जोड़ेगा *चर* SQL तैयार बयान के लिए। सामान्य तौर पर, यह डेटाबेस से प्रतिक्रिया को बहुत धीमा कर देगा।
 ERDDAP™ तैयारी में लॉग इन करें [लॉग-इन](/docs/server-admin/additional-information#log) जैसा
```
    statement=*thePreparedStatement*  
```
यह PreparedStatement का एक पाठ प्रतिनिधित्व होगा, जो वास्तविक PreparedStatement से थोड़ा अलग हो सकता है। उदाहरण के लिए, तैयार स्टेटमेंट में, समय को एक विशेष तरीके से कोडित किया जाता है। लेकिन पाठ प्रतिनिधित्व में, वे ISO 8601 तारीख के रूप में दिखाई देते हैं।
     
#### डेटाबेस स्पीड{#database-speed} 
* डेटाबेस धीमी हो सकता है। कुछ चीजें आप कर सकते हैं:
    * सामान्य में -
SQL की प्रकृति यह है कि प्रश्न हैं [घोषणा](https://en.wikipedia.org/wiki/Declarative_programming) । वे सिर्फ निर्दिष्ट करते हैं कि उपयोगकर्ता क्या चाहता है। उनमें एक विनिर्देश या संकेत शामिल नहीं हैं कि कैसे क्वेरी को संभालने या अनुकूलित करने के लिए है। इसलिए कोई रास्ता नहीं है ERDDAP™ इस तरह से क्वेरी उत्पन्न करने के लिए कि यह डेटाबेस को क्वेरी को अनुकूलित करने में मदद करता है (या किसी भी तरह से निर्दिष्ट करता है कि कैसे क्वेरी को संभालना है) । सामान्य तौर पर, यह डेटाबेस प्रशासक तक है जो चीजों को सेट करने के लिए है (उदाहरण के लिए, सूचकांक) कुछ प्रकार के प्रश्नों का अनुकूलन करना।
##### Fetch Size{#set-the-fetch-size} 
डेटाबेस डेटा वापस करने के लिए ERDDAP™ भाग में। डिफ़ॉल्ट रूप से, विभिन्न डेटाबेस अलग-अलग संख्या में पंक्तियों को बदल देते हैं। अक्सर यह संख्या बहुत छोटी और इतनी अक्षम होती है। उदाहरण के लिए, डिफ़ॉल्ट के लिए Oracle 10 है&#33; इसे बढ़ाने के लिए सेट करने के लिए कनेक्शन संपत्ति खोजने के लिए अपने डेटाबेस के JDBC ड्राइवर के लिए JDBC प्रलेखन पढ़ें, और इसे डेटासेट के विवरण में जोड़ें datasets.xml । उदाहरण के लिए,
MySQL और Amazon RDS के लिए, उपयोग करें
```
        <connectionProperty name="defaultFetchSize">10000</connectionProperty>  
```
MariaDB के लिए, वर्तमान में लाने के आकार को बदलने का कोई तरीका नहीं है। लेकिन यह एक अनुरोधित सुविधा है, इसलिए वेब को देखने के लिए खोज करें कि क्या यह लागू किया गया है।
के लिए Oracle उपयोग
```
        <connectionProperty name="defaultRowPrefetch">10000</connectionProperty>  
```
PostgreSQL के लिए उपयोग करें
```
        <connectionProperty name="defaultRowFetchSize">10000</connectionProperty>  
```
लेकिन नंबर बदलने के लिए स्वतंत्र महसूस करें। संख्या को भी बड़ा करना ERDDAP™ कई स्मृतियों का उपयोग करने और स्मृति से बाहर निकलने की संभावना अधिक है।
#### कनेक्शनप्रस्ताव{#connectionproperties} 
प्रत्येक डेटाबेस में अन्य कनेक्शन गुण होते हैं जिन्हें निर्दिष्ट किया जा सकता है datasets.xml । इनमें से कई डेटाबेस के प्रदर्शन को प्रभावित करेंगे ERDDAP™ कनेक्शन। विकल्प देखने के लिए कृपया अपने डेटाबेस के JDBC ड्राइवर के लिए प्रलेखन पढ़ें। यदि आप उन कनेक्शन गुणों को ढूंढते हैं जो उपयोगी हैं, तो कृपया विवरण के साथ एक ईमेल भेजें erd dot data at noaa dot gov ।
* टेबल बनाना
यदि आप समय-समय पर तेजी से प्रतिक्रियाएं प्राप्त करेंगे (रोज़ाना? जब भी नया डेटा होता है?) वास्तविक तालिका उत्पन्न करना (इसी तरह आप कैसे दृष्टिकोण उत्पन्न करने के लिए) और कहा ERDDAP™ देखने के बजाय तालिका से डेटा प्राप्त करने के लिए। चूंकि तालिका के किसी भी अनुरोध को फिर किसी अन्य तालिका में शामिल किए बिना पूरा किया जा सकता है, इसलिए प्रतिक्रिया बहुत तेज होगी।
* तालिका वैक्यूम -
यदि आप उपयोग करते हैं तो MySQL और अमेज़न आरडीएस बहुत तेज़ी से जवाब देगा [ऑप्टिमाइज़ टेबल](https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html) ।
मारिया यदि आप उपयोग करते हैं तो डीबी बहुत तेज़ी से जवाब देगा [ऑप्टिमाइज़ टेबल](https://mariadb.com/kb/en/optimize-table/) ।
यदि आप पोस्टग्रेएसक्यूएल बहुत तेज़ी से जवाब देंगे [वैक्यूम](https://www.postgresql.org/docs/8.3/static/sql-vacuum.html) तालिका।
     Oracle एक अनुरूप आदेश की आवश्यकता नहीं है।
* बनाना [सूचकांक](https://en.wikipedia.org/wiki/Database_index) आम तौर पर प्रतिबंधित चर के लिए --
आप चर के लिए डेटाबेस में अनुक्रमणिका बनाकर कई/अधिकांश प्रश्नों को गति दे सकते हैं (कौन सा डेटाबेस "कॉलम" कहते हैं) अक्सर उपयोगकर्ता के क्वेरी में बाधित होते हैं। सामान्य तौर पर, ये वही वैरिएबल हैं जो द्वारा निर्दिष्ट हैं [&lt; subsetVariables &gt; (#subsetvariables) और/या अक्षांश, देशांतर और समय चर.
##### कनेक्शन पूलिंग का प्रयोग{#use-connection-pooling} 
आम तौर पर, ERDDAP™ प्रत्येक अनुरोध के लिए डेटाबेस के लिए एक अलग कनेक्शन बनाता है। यह सबसे विश्वसनीय दृष्टिकोण है। तेजी से विकल्प एक DataSource का उपयोग करना है जो कनेक्शन पूलिंग का समर्थन करता है। इसे सेट करने के लिए, निर्दिष्ट करें (उदाहरण के लिए)   
```
        <dataSourceName>java:comp/env/jdbc/postgres/erddap</dataSourceName>  
```
आगे&lt; sourceUrl &gt;&lt;ड्राइवर नाम&gt; और&lt;कनेक्शन संपत्ति&gt;
और *tomcat* /conf/context.xml, समान जानकारी के साथ एक संसाधन को परिभाषित करते हैं, उदाहरण के लिए,
```
        <Resource  
        name="jdbc/postgres/erddap" auth="Container" type="javax.sql.DataSource"  
        driverClassName="org.postgresql.Driver"  
        url="*jdbc:postgresql://somehost:5432/myDatabaseName*"  
        username="*myUsername*" password="*myPassword*"  
        initialSize="0" maxActive="8" minIdle="0" maxIdle="0" maxWait="-1"/>  
```
DataSource का उपयोग करने के बारे में सामान्य जानकारी है [https://docs.oracle.com/javase/tutorial/jdbc/basics/sqldatasources.html](https://docs.oracle.com/javase/tutorial/jdbc/basics/sqldatasources.html) ।
देखें [टॉमकैट डेटासोर्स जानकारी](https://tomcat.apache.org/tomcat-7.0-doc/jndi-resources-howto.html#JDBC_Data_Sources) और [टॉमकैट डेटासोर्स उदाहरण](https://tomcat.apache.org/tomcat-7.0-doc/jndi-datasource-examples-howto.html) या अन्य अनुप्रयोग सर्वर के साथ DataSources का उपयोग करने के उदाहरणों के लिए वेब को खोजें।
* यदि सब कुछ विफल रहता है,
डेटा को संग्रह में संग्रहीत करने पर विचार करें NetCDF v3 .nc फ़ाइलें (विशेष रूप से .nc फ़ाइलें जो उपयोग करती हैं [CF Discrete Sampling Geometries (DSG) ](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries) Contiguous Ragged Array डेटा संरचनाओं और इतने के साथ संभाला जा सकता है ERDDAP ' [EDDTableFromNcCFFiles](#eddtablefromnccffiles) ) । यदि वे तार्किक रूप से व्यवस्थित हैं (प्रत्येक अंतरिक्ष और समय के एक हिस्से के लिए डेटा के साथ) , ERDDAP™ उनमें से बहुत जल्दी डेटा निकाल सकते हैं।
         
#### EDDTableFromDatabase कंकाल एक्सएमएल{#eddtablefromdatabase-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDTableFromDatabase" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceUrl>](#sourceurl)...&lt;/sourceUrl>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- The format varies for each type of database, but will be  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;something like:  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For MariaDB:    jdbc:mariadb://*xxx.xxx.xxx.xxx*:3306/*databaseName*  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For MySql       jdbc:mysql://*xxx.xxx.xxx.xxx*:3306/*databaseName*  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For Amazon RDS: jdbc:mysql://*xxx.xxx.xxx.xxx*:3306/*databaseName*  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For Oracle:     jdbc:oracle:thin:@*xxx.xxx.xxx.xxx*:1521:*databaseName*  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For Postgresql: jdbc:postgresql://*xxx.xxx.xxx.xxx*:5432/*databaseName*  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where *xxx.xxx.xxx.xxx* is the host computer's numeric IP address  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;followed by :*PortNumber* (4 digits), which may be different for your  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;database.  REQUIRED. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;[driverName](#jdbc-driver)\\>...&lt;/driverName>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- The high-level name of the database driver, for example,  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"org.postgresql.Driver".  You need to put the actual database  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;driver .jar file (for example, postgresql.jdbc.jar) in  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*tomcat*/webapps/erddap/WEB-INF/lib.  REQUIRED. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;[connectionProperty](#database-connectionproperty) name="*name*">*value*&lt;/connectionProperty>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- The names (for example, "user", "password", and "ssl")  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and values of the properties needed for ERDDAP™ to establish  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the connection to the database.  0 or more. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dataSourceName>](#use-connection-pooling)...&lt;/dataSourceName>  &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;catalogName>...&lt;/catalogName>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- The name of the catalog which has the schema which has the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table, default = "".  OPTIONAL.  Some databases don't use  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;schemaName>...&lt;/schemaName> &lt;!-- The name of the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;schema which has the table, default = "".  OPTIONAL. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tableName>...&lt;/tableName>  &lt;!-- The name of the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table, default = "".  REQUIRED. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;columnNameQuotes>](#quotes-for-names-and-case-sensitivity)&lt;columnNameQuotes> &lt;!-- OPTIONAL. Options:  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" (the default), ', \\[nothing\\]. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;orderBy>...&lt;/orderBy>  &lt;!-- A comma-separated list of  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[sourceName](#sourcename)s to be used in an ORDER BY clause at the end of the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;every query sent to the database (unless the user's request  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;includes an &orderBy() filter, in which case the user's  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderBy is used).  The order of the sourceNames is important.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The leftmost (first) sourceName is most important; subsequent  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceNames are only used to break ties.  Only relevant  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceNames are included in the ORDER BY clause for a given user  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.  If this is not specified, the order of the returned  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values is not specified. Default = "".  OPTIONAL. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceCanOrderBy>](#sourcecanorderby)no(default)|partial|yes&lt;/sourceCanOrderBy>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceCanDoDistinct>](#sourcecandodistinct)no(default)|partial|yes&lt;/sourceCanDoDistinct>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceNeedsExpandedFP\\_EQ>](#sourceneedsexpandedfp_eq)true(default)|false&lt;/sourceNeedsExpandedFP\\_EQ>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addVariablesWhere>](#addvariableswhere)...&lt;/addVariablesWhere> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addAttributes>](#global-attributes)...&lt;/addAttributes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dataVariable>](#datavariable)...&lt;/dataVariable> &lt;!-- 1 or more.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Each dataVariable MUST include a [&lt;dataType>](#datatype) tag.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See [Database DataTypes](#database-datatype).  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For [database date and timestamp columns](#database-date-time-data), set dataType=double and  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;units=seconds since 1970-01-01T00:00:00Z -->  
>&nbsp;&nbsp;&lt;/dataset>  

### EDDTableFrom EDDGrid  {#eddtablefromeddgrid} 
 [ **EDDTableFrom EDDGrid ** ](#eddtablefromeddgrid) आपको किसी से EDDTable डेटासेट बनाने की अनुमति देता है EDDGrid डेटासेट।

* ऐसा करने के कुछ सामान्य कारण हैं:
    * यह डेटासेट को क्वेरी करने की अनुमति देता है OPeNDAP चयन बाधाएं, जो "मूल्य द्वारा क्वेरी" का एक प्रकार है (जो उपयोगकर्ता अनुरोध कर सकता है) ।
    * डेटासेट स्वाभाविक रूप से एक सारणीबद्ध डेटासेट है।
* वैश्विक विशेषता "maxAxis0" का मूल्य (आमतौर पर टाइप = "int") , (डिफ़ॉल्ट 10 है) अक्ष की संख्या को सीमित करने के लिए इस्तेमाल किया जाएगा \\[ 0 \\]   (आमतौर पर "time" धुरी) संलग्न मूल्य EDDGrid डेटासेट जो डेटा के लिए अनुरोध के अनुसार एक्सेस किया जा सकता है। यदि आप चाहते हैं कि कोई सीमा नहीं है, तो 0 का मान निर्दिष्ट करें। यह सेटिंग महत्वपूर्ण है क्योंकि अन्यथा, उपयोगकर्ता को EDDTableFrom से पूछने के लिए यह बहुत आसान होगा EDDGrid सभी ग्रिड डेटासेट के डेटा को देखने के लिए। यह एक लंबे समय तक होगा और लगभग निश्चित रूप से एक टाइमआउट त्रुटि के साथ विफल हो जाएगा। यह सेटिंग है जो EDDTableFrom को सुरक्षित बनाता है EDDGrid अपने डेटासेट ERDDAP बिना डर के वे कम्प्यूटिंग संसाधनों का अनुचित उपयोग करेंगे।
* अगर संलग्न EDDGrid एक है [ EDDGrid सेंध](#eddfromerddap) और ERDDAP™ वही है ERDDAP , फिर EDDTableFrom EDDGrid हमेशा संदर्भित डेटासेट के वर्तमान उपलब्ध संस्करण का उपयोग करेगा। यह EDDTableFrom के लिए एक बहुत ही कुशल तरीका है EDDGrid ग्रिड डेटा तक पहुंचने के लिए।
* इस वर्ग के [&lt;रीलोड हरNMinutes (#reloadeverynminutes) क्या मायने रखता है। संलग्न EDDGrid '&lt;ReloadEveryNMinutes&gt; को अनदेखा कर दिया गया है।
* यदि कोई मूल्य है&lt;EveryNMillis (#updateeverynmillis) इस डेटासेट के लिए आपूर्ति की जाती है, इसे नजरअंदाज कर दिया जाता है। संलग्न EDDGrid '&lt;अद्यतनEveryNMillis&gt; क्या मायने रखता है।
*    [जनरेट DatasetXml](#generatedatasetsxml) Dataset type=EDDTableFrom के लिए एक विकल्प है EDDGrid जो यूआरएल के लिए पूछता है ERDDAP   (आमतौर पर समान ERDDAP )   ("/erddap/" में समाप्त) और एक नियमित अभिव्यक्ति। जनगणना तब XML एक EDDTableFrom के लिए XML उत्पन्न करेगा EDDGrid प्रत्येक ग्रिड डेटासेट के लिए डेटासेट ERDDAP™ जो एक है datasetID जो नियमित अभिव्यक्ति से मेल खाता है (सभी मैच करने के लिए datasetID ग्रिड डेटासेट के लिए S) ।
    
प्रत्येक डेटासेट के लिए जनरेटडाटासेटएक्सएमएल द्वारा उत्पन्न XML का हिस्सा शामिल है:
    
    * A datasetID जो है EDDGrid ' datasetID प्लस "\\_AsATable"।
    * एक नया सारांश वैश्विक विशेषता जो है EDDGrid सारांश प्लस एक नया पहला अनुच्छेद जिसमें यह वर्णन किया गया है कि यह डेटासेट क्या है।
    * एक नया शीर्षक वैश्विक विशेषता जो है EDDGrid शीर्षक प्लस ", (A table) "।
    * 10 के मान के साथ एक नया मैक्सएक्सिस0 वैश्विक विशेषता
#### EDDTableFrom EDDGrid कंकाल XML{#eddtablefromeddgrid-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDTableFromEDDGrid" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;updateEveryNMillis>](#updateeverynmillis)...&lt;/updateEveryNMillis> &lt;!-- 0 or 1.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For EDDTableFromEDDGrid, this calls lowUpdate() of the underlying  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDDGrid. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addVariablesWhere>](#addvariableswhere)...&lt;/addVariablesWhere> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addAttributes>](#global-attributes)...&lt;/addAttributes>  &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dataset>](#eddgrid)...&lt;/dataset> &lt;!-- 1  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Any type of EDDGrid dataset.  You can even use an  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EDDGridFromERDDAP™ to access an independent EDDGrid dataset on  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this server. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dataset>  

### EDDTableFromFileNames{#eddtablefromfilenames} 
 [ **EDDTableFromFileNames** ](#eddtablefromfilenames) सर्वर की फ़ाइल सिस्टम में फ़ाइलों के एक समूह के बारे में जानकारी से डेटासेट बनाता है, जिसमें प्रत्येक फ़ाइल के लिए एक यूआरएल शामिल है ताकि उपयोगकर्ता फ़ाइलों को डाउनलोड कर सकें ERDDAP ' [ "files" प्रणाली](https://coastwatch.pfeg.noaa.gov/erddap/files/documentation.html) । सभी के विपरीत [EDDTableFromFiles](#eddtablefromfiles) उपवर्ग, यह डेटासेट प्रकार फ़ाइलों के भीतर से डेटा की सेवा नहीं करता है।

* EDDTableFromFileNames कब उपयोगी है:
    * आपके पास उन फ़ाइलों का एक समूह है जिन्हें आप पूरी फाइलों के रूप में वितरित करना चाहते हैं क्योंकि उनमें "डेटा" को उसी तरह शामिल नहीं किया गया है कि नियमित डेटा फ़ाइलों में डेटा होता है। उदाहरण के लिए, छवि फ़ाइलों, वीडियो फ़ाइलों, वर्ड दस्तावेजों, एक्सेल स्प्रेडशीट फ़ाइलों, PowerPoint प्रस्तुति फ़ाइलों, या unstructured पाठ के साथ पाठ फ़ाइलों।
    * आपके पास फ़ाइलों का एक समूह है जिसमें एक प्रारूप में डेटा होता है ERDDAP™ अभी तक पढ़ा नहीं जा सकता। उदाहरण के लिए, एक परियोजना-विशिष्ट, कस्टम, द्विआधारी प्रारूप।
         
#### EDDTableFromFileNames डेटा{#eddtablefromfilenames-data} 
*    [एक EDDTableFromFileNames Dataset में डेटा](#eddtablefromfilenames-data) एक सारणी है कि ERDDAP™ स्थानीय फ़ाइलों के समूह के बारे में जानकारी के साथ ऑन-द-फ्लाई बनाता है। तालिका में प्रत्येक फ़ाइल के लिए एक पंक्ति है। में चार विशेष गुण [ datasets.xml इस डेटासेट के लिए](#eddtablefromfilenames-skeleton-xml) यह निर्धारित करना कि इस डेटासेट में कौन सी फाइलें शामिल होंगी:
    
##### फ़ाइल दीर{#filedir} 
    *   &lt;फ़ाइल यह सर्वर की फ़ाइल प्रणाली में इस डेटासेट के लिए फ़ाइलों के साथ स्रोत निर्देशिका निर्दिष्ट करता है। वास्तव में सर्वर की फ़ाइल प्रणाली में स्थित फाइलें&lt;फ़ाइलDir&gt; एक आभासी निर्देशिका के भीतर इस डेटासेट के यूआरएल कॉलम में दिखाई देगा जिसका नाम हैhttps://*serverUrl*/erddap/files/*datasetID/*।
उदाहरण के लिए, यदि datasetID JplMU है RSS टी
और&lt;फ़ाइलDir&gt; है /home/data/mur/ ,
और उस निर्देशिका में jplmu नामक एक फ़ाइल है RSS T20150103000000.png
तब यूआरएल जो उस फाइल के लिए उपयोगकर्ताओं को दिखाया जाएगा
        https://*serverUrl*/erddap/jplMURSST/jplMURSST20150103000000.png।
        
स्थानीय निर्देशिका का उपयोग करने के अलावा&lt;फ़ाइलDir&gt;, आप दूरस्थ, निर्देशिका जैसी वेब पेज के यूआरएल को भी निर्दिष्ट कर सकते हैं। यह काम करता है:
        
        * THREDDS में अद्वितीय डेटासेट, उदाहरण के लिए,
            https://data.nodc.noaa.gov/thredds/catalog/aquarius/nodc\\_binned\\_V3.0/monthly/  \\[ 2020-10-21 यह सर्वर अब विश्वसनीय नहीं है। \\] 
        * Unaggregated datasets in Hyrax , उदाहरण के लिए,
             [https://podaac-opendap.jpl.nasa.gov/opendap/allData/ccmp/L3.5a/monthly/flk/](https://podaac-opendap.jpl.nasa.gov/opendap/allData/ccmp/L3.5a/monthly/flk/) 
        * अधिकांश अपाचे जैसी निर्देशिका लिस्टिंग, उदाहरण के लिए,
             [https://www1.ncdc.noaa.gov/pub/data/cmb/ersst/v5/netcdf/](https://www1.ncdc.noaa.gov/pub/data/cmb/ersst/v5/netcdf/) 
##### fromOnTheFly{#fromonthefly} 
 [\\*\\** FromOnTheFly](#fromonthefly) -- कुछ विशाल S3 बाल्टी के लिए (Noaa-goes17 की तरह, जिसमें 26 मिलियन फाइलें हैं) हो सकता है ERDDAP™ बाल्टी की सामग्री के बारे में सभी जानकारी डाउनलोड करने के लिए 12 घंटे तक (और फिर अन्य समस्याएं हैं) । इसके आसपास जाने के लिए, उपयोग करने का एक विशेष तरीका है&lt;फ़ाइलDir&gt; EDDTableFromFileNames में AWS S3 बाल्टी से निर्देशिका और फ़ाइल नामों के साथ डेटासेट बनाने के लिए। डेटासेट में सभी S3 बाल्टी की निर्देशिकाओं और फ़ाइल नामों की सूची नहीं होगी जो एक उपयोगकर्ता डेटासेट के अनुरोध के माध्यम से खोज सकता है। लेकिन डेटासेट को निर्देशिकाओं और फ़ाइलों के नामों को ऑन-द-फ्लाई मिलेगी यदि उपयोगकर्ता डेटासेट के साथ निर्देशिका पदानुक्रमित करता है "files" विकल्प इस प्रकार, यह उपयोगकर्ताओं को डेटासेट के माध्यम से S3 बाल्टी की फ़ाइल पदानुक्रम और फ़ाइलों को ब्राउज़ करने की अनुमति देता है "files" प्रणाली। ऐसा करने के बजाय, S3 बाल्टी के लिए URL निर्दिष्ट करने के बजाय "शुरू निर्देशिका" के रूप में (में GenerateDatasets एक्सएमएल) या&lt;फ़ाइल (में datasets.xml ) उपयोग:
```
\\*\\*\\*fromOnTheFly,*theS3BucketUrl*  
```
उदाहरण के लिए:
```
\\*\\*\\*fromOnTheFly,https://noaa-goes17.s3.us-east-1.amazonaws.com/  
```
प्रलेखन देखें [S3 बाल्टी के साथ काम करना ERDDAP™ ](#working-with-aws-s3-files) विशेष रूप से विशिष्ट प्रारूप का वर्णन जिसे S3 बाल्टी URL के लिए इस्तेमाल किया जाना चाहिए। और देखें
 [ये विवरण और उदाहरण](#making-an-eddtablefromfilenames-dataset-with-an-aws-s3-bucket) उपयोग करना\\*\\**OntheFly से।
        
##### पुनरावर्ती{#recursive} 
*   &lt;पुनरावर्ती&gt; -- के उपनिर्देशों में फ़ाइलें&lt;फ़ाइलDir&gt; नाम जो मैच के साथ&lt;फ़ाइलRegex&gt; उसी उपनिर्देशों में दिखाई देगी "files" अगर यूआरएल&lt;पुनरावर्ती&gt; सही करने के लिए सेट किया गया है। डिफ़ॉल्ट गलत है।
* [&lt;पथRegex&gt; (#pathregex) -- यदि Recursive=true, तो केवल डायरेक्टरी नाम जो पथRegex से मेल खाते हैं (डिफ़ॉल्ट) स्वीकार किया जाएगा। यदि पुनरावर्ती = झूठ, तो इसे अनदेखा किया जाता है। यह शायद ही कभी इस्तेमाल किया जाता है, लेकिन असामान्य परिस्थितियों में बहुत उपयोगी हो सकता है। (इसे देखें [रेगेक्स प्रलेखन](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html) और [Regex ट्यूटोरियल](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html) ।) 
##### फ़ाइल{#fileregex} 
*   &lt;फ़ाइल केवल फ़ाइल नाम जहां पूरे फ़ाइल नाम (निर्देशिका नाम शामिल नहीं है) मैच&lt;फ़ाइलRegex&gt; इस डेटासेट में शामिल किया जाएगा। उदाहरण के लिए, jplmu RSS PNG. (इसे देखें [रेगेक्स प्रलेखन](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html) और [Regex ट्यूटोरियल](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html) ।)   
         
##### फ़ाइल नाम डेटा तालिका सामग्री से{#from-file-names-data-table-contents} 
तालिका में, इसके साथ स्तंभ होंगे:
* यूआरएल वह URL जो उपयोगकर्ता फ़ाइल को डाउनलोड करने के लिए उपयोग कर सकते हैं ERDDAP ' [ "files" प्रणाली](https://coastwatch.pfeg.noaa.gov/erddap/files/documentation.html) ।
* नाम फ़ाइल का नाम (निर्देशिका नाम के बिना) ।
* अंतिम संशोधित -- फ़ाइल को आखिरी बार संशोधित किया गया था (के साथ डबल्स के रूप में संग्रहीत "seconds since 1970-01-01T00:00:00Z" ) । यह चर उपयोगी है क्योंकि उपयोगकर्ता देख सकते हैं कि क्या/जब किसी दिए गए फ़ाइल की सामग्री बदल दी गई है। यह चर एक है [समय मुद्रा परिवर्तनीय](#timestamp-variables) इसलिए डेटा संख्यात्मक मान के रूप में दिखाई दे सकता है (1970-01-01T00:00:00Z) या स्ट्रिंग मान (आईएसओ 8601:2004 (E) स्वरूप) स्थिति के आधार पर।
* आकार - बाइट्स में फ़ाइल का आकार, डबल्स के रूप में संग्रहीत होता है। उन्हें डबल्स के रूप में संग्रहीत किया जाता है क्योंकि कुछ फाइलें इंट की अनुमति से बड़ी हो सकती हैं और कुछ प्रतिक्रिया फ़ाइल प्रकारों में लंबे समय तक समर्थित नहीं हैं। डबल्स सटीक आकार देंगे, यहां तक कि बहुत बड़ी फ़ाइलों के लिए भी।
* इसके अलावा कॉलम द्वारा परिभाषित ERDDAP™ प्रशासक के साथ जानकारी निकालने से फ़ाइल नाम (उदाहरण के लिए, फ़ाइल में डेटा से जुड़े समय) दो विशेषताओं के आधार पर जो आप प्रत्येक अतिरिक्त कॉलम के लिए मेटाडाटा में निर्दिष्ट करते हैं / dataVariable :
    
    * निकालने Regex यह एक है [नियमित अभिव्यक्ति](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html)   ( [ट्यूटोरियल](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html) ) । पूरे रेगेक्स को पूरे फाइल नाम से मिलान करना चाहिए (निर्देशिका नाम शामिल नहीं है) । रेगेक्स में कम से कम एक कैप्चर समूह शामिल होना चाहिए (एक नियमित अभिव्यक्ति का एक खंड जो माता-पिता द्वारा संलग्न है) जो ERDDAP™ यह निर्धारित करने के लिए उपयोग करता है कि डेटा बनने के लिए फ़ाइल नाम का कौन-सा खंड निकाला जाए।
    * निकालने समूह यह कैप्चर समूह की संख्या है (#1 पहला कैप्चर ग्रुप है) नियमित अभिव्यक्ति में। डिफ़ॉल्ट 1 है। एक कैप्चर समूह एक नियमित अभिव्यक्ति का एक अनुभाग है जो माता-पिता द्वारा संलग्न है।
    
यहाँ दो उदाहरण हैं:
```
            <dataVariable>
                <sourceName>time</sourceName>
                <destinationName>time</destinationName>
                <dataType>String</dataType>
                <addAttributes>
                    <att name="extractRegex">jplMURSST(.{14})\\.png</att>
                    <att name="extractGroup" type="int">1</att>
                    <att name="units">yyyyMMddHHmmss</att>
                </addAttributes>
            </dataVariable>
```
```
            <dataVariable>
                <sourceName>day</sourceName>
                <destinationName>day</destinationName>
                <dataType>int</dataType>
                <addAttributes>
                    <att name="extractRegex">jplMURSST.{6}(..).{6}\\.png</att>
                    <att name="extractGroup" type="int">1</att>
                    <att name="ioos\\_category">Time</att>
                </addAttributes>
            </dataVariable> 
```
समय चर के मामले में, यदि किसी फ़ाइल का नाम jplmu है RSS T20150103000000.png, extractRegex फ़ाइल नाम से मेल खाता है, पात्रों को निकालता है जो पहले कैप्चर समूह से मेल खाता है। ("20150103000000") डेटा टाइप = स्ट्रिंग के रूप में, फिर उपयोग करें [स्ट्रिंग समय के लिए उपयुक्त इकाइयों](#string-time-units) स्ट्रिंग को समय-समय पर डेटा मानों में पार करने के लिए (2015-01-03T00:00:00Z) ।

यदि किसी फ़ाइल का नाम jplMU है तो दिन चर के मामले में RSS T20150103000000.png, extractRegex फ़ाइल नाम से मेल खाता है, पात्रों को निकालता है जो पहले कैप्चर समूह से मेल खाता है। ("03") []&lt;Datatype&gt; (#datatype) \\=int, 3 का डेटा मान पैदा करना।
        
#### अन्य जानकारी{#other-information} 
* नहीं&lt;EveryNMillis (#updateeverynmillis) -- इस प्रकार की डेटासेट की आवश्यकता नहीं है और इसका उपयोग नहीं किया जा सकता है&lt;अद्यतनEveryNMillis&gt; टैग क्योंकि EDDTableFromFileNames द्वारा सेवा की गई जानकारी हमेशा पूरी तरह से अद्यतन हो रही है क्योंकि ERDDAP™ डेटा के लिए प्रत्येक अनुरोध का जवाब देने के लिए फ़ाइल सिस्टम को क्वेरी करता है। यहां तक कि अगर फ़ाइलों की एक बड़ी संख्या है, तो यह दृष्टिकोण उचित रूप से अच्छी तरह से काम करना चाहिए। यदि फ़ाइलों की एक बड़ी संख्या होती है तो एक प्रतिक्रिया धीमी हो सकती है और डेटासेट को थोड़ी देर के लिए क्वारी नहीं किया गया है। लेकिन उसके बाद कई मिनट के लिए, ऑपरेटिंग सिस्टम जानकारी को कैश में रखता है, इसलिए जवाब बहुत तेज़ होना चाहिए।
     
* आप उपयोग कर सकते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) बनाने के लिए datasets.xml इस प्रकार के डेटासेट के लिए भाग लें। जैसा कि ऊपर दिखाया गया है, आप फ़ाइल नाम से निकाली गई जानकारी के साथ अतिरिक्त कॉलम जोड़ / परिभाषित कर सकते हैं।
     
#### EDDTableFromFileNames कंकाल एक्सएमएल{#eddtablefromfilenames-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDTableFromFileNames" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addVariablesWhere>](#addvariableswhere)...&lt;/addVariablesWhere> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fileDir>](#eddtablefromfilenames-data)...&lt;/fileDir>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;recursive>](#eddtablefromfilenames-data)...&lt;/recursive>  &lt;!-- true or false (the default) -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;pathRegex>](#pathregex)...&lt;/pathRegex>  &lt;!-- 0 or 1. Only directory names which  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match the pathRegex (default=".\\*") will be accepted. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fileNameRegex>](#eddtablefromfilenames-data)...&lt;/fileNameRegex>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addAttributes>](#global-attributes)...&lt;/addAttributes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dataVariable>](#datavariable)...&lt;/dataVariable> &lt;!-- 1 or more.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Each dataVariable MUST include [&lt;dataType>](#datatype) tag. -->  
>&nbsp;&nbsp;&lt;/dataset>  

### EDDTableFromFiles{#eddtablefromfiles} 
 [ **EDDTableFromFiles** ](#eddtablefromfiles) सभी EDDTableFrom की सुपरक्लास है। आप सीधे EDDTableFromFiles का उपयोग नहीं कर सकते। इसके बजाय, विशिष्ट फ़ाइल प्रकार को संभालने के लिए EDDTableFromFiles के एक उपश्रेणी का उपयोग करें:

*    [EDDTableFromAsciiFiles](#eddtablefromasciifiles) कॉमा-, टैब-, सेमीकोलॉन-, या स्पेस-सेपरेटेड सारणीबद्ध ASCII डेटा फ़ाइलों से डेटा एकत्र करता है।
*    [EDDTableFromAudioFiles](#eddfromaudiofiles) स्थानीय ऑडियो फ़ाइलों के एक समूह से डेटा एकत्र करता है।
*    [EDDTableFrom AwsXmlFiles](#eddtablefromawsxmlfiles) स्वचालित मौसम स्टेशन के एक सेट से डेटा एकत्र करता है (एडब्ल्यूएस) XML फ़ाइलें
*    [EDDTableFromColumnarAsciiFiles](#eddtablefromcolumnarasciifiles) स्थिर-चौड़ाई डेटा कॉलम के साथ सारणीबद्ध ASCII डेटा फ़ाइलों से डेटा एकत्र करता है।
*    [EDDTableFrom Hyrax फ़ाइलें](#eddtablefromhyraxfiles)   (डिप्रेषित) कई चर के साथ डेटा एकत्र करता है, प्रत्येक साझा आयाम के साथ (उदाहरण के लिए, समय, ऊंचाई (या गहराई) अक्षांश) , और एक द्वारा सेवा की [ Hyrax   OPeNDAP सर्वर](https://www.opendap.org/software/hyrax-data-server) ।
*    [EDDTableFromInvalidCRAFiles](#eddtablefrominvalidcrafiles) से डेटा एकत्र करना NetCDF   (v3)   .nc फ़ाइलें जो CF DSG Contiguous Ragged Array का एक विशिष्ट, अवैध, संस्करण का उपयोग करती हैं (सीआरए) फ़ाइलें हालांकि ERDDAP™ इस फ़ाइल प्रकार का समर्थन करता है, यह एक अमान्य फ़ाइल प्रकार है जिसे कोई भी उपयोग करना शुरू नहीं करना चाहिए। वर्तमान में इस फ़ाइल प्रकार का उपयोग करने वाले समूह को दृढ़ता से उपयोग करने के लिए प्रोत्साहित किया जाता है ERDDAP™ मान्य CF DSG CRA फ़ाइलों को उत्पन्न करने और इन फ़ाइलों का उपयोग बंद करने के लिए।
*    [EDDTableFromJsonlCSVFiles](#eddtablefromjsonlcsvfiles) से डेटा एकत्र करना [JSON लाइन्स CSV फ़ाइलों](https://jsonlines.org/examples/) ।
*    [EDDTableFromMultidimNcFiles](#eddtablefrommultidimncfiles) से डेटा एकत्र करना NetCDF   (v3)   .nc   (या [ .nc एमएल](#ncml-files) ) कई चर के साथ फाइलें, प्रत्येक साझा आयाम के साथ (उदाहरण के लिए, समय, ऊंचाई (या गहराई) अक्षांश) ।
*    [EDDTableFromNcFiles](#eddtablefromncfiles) से डेटा एकत्र करना NetCDF   (v3)   .nc   (या [ .nc एमएल](#ncml-files) ) कई चर के साथ फाइलें, प्रत्येक साझा आयाम के साथ (उदाहरण के लिए, समय, ऊंचाई (या गहराई) अक्षांश) । मौजूदा डेटासेट के लिए इस डेटासेट प्रकार का उपयोग जारी रखना ठीक है, लेकिन नए डेटासेट के लिए हम इसके बजाय EDDTableFromMultidimNcFiles का उपयोग करने की सलाह देते हैं।
*    [EDDTableFromNcCFFiles](#eddtablefromnccffiles) से डेटा एकत्र करना NetCDF   (v3)   .nc   (या [ .nc एमएल](#ncml-files) ) जो फ़ाइलों द्वारा निर्दिष्ट फ़ाइल प्रारूपों में से एक का उपयोग करते हैं [CF Discrete Sampling Geometries (DSG) ](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries) सम्मेलन। लेकिन फ़ाइलों के लिए बहुआयामी CF DSG वेरिएंट का उपयोग करते हुए, उपयोग करते हैं [EDDTableFromMultidimNcFiles](#eddtablefrommultidimncfiles) इसके बजाय।
*    [EDDTableFromNccsvFiles](#eddtablefromnccsvfiles) से डेटा एकत्र करना [एनसीसीएसवी](/docs/user/nccsv-1.00) ASCII फ़ाइलें.
*    [EDDTableFromParquetFiles](#eddtablefromparquetfiles) डेटा को संभालना [लकड़ी](https://parquet.apache.org/) ।
*    [EDDTableFromThreddsFiles](#eddtablefromthreddsfiles)   (डिप्रेषित) फ़ाइलों से डेटा को एकत्रित करता है जिसमें साझा आयामों के साथ कई चर होते हैं, जो एक द्वारा सेवा की जाती है। [थर्ड OPeNDAP सर्वर](https://www.unidata.ucar.edu/software/tds/) ।
*    [EDDTableFrom WFS फ़ाइलें](#eddtablefromwfsfiles)   (डिप्रेषित) सभी डेटा की एक स्थानीय प्रति बनाता है ArcGIS MapServer WFS इसलिए डेटा को फिर से संरक्षित किया जा सकता है ERDDAP™ उपयोगकर्ता

वर्तमान में, कोई अन्य फ़ाइल प्रकार समर्थित नहीं है। लेकिन यह आमतौर पर अन्य फ़ाइल प्रकारों के लिए समर्थन जोड़ने के लिए अपेक्षाकृत आसान है। यदि आपके पास अनुरोध है तो हमसे संपर्क करें। यदि आपका डेटा पुराने फ़ाइल प्रारूप में है तो आप दूर जाना चाहते हैं, तो हम अनुशंसा करते हैं कि फ़ाइलों को परिवर्तित करने के लिए फ़ाइलों को परिवर्तित करें। NetCDF v3 .nc फ़ाइलें (विशेष रूप से .nc फ़ाइलों के साथ [CF Discrete Sampling Geometries (DSG) ](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries) Contiguous ragged Array डेटा संरचना - ERDDAP™ उनमें से बहुत जल्दी डेटा निकाल सकते हैं) । NetCDF एक व्यापक रूप से समर्थित, द्विआधारी प्रारूप है, डेटा तक तेजी से यादृच्छिक पहुंच की अनुमति देता है, और पहले से ही समर्थित है ERDDAP ।

#### FromFiles Details{#fromfiles-details} 
निम्नलिखित जानकारी EDDTableFromFiles के सभी उपवर्गों पर लागू होती है।
##### एकत्रीकरण{#aggregation} 
यह वर्ग स्थानीय फाइलों से डेटा एकत्र करता है। प्रत्येक फ़ाइल एक रखती है (अपेक्षाकृत) डेटा की छोटी तालिका।
    * परिणामस्वरूप डेटासेट दिखाई देता है जैसे कि फ़ाइल की तालिकाओं को जोड़ा गया था। (फ़ाइल # 1 से डेटा की सभी पंक्तियां, साथ ही फ़ाइल #2 से सभी पंक्तियां।) ।
    * सभी फ़ाइलों को निर्दिष्ट चर के सभी नहीं होना चाहिए। यदि किसी दिए गए फ़ाइल में निर्दिष्ट चर नहीं होता है, तो उसके पास निर्दिष्ट चर नहीं होता है। ERDDAP™ आवश्यकतानुसार लापता मूल्यों को जोड़ देगा।
    * सभी फाइलों में चर MUST में समान मान होते हैं। [ add\\_offset ](#scale_factor) , [ missing\\_value ](#missing_value) , [\\_Fill मूल्य](#missing_value) , [ scale\\_factor ](#scale_factor) , और [यूनिट](#units) गुण (यदि कोई हो) । ERDDAP™ चेक, लेकिन यह एक अपूर्ण परीक्षण है - यदि अलग-अलग मान हैं, तो अलग-अलग मान होते हैं। ERDDAP यह नहीं पता कि कौन सही है और इसलिए कौन सी फाइलें अवैध हैं। यदि यह एक समस्या है, तो आप उपयोग करने में सक्षम हो सकते हैं [एनसीएमएल](#ncml-files) या [ NCO ](#netcdf-operators-nco) समस्या को ठीक करने के लिए।
         
##### संपीडित फ़ाइलें{#compressed-files} 
सभी EDDTableFromFiles subclasses के लिए स्रोत डेटा फ़ाइलों को बाहरी रूप से संपीड़ित किया जा सकता है (उदाहरण के लिए .tgz , .tar  .gz , .tar  .gzip , .gz , .gzip , .zip , .bz2 A.Z.) । देखें [बाह्य रूप से संपीड़ित फ़ाइल प्रलेखन](#externally-compressed-files) ।
     
##### कैश्ड फाइल जानकारी{#cached-file-information-1} 
* जब एक EDDTableFromFiles डेटासेट पहले लोड हो गया है, EDDTableFromFiles प्रासंगिक फ़ाइलों के सभी से जानकारी पढ़ता है और टेबल बनाता है (प्रत्येक फ़ाइल के लिए एक पंक्ति) प्रत्येक वैध फ़ाइल और प्रत्येक "बाद" के बारे में जानकारी के साथ (अलग या अमान्य) फ़ाइल
    * टेबल को डिस्क पर भी संग्रहीत किया जाता है, जैसा कि NetCDF v3 .nc फ़ाइलों में *बड़ाParentDirectory* /dataset/ *Last2CharsOfDatasetID* / * datasetID * / फ़ाइलों में नामित:
dirTable .nc   (जो अद्वितीय निर्देशिका नामों की सूची रखता है) ,
फ़ाइल टेबल .nc   (जो प्रत्येक वैध फ़ाइल की जानकारी के साथ तालिका रखता है) ,
बुराफिल .nc   (जो प्रत्येक बुरी फ़ाइल की जानकारी के साथ तालिका रखता है) ।
    * EDDTableFromFiles Dataset तक पहुंच को तेज करने के लिए (लेकिन अधिक स्मृति का उपयोग करने के खर्च पर) , आप उपयोग कर सकते हैं
[&lt;फ़ाइलTableInMemory&gt;true&lt;/fileTableInMemory&gt; (#फ़ाइलटेबलइंमेमोरी)   
बताने के लिए ERDDAP™ मेमोरी में फ़ाइल सूचना तालिका की एक प्रति रखने के लिए।
    * डिस्क पर फ़ाइल सूचना तालिका की प्रतिलिपि तब भी उपयोगी होती है जब ERDDAP™ बंद हो गया है और फिर से शुरू किया गया है: यह EDDTable बचाता है FromFiles से डेटा फ़ाइलों के सभी को फिर से पढ़ने के लिए।
    * जब डेटासेट को पुनः लोड किया जाता है, ERDDAP™ केवल नए फाइलों और फ़ाइलों में डेटा पढ़ने की जरूरत है जो बदल गए हैं।
    * यदि किसी फ़ाइल में अन्य फ़ाइलों से एक अलग संरचना है (उदाहरण के लिए, चर में से एक के लिए एक अलग डेटा प्रकार, या "के लिए एक अलग मान [यूनिट](#units) विशेषता) , ERDDAP फ़ाइल को "bad" फ़ाइलों की सूची में जोड़ता है। फ़ाइल के साथ समस्या के बारे में जानकारी को लिखा जाएगा *बड़ाParentDirectory* /logs/log.txt फ़ाइल।
    * आपको कभी भी इन फ़ाइलों के साथ हटाने या काम करने की आवश्यकता नहीं है। एक अपवाद है: यदि आप अभी भी डेटासेट में बदलाव कर रहे हैं datasets.xml सेटअप, आप इन फ़ाइलों को बल देने के लिए चाहते हैं ERDDAP™ सभी फ़ाइलों को फिर से पढ़ने के लिए क्योंकि फ़ाइलों को अलग-अलग ढंग से पढ़ा / व्याख्या किया जाएगा। यदि आपको कभी इन फ़ाइलों को हटाने की आवश्यकता है, तो आप ऐसा कर सकते हैं जब ERDDAP™ चल रहा है। (फिर सेट [झंडा](/docs/server-admin/additional-information#set-dataset-flag) डेटासेट ASAP को फिर से लोड करने के लिए।) हालांकि, ERDDAP™ आमतौर पर नोटिस करता है कि datasets.xml जानकारी फाइल से मेल नहीं खाती टेबल की जानकारी और स्वचालित रूप से फ़ाइल टेबल को हटा देता है।
    * यदि आप प्रोत्साहित करना चाहते हैं ERDDAP™ संग्रहीत डेटासेट जानकारी अद्यतन करने के लिए (उदाहरण के लिए, यदि आपने अभी जोड़ा है, तो कुछ फ़ाइलों को डेटासेट के डेटा डाइरेक्टरी में बदल दिया है या बदल दिया है।) , उपयोग करें [ध्वज प्रणाली](/docs/server-admin/additional-information#flag) मजबूर होना ERDDAP™ कैश्ड फ़ाइल जानकारी अपडेट करने के लिए।
         
##### हैंडलिंग अनुरोध{#handling-requests-1} 
*    ERDDAP™ सारणीबद्ध डेटा अनुरोध किसी भी परिवर्तनीय पर बाधा डाल सकते हैं।
    * जब डेटा के लिए ग्राहक के अनुरोध को संसाधित किया जाता है, तो EDDTableFromFiles जल्दी से तालिका में देखने के लिए मान्य फ़ाइल जानकारी के साथ देख सकते हैं कि किस फाइल में प्रासंगिक डेटा हो सकता है। उदाहरण के लिए, यदि प्रत्येक स्रोत फ़ाइल में एक निश्चित स्थान buoy के लिए डेटा है, तो EDDTableFromFiles बहुत कुशलतापूर्वक निर्धारित कर सकते हैं कि कौन से फ़ाइलों को दिए गए अक्षांश रेंज और अक्षांश रेंज के भीतर डेटा हो सकता है।
    * क्योंकि वैध फ़ाइल सूचना तालिका में प्रत्येक वैध फ़ाइल के लिए प्रत्येक परिवर्तनीय का न्यूनतम और अधिकतम मान शामिल है, EDDTableFromFiles अक्सर अन्य प्रश्नों को काफी कुशलतापूर्वक संभाल सकते हैं। उदाहरण के लिए, यदि कुछ buoys में एयर प्रेशर सेंसर नहीं होता है, और एक ग्राहक एयरप्रेस के लिए डेटा का अनुरोध करता है&#33;
         
##### कैश्ड फाइल जानकारी को अद्यतन करना{#updating-the-cached-file-information-1} 
जब भी डेटासेट को पुनः लोड किया जाता है, तो कैश्ड फ़ाइल जानकारी अपडेट की जाती है।
    
* डेटासेट को समय-समय पर रीलोड किया जाता है जैसा कि द्वारा निर्धारित किया जाता है&lt;ReloadEveryNMinutes&gt; डेटासेट की जानकारी में datasets.xml ।
* जब भी संभव हो डेटासेट को पुनः लोड किया जाता है ERDDAP™ पता लगाता है कि आपने जोड़ा है, हटा दिया है, [स्पर्श](https://en.wikipedia.org/wiki/Touch_(Unix) ) (फ़ाइल के अंतिम परिवर्तन के लिए संशोधित समय) , या एक डेटाफ़ाइल बदल दिया।
* यदि आप उपयोग करते हैं तो डेटासेट को जल्द से जल्द लोड किया जाता है [ध्वज प्रणाली](/docs/server-admin/additional-information#flag) ।

जब डेटासेट को पुनः लोड किया जाता है, ERDDAP™ वर्तमान में उपलब्ध फ़ाइलों की तुलना कैश्ड फ़ाइल सूचना तालिका में की जाती है। नई फ़ाइलों को वैध फ़ाइलों की तालिका में पढ़ा और जोड़ा जाता है। उन फ़ाइलों को जो अब मौजूद नहीं हैं वे वैध फ़ाइलों की तालिका से हटा दिए गए हैं। जहां फ़ाइल टाइमस्टैम्प बदल गया है, वहां फ़ाइल को पढ़ा जाता है और उनकी जानकारी अपडेट की जाती है। नई तालिकाएं स्मृति में और डिस्क पर पुराने तालिकाओं को प्रतिस्थापित करती हैं।
     
##### बुरा फ़ाइलें{#bad-files-1} 
खराब फ़ाइलों की तालिका और कारणों से फ़ाइलों को खराब घोषित किया गया था (भ्रष्ट फ़ाइल, लापता चर, गलत अक्ष मान आदि।) ईमेल करने के लिए ईमेल किया जाता है सब कुछ ईमेल पता (शायद आप) हर बार डेटासेट को पुनः लोड किया जाता है। आपको जितनी जल्दी हो सके इन फ़ाइलों को प्रतिस्थापित या मरम्मत करनी चाहिए।
     
##### लापता चर{#missing-variables-1} 
यदि कुछ फ़ाइलों में कुछ नहीं है तो कुछ फ़ाइलों में से कुछ नहीं है। dataVariable डेटासेट में परिभाषित datasets.xml वह ठीक है। जब EDDTableFromFiles उन फ़ाइलों में से एक पढ़ता है, तो यह कार्य करेगा जैसे कि फ़ाइल में चर था, लेकिन सभी लापता मूल्यों के साथ।
     
##### रियल टाइम डेटा के पास{#near-real-time-data} 
* EDDTableFromFiles एक विशेष मामले के रूप में हाल के डेटा के लिए अनुरोध का इलाज करता है। समस्या: यदि डेटासेट बनाने वाली फ़ाइलों को अक्सर अद्यतन किया जाता है, तो यह संभावना है कि डेटासेट को हर बार एक फ़ाइल बदलने पर अपडेट नहीं किया जाएगा। इसलिए EDDTableFromFiles परिवर्तित फ़ाइलों के बारे में पता नहीं होगा। (आप उपयोग कर सकते हैं [ध्वज प्रणाली](/docs/server-admin/additional-information#flag) लेकिन इससे हो सकता है ERDDAP™ डेटासेट को लगातार लोड करना। इसलिए ज्यादातर मामलों में, हम इसकी अनुशंसा नहीं करते हैं।) इसके बजाय, EDDTableFromFiles निम्नलिखित प्रणाली से संबंधित है: कब ERDDAP™ पिछले 20 घंटों में डेटा के लिए एक अनुरोध मिलता है (उदाहरण के लिए, 8 घंटे पहले) , ERDDAP™ पिछले 20 घंटों में किसी भी डेटा में मौजूद सभी फ़ाइलों की खोज करेगा। इस प्रकार, ERDDAP™ नवीनतम डेटा खोजने के लिए सभी फ़ाइलों के लिए पूरी तरह से अद्यतन डेटा की आवश्यकता नहीं है। अभी भी सेट होना चाहिए&lt;रीलोड हरNMinutes (#reloadeverynminutes) एक उचित मूल्य पर (उदाहरण के लिए, 60) लेकिन यह छोटा नहीं होना चाहिए (उदाहरण के लिए, 3) ।
     
    *    **अनुशंसित नहीं** फ़ाइलों में निकट-वास्तविक समय डेटा का संगठन: यदि, उदाहरण के लिए, आपके पास एक डेटासेट है जो कई स्टेशनों के लिए डेटा स्टोर करता है (या buoy, या trajectory, ...) कई वर्षों तक, आप फ़ाइलों को व्यवस्थित कर सकते हैं ताकि उदाहरण के लिए, प्रति स्टेशन एक फ़ाइल है। लेकिन फिर, स्टेशन के लिए हर बार नया डेटा आता है, आपको एक बड़ी पुरानी फ़ाइल पढ़ना होगा और एक बड़ी नई फ़ाइल लिखना होगा। कब और कब ERDDAP™ डेटासेट को फिर से लोड करता है, यह ध्यान देता है कि कुछ फ़ाइलों को संशोधित किया गया है, इसलिए यह उन फ़ाइलों को पूरी तरह से पढ़ता है। यह अक्षम है।
         
    *    **अनुशंसित** फ़ाइलों में निकट-वास्तविक समय डेटा का संगठन: उदाहरण के लिए, एक साल के लिए एक स्टेशन / बॉय / ट्रेजेक्टरी के लिए सभी डेटा (या एक महीना) । फिर, जब एक नया डेटम आता है, तो केवल इस साल की फ़ाइल के साथ (या महीना) डेटा प्रभावित होता है।
        
        * सर्वश्रेष्ठ: उपयोग NetCDF v3 .nc असीमित आयाम वाली फाइलें (समय) । फिर, नए डेटा को जोड़ने के लिए, आप पूरी फ़ाइल को पढ़ने और लिखने के बिना नए डेटा को सिर्फ ऐपेंड कर सकते हैं। परिवर्तन बहुत कुशलतापूर्वक और अनिवार्य रूप से परमाणु रूप से किया जाता है, इसलिए फ़ाइल कभी भी असंगत अवस्था में नहीं होती है।
        * अन्यथा: यदि आप उपयोग नहीं करते हैं / नहीं कर सकते हैं .nc असीमित आयाम वाली फाइलें (समय) , फिर, जब आपको नया डेटा जोड़ने की आवश्यकता होती है, तो आपको पूरी प्रभावित फ़ाइल को पढ़ने और लिखने की आवश्यकता होती है (उम्मीद है कि यह सिर्फ एक साल है (या महीना) डेटा का मूल्य) । Fortunately, पिछले वर्षों के लिए फ़ाइलों के सभी (या महीना) उस स्टेशन के लिए अपरिवर्तित रहता है।
        
दोनों मामलों में, जब ERDDAP™ डेटासेट को फिर से लोड करता है, अधिकांश फाइलें अपरिवर्तित हैं; केवल कुछ ही, छोटी फाइलें बदल गई हैं और पढ़ने की आवश्यकता है।
         
##### निदेशक{#directories-1} 
फ़ाइलों को एक निर्देशिका में या किसी निर्देशिका और उसके उपनिर्देशों में किया जा सकता है (लगातार) । यदि फ़ाइलों की एक बड़ी संख्या है (उदाहरण के लिए, &gt; 1,000) ऑपरेटिंग सिस्टम (इस प्रकार EDDTableFromFiles) यदि आप फ़ाइलों को उपनिर्देशों की एक श्रृंखला में स्टोर करते हैं तो अधिक कुशलतापूर्वक काम करेंगे (प्रति वर्ष, या बहुत लगातार फ़ाइलों के साथ डेटासेट के लिए प्रति माह एक) इसलिए, किसी दिए गए निर्देशिका में फ़ाइलों की एक बड़ी संख्या कभी नहीं होती है।
     
##### रिमोट डायरेक्टरीज़ और रेंज अनुरोध{#remote-directories-and-http-range-requests-1} 
*    **रिमोट डायरेक्टरीज़ और रेंज अनुरोध**   (AKA बाइट सर्विंग, बाइट रेंज अनुरोध) --
     EDDGrid से NcFiles, EDDTableFromMultidimNcFiles, EDDTableFromNcFiles, और EDDTableFromNcCFFiles, कभी कभी कभी से डेटा की सेवा कर सकते हैं डेटा से .nc दूरस्थ सर्वर पर फाइलें और HTTP के माध्यम से एक्सेस अगर सर्वर समर्थन करता है [Byte](https://en.wikipedia.org/wiki/Byte_serving) HTTP रेंज अनुरोध के माध्यम से (सेवा करने के लिए HTTP तंत्र) । यह संभव है क्योंकि netcdf-java (जो ERDDAP™ पढ़ने के लिए उपयोग .nc फ़ाइलें) दूरस्थ से डेटा पढ़ने का समर्थन करता है .nc HTTP रेंज अनुरोधों के माध्यम से फ़ाइलें।
    
     **ऐसा मत करो&#33;**   
इसके बजाय, [] का उपयोग करें&lt;कैशFromUrl&gt; प्रणाली (#cachefromurl) ।
    
##### CashFromUrl{#cachefromurl} 
* [ ** &lt;कैशFromUrl&gt; ** ] (#cachefromurl) -
सब EDDGrid FromFiles and all EDDTableFromFiles डाटासेट एक सेट का समर्थन करते हैं जो बताते हैं ERDDAP™ सभी दूरस्थ डेटासेट फ़ाइलों की एक प्रति डाउनलोड करने और बनाए रखने के लिए, या कुछ फ़ाइलों का कैश (आवश्यकतानुसार डाउनलोड करें) । **यह एक अविश्वसनीय रूप से उपयोगी विशेषता है।** 
    * The The most of the&lt;कैशFromUrl&gt; टैग आपको दूरस्थ फ़ाइल सूची से दूरस्थ डेटासेट की फ़ाइलों की सूची के साथ एक URL निर्दिष्ट करने देता है।
        
        * THREDDS में अद्वितीय डेटासेट, उदाहरण के लिए,
            https://data.nodc.noaa.gov/thredds/catalog/aquarius/nodc\\_binned\\_V3.0/monthly/  \\[ 2020-10-21 यह सर्वर अब विश्वसनीय नहीं है। \\] 
        * Unaggregated datasets in Hyrax , उदाहरण के लिए,
             [https://podaac-opendap.jpl.nasa.gov/opendap/allData/ccmp/L3.5a/monthly/flk/](https://podaac-opendap.jpl.nasa.gov/opendap/allData/ccmp/L3.5a/monthly/flk/) 
        * अधिकांश अपाचे जैसी निर्देशिका लिस्टिंग, उदाहरण के लिए,
             [https://www.ncei.noaa.gov/data/global-precipitation-climatology-project-gpcp-daily/](https://www.ncei.noaa.gov/data/global-precipitation-climatology-project-gpcp-daily/) 
        * S3 बाल्टी, उदाहरण के लिए,
             [https://noaa-goes17.s3.us-east-1.amazonaws.com/](https://noaa-goes17.s3.us-east-1.amazonaws.com/)   
हालांकि, इसे एडब्ल्यूएस खाता और अधिक सेटअप की आवश्यकता हो सकती है।
देखें [S3 बाल्टी के साथ काम करना ERDDAP™ ](#working-with-aws-s3-files) ।
इसके अलावा, आपको आमतौर पर कैश का उपयोग करने की आवश्यकता नहीं है S3 बाल्टी में फ़ाइलों के साथ Url अगर फाइलें ASCII फाइलें हैं (उदाहरण के लिए, csv) क्योंकि ERDDAP™ एक धारा के माध्यम से सीधे बाल्टी से डेटा को कुशलतापूर्वक पढ़ सकते हैं।
        
         ERDDAP™ इन फ़ाइलों को डेटासेट में कॉपी या कैश करेगा&lt;फ़ाइलDir&gt; निर्देशिका. यदि आपको किसी अन्य प्रकार की दूरस्थ फ़ाइल सूची के लिए समर्थन की आवश्यकता है (उदाहरण के लिए, FTP) , कृपया अपने अनुरोध को क्रिस पर ईमेल करें। जॉन at noaa.gov.
        
        * के लिए डिफ़ॉल्ट मान&lt;कैशFromUrl&gt; टैग null है। यदि आप मूल्य निर्दिष्ट नहीं करते हैं&lt;कैशFromUrl&gt; टैग, इस डेटासेट के लिए प्रतिलिपि / कैश सिस्टम का उपयोग नहीं किया जाएगा।
        * यदि डेटासेट है&lt;फ़ाइल सेटिंग अन्य है। ERDDAP™ केवल उन फ़ाइलों को डाउनलोड करेगा जो फ़ाइल रेजेक्स से मेल खाते हैं।
        * यदि डेटासेट है&lt;Recursive&gt; सेटिंग सच है और दूरस्थ फाइलें उपनिर्देशों में हैं, ERDDAP™ दूरस्थ उपनिर्देशों में दिखाई देगा जो डेटासेट के मिलान से मेल खाते हैं [&lt;पथRegex&gt; (#pathregex) स्थानीय रूप से इसी निर्देशिका संरचना का निर्माण, और स्थानीय फ़ाइलों को उसी उपनिर्देशों में डाल दिया।
        * जनरेटडाटासेट में यदि आप एक निर्दिष्ट करते हैं, तो Xml&lt;कैशFromUrl&gt; मान, जनरेट डेटासेट XML स्थानीय बना देगा&lt;फ़ाइलDir&gt; निर्देशिका और इसमें 1 दूरस्थ फ़ाइल कॉपी करें। जनगणना तब XML उत्पन्न करेगा datasets.xml उस नमूना फ़ाइल पर आधारित हिस्सा (नमूना निर्दिष्ट करें फ़ाइल) ।
        * यदि डेटा स्रोत रिमोट है ERDDAP™ उपयोग [ EDDGrid सेंध](#eddfromerddap) या [EDDTableFromErddap](#eddfromerddap) इसके बजाय&lt;CashFromUrl&gt;। इस तरह, आपका स्थानीय ERDDAP™ डेटासेट दिखाई देगा लेकिन स्थानीय रूप से किसी भी डेटा को स्टोर करने की आवश्यकता नहीं होगी। उपयोग करने का एकमात्र कारण&lt;कैशFromUrl&gt; दूर से डेटा प्राप्त करने के लिए ERDDAP™ जब आपके पास कुछ अन्य कारण हैं कि आप डेटा फ़ाइलों की स्थानीय प्रति क्यों चाहते हैं। उस मामले में:
            * यह डेटासेट रिमोट पर डेटासेट की सदस्यता लेने की कोशिश करेगा ERDDAP ताकि उस डेटासेट में परिवर्तन इस डेटासेट के ध्वज को बुला सके Url, इस स्थानीय डेटासेट को परिवर्तित दूरस्थ फ़ाइलों को पुनः लोड करने और डाउनलोड करने के लिए बनाता है। इस प्रकार, रिमोट डेटासेट में बदलाव के बाद स्थानीय डेटासेट बहुत जल्द अद्यतन हो जाएगा।
            * आपको दूरस्थ के व्यवस्थापक को ईमेल करना चाहिए ERDDAP™ पूछने के लिए datasets.xml दूरस्थ डेटासेट के लिए ताकि आप अपने स्थानीय में डेटासेट बना सकें ERDDAP™ दूरस्थ में डेटासेट की तरह दिखते हैं ERDDAP ।
        * यदि डेटा स्रोत रिमोट है ERDDAP™ स्थानीय डेटासेट दूरस्थ डेटासेट की सदस्यता लेने की कोशिश करेगा।
            * यदि सदस्यता सफल होती है, तो जब भी रिमोट ERDDAP फिर से लोड हो रहा है और नया डेटा है, यह इस डेटासेट के लिए flagURL से संपर्क करेगा, जिससे यह नए और / या डेटा फ़ाइलों को परिवर्तित करने और डाउनलोड करने के लिए सक्षम होगा।
            * यदि सदस्यता विफल हो जाती है (किसी भी कारण के लिए) यदि आप यह सुनिश्चित करना चाहते हैं कि स्थानीय डेटासेट अप-टू-डेट है, तो आप एक सेट कर सकते हैं [झंडा](/docs/server-admin/additional-information#flag) स्थानीय डेटासेट के लिए, इसलिए यह फिर से लोड हो जाएगा, इसलिए यह नए और / या दूरस्थ डेटा फ़ाइलों को बदल देगा।
        * यदि डेटा स्रोत रिमोट नहीं है ERDDAP : डेटासेट नई के लिए जांच करेगा और / या जब भी यह फिर से लोड हो जाता है तो दूरस्थ फ़ाइलों को बदल देगा। आम तौर पर, यह द्वारा नियंत्रित किया जाता है [&lt;रीलोड हरNMinutes (#reloadeverynminutes) । लेकिन अगर आप जानते हैं कि नई दूरस्थ फाइलें कब हैं, तो आप एक सेट कर सकते हैं [झंडा](/docs/server-admin/additional-information#flag) स्थानीय डेटासेट के लिए, इसलिए यह फिर से लोड हो जाएगा और नए और / या दूरस्थ डेटा फ़ाइलों को बदल देगा। यदि यह नियमित रूप से दिन के एक निश्चित समय पर होता है (उदाहरण के लिए, 7am पर) , आप उपयोग करने के लिए क्रॉन जॉब बना सकते हैं curl ध्वज से संपर्क करें इस डेटासेट के लिए Url, इसलिए यह नए और / या दूरस्थ डेटा फ़ाइलों को परिवर्तित करने के लिए पुनः लोड और जांच करेगा।
    * The The most of the&lt;कैशSizeGB&gt; टैग स्थानीय कैश के आकार को निर्दिष्ट करता है। क्लाउड स्टोरेज सिस्टम जैसे काम करते समय आपको शायद इसका उपयोग करने की आवश्यकता है [अमेज़न S3](https://aws.amazon.com/s3/) जो आमतौर पर इस्तेमाल किया जाने वाला भंडारण प्रणाली है जो का हिस्सा है [अमेज़न वेब सर्विसेज (एडब्ल्यूएस) ](https://aws.amazon.com/) । डिफ़ॉल्ट -1 है।
        * यदि मूल्य है&lt;=0 (उदाहरण के लिए, -1 का डिफ़ॉल्ट मान) ,
             ERDDAP™ डाउनलोड करें और बनाए रखें **प्रतिलिपि** डेटासेट की सभी दूरस्थ डेटासेट की फ़ाइलों की&lt;फ़ाइल
            * यह सेटिंग है जो जब भी संभव हो की सिफारिश की है।
            * हर बार डेटासेट को फिर से लोड किया जाता है, यह दूरस्थ फ़ाइलों और स्थानीय फ़ाइलों के नाम, आकार और अंतिम संशोधित समय की तुलना करता है, और किसी भी दूरस्थ फ़ाइलों को डाउनलोड करता है जो नई हैं या बदल गया है।
            * यदि दूरस्थ सर्वर पर एक फ़ाइल गायब हो जाती है, तो, ERDDAP™ संबंधित स्थानीय फ़ाइल को नष्ट नहीं करेगा (अन्यथा, अगर कुछ दूरस्थ सर्वर के साथ अस्थायी रूप से गलत था, ERDDAP™ कुछ या सभी स्थानीय फ़ाइलों को नष्ट कर सकते हैं&#33;) ।
            * इस सेटिंग के साथ, आमतौर पर आप सेट करेंगे&lt;अद्यतनEveryNMillis&gt; -1 करने के लिए, क्योंकि डेटासेट के बारे में पता है जब यह जगह में नए डेटा फ़ाइलों की नकल की है।
        * यदि मान 0 है,
             ERDDAP™ दूरस्थ डेटासेट से फ़ाइलों को स्थानीय में आवश्यकतानुसार डाउनलोड करेगा **कैश** (dataset)&lt;फ़ाइलDir&gt;) GB की उस निर्दिष्ट संख्या के एक थ्रेसहोल्ड आकार के साथ।
            * कम से कम कई डेटा फ़ाइलों को पकड़ने के लिए कैश काफी बड़ा होना चाहिए।
            * सामान्य तौर पर, कैश जितना बड़ा होता है, उतना बेहतर होता है क्योंकि अगले अनुरोधित डेटा फ़ाइल पहले से ही कैश में होने की संभावना अधिक होती है।
            * जब केवल कैशिंग का उपयोग किया जाना चाहिए ERDDAP™ क्लाउड कंप्यूटिंग सर्वर में चल रहा है (उदाहरण के लिए, एडब्ल्यूएस कम्प्यूट उदाहरण) क्लाउड स्टोरेज सिस्टम में दूरस्थ फाइलें (उदाहरण के लिए, AWS S3) ।
            * जब स्थानीय फ़ाइलों द्वारा उपयोग की जाने वाली डिस्क स्थान कैश से अधिक हो जाती है आकार जीबी ERDDAP™ जल्द ही (शायद) कुछ कैश्ड फ़ाइलों को हटा दें (वर्तमान में, पूर्वोत्तर हाल ही में प्रयुक्त (LRU) एल्गोरिदम) जब तक कि स्थानीय फ़ाइलों द्वारा उपयोग की जाने वाली डिस्क स्पेस तब तक होती है जब तक कि स्थानीय फ़ाइलों द्वारा उपयोग की जाने वाली डिस्क स्पेस का उपयोग किया जाता है।&lt;CacheSizeGB ("goal") । हां, ऐसे मामले हैं जहां LRU बहुत बुरी तरह से प्रदर्शन करता है - कोई सही एल्गोरिथ्म नहीं है।
            *    ERDDAP™ कभी एक कैश्ड फाइल को हटाने की कोशिश नहीं करेगा जो कि कैश्ड फाइल को नष्ट करने की कोशिश करेगा। ERDDAP™ पिछले 10 सेकंड में उपयोग करना शुरू कर दिया। यह कैश सिस्टम से निपटने के लिए एक अपूर्ण प्रणाली है और डेटा फ़ाइल रीडर सिस्टम को केवल ढीले ढंग से एकीकृत किया जा रहा है। इस नियम के कारण, ERDDAP™ इसके लक्ष्य तक पहुंचने के लिए पर्याप्त फ़ाइलों को हटाने में सक्षम नहीं हो सकता है, जिसके मामले में यह लॉग.txt फ़ाइल पर WARNING प्रिंट करेगा, और सिस्टम कैश को ठीक करने की कोशिश में बहुत समय बर्बाद कर देगा, और यह संभव है कि कैश में फ़ाइलों का आकार कैशSizeGB से अधिक हो सकता है। यदि यह कभी होता है, तो उस डेटासेट के लिए एक बड़ा कैशSizeGB सेटिंग का उपयोग करें।
            * वर्तमान में, ERDDAP™ कभी नहीं जांचता कि रिमोट सर्वर में एक फ़ाइल का नया संस्करण है जो स्थानीय कैश में है। यदि आपको इस सुविधा की आवश्यकता है, तो कृपया क्रिस को ईमेल करें। जॉन at noaa.gov.
        * हालांकि उसी टैग के नामों का उपयोग ऐसा हो सकता है कि कॉपी सिस्टम और कैश सिस्टम उसी अंतर्निहित सिस्टम का उपयोग करता है, जो सही नहीं है।
            * सक्रिय रूप से कार्य शुरू होता हैथ्रेड कार्य हर बार नई फ़ाइलों को डाउनलोड करने और परिवर्तित करने के लिए डेटासेट को पुनः लोड किया जाता है। केवल उन फ़ाइलों को जिन्हें वास्तव में स्थानीय निर्देशिका में कॉपी किया गया है, के माध्यम से उपलब्ध हैं ERDDAP™ डेटासेट।
            * कैश सिस्टम को हर बार दूरस्थ फ़ाइल सूची मिलती है जब डेटासेट को फिर से लोड किया जाता है और यह दर्शाता है कि उन सभी फाइलों को उपलब्ध कराया जाता है। ERDDAP™ डेटासेट। दिलचस्प बात यह है कि सभी दूरस्थ फाइलें डेटासेट के / फ़ाइल / वेब पेज में भी दिखाई देती हैं और डाउनलोड करने के लिए उपलब्ध हैं (हालांकि शायद देरी के बाद, फ़ाइल को पहले दूरस्थ सर्वर से स्थानीय कैश में डाउनलोड किया जाता है।) 
        * डेटासेट जो कैश का उपयोग करते हैंSizeGB एक उपयोग से लाभ उठा सकता है [nThread](#nthreads) 1 से अधिक की सेटिंग, क्योंकि यह डेटासेट को एक समय में 1 से अधिक दूरस्थ फ़ाइल डाउनलोड करने में सक्षम होगा।
    * The The most of the&lt;कैशपार्टियलPathRegex&gt; टैग एक शायद ही कभी इस्तेमाल किया जाने वाला टैग है जो डेटासेट के लिए एक विकल्प निर्दिष्ट कर सकता है [&lt;पथRegex&gt; (#pathregex) । डिफ़ॉल्ट शून्य है।
        * यदि आप डिफ़ॉल्ट के माध्यम से पूरे डेटासेट की प्रतिलिपि बना रहे हैं तो केवल इसका उपयोग करें&lt;1 का कैशSizeGB&gt; मान।&lt;कैशSizeGB&gt; 1 के मान, इसे अनदेखा किया जाएगा क्योंकि यह गैर-संवेदनशील है।
        * देखें [email protected]&lt;पथRegex&gt; (#pathregex) रेगेक्स का निर्माण कैसे करें, इसके मार्गदर्शन के लिए।
        * यदि यह निर्दिष्ट है, तो यह हर बार डेटासेट को पुनः लोड किया जाता है, पहली बार एक महीने की शुरुआत में डेटासेट को पुनः लोड किया जाता है।
        * यह तब उपयोगी होता है जब दूरस्थ डेटासेट को सबडायरेक्टरी के भूलभुलैया में संग्रहीत किया जाता है और जब उन फ़ाइलों का विशाल बहुमत शायद ही कभी, अगर कभी, बदल जाता है। (a)&lt;खांसी&gt; नासा&lt;खांसी&gt; उदाहरण के लिए, आप एक निर्दिष्ट कर सकते हैं&lt;कैशपार्टियलPathRegex&gt; जो वर्तमान वर्ष या वर्तमान महीने से मेल खाता है। ये regexes निर्दिष्ट करने के लिए बहुत मुश्किल हैं, क्योंकि सभी आंशिक और पूर्ण पथ नामों को मिलान करना चाहिए&lt;कैशपार्टियलPathRegex&gt; और क्योंकि&lt;कैशपार्टियलPathRegex&gt; दूरस्थ यूआरएल और स्थानीय निर्देशिकाओं के साथ काम करना चाहिए। वास्तविक जीवन उदाहरण है:
```
            <cacheFromUrl>https://data.nodc.noaa.gov/ghrsst/GDS2/L4/GLOB/JPL/MUR/v4.1/</cacheFromUrl>  
            \\>!-- \\[2020-10-21 This server is no longer reliably available.\\] For most types of remote directories, omit the filename (e.g., contents.html for Hyrax). -->  
            <fileDir>/u00/satellite/MUR41/</fileDir>  
            <fileNameRegex>\\*\\.nc</fileNameRegex>  
            <recursive>true</recursive>  
            <pathRegex>.\\*</pathRegex>  
            <cachePartialPathRegex>.\\*/v4\\.1/(|2018/(|01./))</cachePartialPathRegex>  
```
ऊपर नमूना यूआरएल में साल के आधार पर उपनिर्देशिकाओं में फाइलें हैं (उदाहरण के लिए, 2018) वर्ष का दिन (उदाहरण के लिए, 001,002, ..., 365 या 366) ।
ध्यान दें कि&lt;कैशपार्टियलPathRegex&gt; साथ शुरू होता है।
फिर एक विशिष्ट उपनिर्देशिका है जो दूरस्थ यूआरएल और स्थानीय निर्देशिकाओं के लिए आम है, उदाहरण के लिए, /v4\\.1/
उसके पास घोंसले पर कब्जा समूहों की एक श्रृंखला है जहां पहला विकल्प कुछ नहीं है
और दूसरा विकल्प एक विशिष्ट मान है।
            
ऊपर का उदाहरण केवल 2018 के दूसरे 10 दिनों के लिए मैच डायरेक्टरी होगा, उदाहरण के लिए,
            https://data.nodc.noaa.gov/ghrsst/GDS2/L4/GLOB/JPL/MUR/v4.1/2018/010/  \\[ 2020-10-21 यह सर्वर अब विश्वसनीय नहीं है। \\]   
और दिन 011, 012, ..., 019।
             (इसे देखें [रेगेक्स प्रलेखन](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html) और [Regex ट्यूटोरियल](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html) ।)   
यदि आपको मदद की आवश्यकता है&lt;CashPartialPathRegex&lt;CashFromUrl&gt; to Chris. जॉन at noaa.gov.
            
        * एक सामान्य दृष्टिकोण: यदि आप उपयोग करना चाहते हैं&lt;CashPartialPathRegex ERDDAP™ शुरू में सभी फ़ाइलों को डाउनलोड करने के लिए। बाद में ERDDAP™ सभी फ़ाइलों को डाउनलोड किया है, इसे डेटासेट के हिस्से में जोड़ें datasets.xml ।
             
##### हजारों फाइलें{#thousands-of-files} 
यदि आपके डेटासेट में हजारों फाइलें हैं, तो आपके डेटासेट में हजारों फाइलें हैं। ERDDAP™ उस डेटासेट से डेटा के लिए अनुरोधों का जवाब देने के लिए धीमा हो सकता है। यहाँ दो मुद्दे हैं:
 

1. प्रति निर्देशिका फ़ाइलों की संख्या।
आंतरिक रूप से ERDDAP™ इस बात की परवाह किए बिना कि एन फाइलें एक निर्देशिका में हैं या कई निर्देशिकाओं में बिखरे हुए हैं।
     
लेकिन एक समस्या है: किसी दिए गए निर्देशिका में अधिक फाइलें, ऑपरेटिंग सिस्टम धीमी गति से निर्देशिका में फ़ाइलों की सूची वापस करने पर है (प्रति फ़ाइल) to ERDDAP । प्रतिक्रिया समय ओ हो सकता है (n) । यह कहना मुश्किल है कि एक निर्देशिका में कितने फाइलें बहुत ज्यादा हैं, लेकिन 10,000 शायद बहुत ज्यादा है। इसलिए यदि आपका सेटअप बहुत सारी फाइलों को उत्पन्न कर रहा है, तो यहां एक सिफारिश हो सकती है: फ़ाइलों को तार्किक रूप से व्यवस्थित उपनिर्देशों में डाल दें (उदाहरण के लिए, स्टेशन या स्टेशन / वर्ष) ।
    
उपनिर्देशों का उपयोग करने का एक और कारण: यदि कोई उपयोगकर्ता उपयोग करना चाहता है ERDDAP ' "files" सिस्टम स्टेशन एक्स के लिए सबसे पुरानी फ़ाइल का नाम खोजने के लिए, यह तेजी से और अधिक कुशल है यदि फाइलें स्टेशन / वर्ष के उपनिर्देशों में हैं, क्योंकि बहुत कम जानकारी को स्थानांतरित करने की आवश्यकता है।
    
2. फ़ाइलों की कुल संख्या।
सारणीबद्ध डेटासेट के लिए, ERDDAP™ प्रत्येक फ़ाइल में प्रत्येक चर के लिए मानों की श्रेणी का ट्रैक रखता है। जब कोई उपयोगकर्ता अनुरोध करता है, ERDDAP™ सभी फाइलों से सभी डेटा को पढ़ना पड़ता है, जिसमें उपयोगकर्ता के अनुरोध से डेटा मिलान हो सकता है। यदि उपयोगकर्ता सीमित समय से डेटा के लिए पूछता है (उदाहरण के लिए, एक दिन या एक महीने) फिर ERDDAP™ अपने डेटासेट में बहुत सारी फाइलें खोलने की जरूरत नहीं है। लेकिन वहाँ चरम मामलों जहां लगभग हर फ़ाइल मिलान डेटा हो सकता है (उदाहरण के लिए, जब पानी का तापमान = 13.2C) । चूंकि यह लेता है ERDDAP™ थोड़ी देर (आंशिक रूप से एचडीडी पर तलाश का समय, आंशिक रूप से फ़ाइल के हेडर को पढ़ने का समय) बस एक दिए गए फ़ाइल खोलने के लिए (यदि निर्देशिका में बहुत सारी फाइलें हैं) यदि फ़ाइलों की कुल संख्या है, तो एक महत्वपूर्ण समय दंड है ERDDAP™ खोलना बहुत बड़ा है। यहां तक कि 1000 फाइलें खोलने में भी महत्वपूर्ण समय लगता है। इसलिए दैनिक फ़ाइलों को बड़े टुकड़ों में समय-समय पर समेकित करने के लिए लाभ हैं (उदाहरण के लिए, 1 साल के लिए स्टेशन) । मैं समझता हूं कि आप इसे विभिन्न कारणों से नहीं करना चाहते हैं, लेकिन यह बहुत तेजी से जवाब देता है। अत्यधिक मामलों में (उदाहरण के लिए, मैं एक GTSPP डेटासेट से निपटता हूं जिसमें ~ 35 मिलियन स्रोत फाइलें हैं।) , स्रोत फ़ाइलों की एक बड़ी संख्या से डेटा की सेवा करना अव्यवहारिक है क्योंकि ERDDAP सरल प्रश्नों के जवाब में घंटे लग सकते हैं और टन मेमोरी का उपयोग कर सकते हैं। स्रोत फ़ाइलों को एक छोटी संख्या में समेकित करके (जीएसटीपीपी के लिए, मेरे पास अब 720, 2 प्रति माह है) , ERDDAP™ जल्दी से जवाब दे सकते हैं। देखें [लाखों फ़ाइल](#millions-of-files)   
     

एन.बी. सॉलिड स्टेट ड्राइव महान हैं&#33; मदद करने के लिए सबसे तेज़, सबसे सस्ता तरीका ERDDAP™ बड़ी संख्या में सौदा (छोटा) फ़ाइलों को एक ठोस राज्य ड्राइव का उपयोग करना है। देखें [सॉलिड स्टेट ड्राइव महान हैं&#33;](/docs/server-admin/additional-information#solid-state-drives)   
     
##### लाखों फ़ाइल{#millions-of-files} 
* कुछ डेटासेट में लाखों स्रोत फाइल हैं। ERDDAP™ इसे संभाल सकते हैं, लेकिन मिश्रित परिणामों के साथ।
    
    * अनुरोधों के लिए जिसमें केवल उन चरों को शामिल किया गया है जिन्हें सूचीबद्ध किया गया है [&lt; subsetVariables &gt; (#subsetvariables) , ERDDAP™ सभी आवश्यक जानकारी पहले से ही डेटाफ़ाइल से निकाली गई है और एक फ़ाइल में संग्रहीत की गई है, इसलिए यह बहुत जल्दी जवाब दे सकता है।
    * अन्य अनुरोधों के लिए ERDDAP™ डेटासेट को स्कैन कर सकते हैं [कैश्ड फाइल जानकारी](#cached-file-information) और यह जानने के लिए कि केवल कुछ फाइलों में डेटा हो सकता है जो अनुरोध के लिए प्रासंगिक है और इस तरह जल्दी प्रतिक्रिया करता है।
    * लेकिन अन्य अनुरोधों के लिए (उदाहरण के लिए, waterTemperature=18 डिग्री सेल्सियस) जहां किसी भी फ़ाइल में प्रासंगिक डेटा हो सकता है, ERDDAP™ यह देखने के लिए फ़ाइलों की एक बड़ी संख्या को खोलना होगा कि प्रत्येक फ़ाइल में कोई डेटा है जो अनुरोध के लिए प्रासंगिक है। फाइलों को क्रमिक रूप से खोला जाता है। किसी भी ऑपरेटिंग सिस्टम और किसी भी फ़ाइल सिस्टम पर (ठोस राज्य ड्राइव के अलावा अन्य) , यह लंबे समय तक लेता है (इसलिए ERDDAP™ धीरे जवाब) और वास्तव में फाइल सिस्टम को टाई करता है (इसलिए ERDDAP™ अन्य अनुरोधों को धीरे-धीरे जवाब देता है) ।
    
वास्तव में, वहाँ एक समाधान है।
    
    1. एक गैर-सार्वजनिक पर डेटासेट सेट करें ERDDAP™   (आपका व्यक्तिगत कंप्यूटर?) ।
    2. एक स्क्रिप्ट बनाने और चलाने के लिए जो एक श्रृंखला का अनुरोध करता है .nc CF फाइलें, प्रत्येक डेटासेट के बड़े हिस्से के साथ, आमतौर पर एक समय अवधि (उदाहरण के लिए, किसी दिए गए महीने के लिए सभी डेटा) । समय अवधि का चयन करें ताकि परिणामस्वरूप फ़ाइलों के सभी 2GB से कम हो (लेकिन उम्मीद है कि 1GB से अधिक) । यदि डेटासेट में निकट-वास्तविक समय डेटा है, तो वर्तमान समय अवधि के लिए फ़ाइल को फिर से उत्पन्न करने के लिए स्क्रिप्ट चलाएं (उदाहरण के लिए, इस माह) अक्सर (हर 10 मिनट? हर घंटे?) । अनुरोध ERDDAP™ के लिए .nc सीएफ फाइलें एक बनाते हैं NetCDF v3 .nc फ़ाइल जो उपयोग करती है [CF Discrete Sampling Geometries (DSG) ](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries) Contiguous Ragged Array डेटा संरचनाओं).
    3. सेट अप [EDDTableFromNcCFFiles](#eddtablefromnccffiles) अपने सार्वजनिक डेटासेट ERDDAP™ जो डेटा से मिलता है .nc  (CF) फ़ाइलें ERDDAP™ इन फ़ाइलों को जल्दी से निकाल सकते हैं। चूंकि अब दर्जनों या सैकड़ों हैं (इसके बजाय लाखों) फ़ाइलों की, भले ही ERDDAP™ सभी फाइलों को खोलना है, यह जल्द ही कर सकता है।
    
हां, यह प्रणाली कुछ समय और प्रयास करती है। अधिकांश डेटा अनुरोधों को पहले की तुलना में 100 गुना तेजी से संभाला जा सकता है।
     \\[ बॉब को पता था कि यह एक संभावना थी, लेकिन यह केविन ओ'ब्रायन था जिन्होंने पहले ऐसा किया और दिखाया कि यह अच्छी तरह से काम करता है। अब, बॉब जीएसटीपीपी डेटासेट के लिए इसका उपयोग करता है, जिसमें लगभग 18 मिलियन स्रोत फाइलें होती हैं और जो ERDDAP™ अब 500 के बारे में कार्य करता है .nc  (CF) फ़ाइलें \\] 
    
एन.बी. सॉलिड स्टेट ड्राइव महान हैं&#33; मदद करने के लिए सबसे तेज़, सबसे सस्ता तरीका ERDDAP™ बड़ी संख्या में सौदा (छोटा) फ़ाइलों को एक ठोस राज्य ड्राइव का उपयोग करना है। देखें [सॉलिड स्टेट ड्राइव महान हैं&#33;](/docs/server-admin/additional-information#solid-state-drives)   
     
    
##### विशाल फ़ाइल{#huge-files} 
* एकल विशाल डेटा फ़ाइल (विशेष रूप से विशाल ASCII डेटा फ़ाइलों) एक OutOfMemoryError पैदा कर सकता है। यदि यह समस्या है तो यह स्पष्ट होना चाहिए क्योंकि ERDDAP™ डेटासेट लोड करने में विफल हो जाएगा। यदि संभव हो तो समाधान फ़ाइल को एकाधिक फ़ाइलों में विभाजित करना है। आदर्श रूप से, आप फ़ाइल को तार्किक टुकड़ों में विभाजित कर सकते हैं। उदाहरण के लिए, यदि फ़ाइल में 20 महीने का डेटा है, तो इसे 20 फ़ाइलों में विभाजित करें, प्रत्येक में 1 महीने के डेटा के लायक है। लेकिन अगर मुख्य फ़ाइल मनमाने ढंग से विभाजित हो जाती है तो भी फायदे हैं। इस दृष्टिकोण के कई फायदे हैं: a) यह 1/20 तक डेटा फ़ाइलों को पढ़ने के लिए आवश्यक मेमोरी को कम करेगा, क्योंकि केवल एक फ़ाइल एक समय में पढ़ा जाता है। b) अक्सर, ERDDAP™ अनुरोधों के साथ बहुत तेजी से सौदा कर सकते हैं क्योंकि इसे केवल एक या कुछ फ़ाइलों को देखने के लिए दिए गए अनुरोध के लिए डेटा ढूंढना पड़ता है। c) यदि डेटा संग्रह चल रहा है, तो मौजूदा 20 फाइलें अपरिवर्तित रह सकती हैं, और आपको डेटासेट में डेटा के अगले महीने के लायक डेटा जोड़ने के लिए केवल एक, छोटी, नई फ़ाइल को संशोधित करने की आवश्यकता है।
     
##### FTP Trouble/Advice{#ftp-troubleadvice-1} 
* यदि आप FTP नई डेटा फ़ाइलों को करने के लिए ERDDAP™ सर्वर जबकि ERDDAP™ चल रहा है, यह मौका है कि ERDDAP™ FTP प्रक्रिया के दौरान डेटासेट को फिर से लोड किया जाएगा। अक्सर ऐसा होता है जितना आप सोच सकते हैं&#33; यदि ऐसा होता है तो फ़ाइल मान्य होगी। (यह एक वैध नाम है) लेकिन फ़ाइल मान्य नहीं है। अगर ERDDAP™ उस अमान्य फ़ाइल से डेटा पढ़ने की कोशिश करता है, जिसके परिणामस्वरूप त्रुटि फ़ाइल को अमान्य फ़ाइलों की तालिका में जोड़ा जाएगा। यह अच्छा नहीं है। इस समस्या से बचने के लिए, एक अस्थायी फ़ाइल नाम का उपयोग करें जब FTP फ़ाइल है, उदाहरण के लिए, ABC2005 .nc \\_TEMP। फिर, फ़ाइलNameRegex परीक्षण (नीचे देखें) यह संकेत देगा कि यह एक प्रासंगिक फ़ाइल नहीं है। FTP प्रक्रिया पूरी होने के बाद, फ़ाइल को सही नाम में बदलें। नामकरण प्रक्रिया फ़ाइल को तत्काल में प्रासंगिक होने का कारण बनाती है।
    
##### फ़ाइल का नाम निकालें{#file-name-extracts} 
 \\[ यह सुविधा डीपीआरईसीटेड है। कृपया उपयोग करें [\\*\\*\\* फ़ाइलनाम छद्म sourceName ](#filename-sourcenames) इसके बजाय। \\]   
EDDTableFromFiles में प्रत्येक फ़ाइल नाम से स्ट्रिंग निकालने और इसका उपयोग करने के लिए एक प्रणाली होती है। वर्तमान में, इन स्ट्रिंग्स को दिनांक / समय के रूप में व्याख्या करने की कोई व्यवस्था नहीं है। इस प्रणाली को स्थापित करने के लिए कई XML टैग हैं। यदि आपको इस प्रणाली के सभी हिस्से की आवश्यकता नहीं है, तो कृपया इन टैग को निर्दिष्ट न करें या "" मानों का उपयोग न करें।

* PreExtractRegex एक है [नियमित अभिव्यक्ति](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html)   ( [ट्यूटोरियल](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html) ) फ़ाइल नाम की शुरुआत से हटाने के लिए पाठ की पहचान करने के लिए उपयोग किया जाता है। हटाने केवल तभी होता है जब रेगेक्स मैच होता है। यह आमतौर पर "^" से शुरू होता है ताकि फ़ाइल नाम की शुरुआत की जा सके।
* पोस्ट ExtractRegex एक नियमित अभिव्यक्ति है जिसका उपयोग फ़ाइल नाम के अंत से हटाने के लिए पाठ की पहचान करने के लिए किया जाता है। हटाने केवल तभी होता है जब रेगेक्स मैच होता है। यह आमतौर पर फ़ाइल नाम के अंत से मिलान करने के लिए "$" के साथ समाप्त होता है।
* अर्क यदि वर्तमान में, इस नियमित अभिव्यक्ति का उपयोग प्रीएक्सट्रैक्ट रेगेक्स और पोस्टएक्सट्रैक्ट रेगेक्स के बाद किया जाता है ताकि फ़ाइल नाम से निकाला जा सके। (उदाहरण के लिए, stationID ) । यदि रेगेक्स मैच नहीं होता है, तो पूरे फाइल नाम का उपयोग किया जाता है (माइनस प्रीएक्सट्रैक्ट और पोस्ट निकालें) । ".\" का उपयोग करने के लिए पूरी फ़ाइल नाम से मिलान करें जो प्री एक्सट्रैक्ट रेगेक्स और पोस्ट एक्सट्रैक्ट रेगेक्स के बाद छोड़ दिया गया है।
* स्तंभ NameForExtract is डेटा स्तंभ स्रोत नाम के लिए निकाले गए स्ट्रिंग्स. A dataVariable इसके साथ [ sourceName ](#sourcename) होना चाहिए dataVariable सूची (किसी भी डेटा प्रकार के साथ, लेकिन आमतौर पर स्ट्रिंग) ।

उदाहरण के लिए, यदि किसी डेटासेट में XYZAble जैसे नामों के साथ फ़ाइलें हैं .nc XYZBaker .nc XYZCharlie .nc , ..., और आप एक नया परिवर्तनीय बनाना चाहते हैं ( stationID ) जब प्रत्येक फ़ाइल को पढ़ा जाता है तो स्टेशन आईडी मान होगा (Able, Baker, Charlie, ......) फ़ाइल नाम से निकाला गया, आप इन टैग का उपयोग कर सकते हैं:

*   &lt;PreExtractRegex&gt;^ XYZ&lt;/preExtractRegex&gt;
प्रारंभिक ^ एक नियमित अभिव्यक्ति विशेष चरित्र है जो बल देता है ERDDAP™ XYZ को फ़ाइल नाम की शुरुआत में देखने के लिए। यह XYZ का कारण बनता है, यदि फ़ाइल नाम की शुरुआत में पाया जाता है, तो हटाया जाना चाहिए। (उदाहरण के लिए, फ़ाइल नाम XYZAble .nc Able .nc ) ।
*   &lt;postExtractRegex&gt; \\ .nc $&lt;/postExtractRegex&gt;
अंत में $ एक नियमित अभिव्यक्ति विशेष चरित्र है जो बल देता है ERDDAP™ देखने के लिए .nc फ़ाइल नाम के अंत में। चूंकि एक नियमित अभिव्यक्ति विशेष चरित्र है (जो किसी भी चरित्र से मेल खाता है) यह \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ यहाँ (क्योंकि 2E एक अवधि के लिए हेक्साडेसिमल वर्ण संख्या है) । इस कारण .nc यदि फ़ाइल नाम के अंत में पाया जाता है, तो हटाया जाना चाहिए (उदाहरण के लिए, आंशिक फ़ाइल नाम Able .nc Able) ।
*   &lt;Regex&lt;Regex
* नियमित अभिव्यक्ति सभी शेष वर्णों से मेल खाती है (उदाहरण के लिए, आंशिक फ़ाइल नाम Able पहली फ़ाइल के लिए निकालने बन जाता है) ।
*   &lt;स्तंभNameForExtract&gt; stationID &lt;/columnNameForExtract&gt;
यह बताता है ERDDAP™ एक नया स्रोत स्तंभ बनाने के लिए बुलाया stationID प्रत्येक फ़ाइल को पढ़ने पर। किसी दिए गए फ़ाइल के लिए डेटा की हर पंक्ति में उसके फ़ाइल नाम से निकाला गया पाठ होगा (उदाहरण के लिए, Able) मूल्य के रूप में stationID स्तंभ।

ज्यादातर मामलों में, इन निकालने वाले टैग के लिए कई मान हैं जो समान परिणाम उत्पन्न करेंगे - नियमित अभिव्यक्ति बहुत लचीला है। लेकिन कुछ मामलों में, वांछित परिणाम प्राप्त करने का सिर्फ एक तरीका है।
     
##### Pseudo sourceName s{#pseudo-sourcenames} 
प्रत्येक डेटासेट में प्रत्येक परिवर्तनीय ERDDAP™ [a]&lt; sourceName &gt; (#sourcename) जो परिवर्तनीय के लिए स्रोत के नाम को निर्दिष्ट करता है। EDDTableFromFiles कुछ छद्म समर्थन करता है sourceName जो कुछ अन्य जगहों से मूल्य निकालते हैं (उदाहरण के लिए, फ़ाइल का नाम या वैश्विक विशेषता का मूल्य) और उस मान को बढ़ावा देना डेटा के उस हिस्से के लिए स्थिर मूल्यों का एक स्तंभ होना (उदाहरण के लिए, उस फ़ाइल के डेटा की तालिका) । इन चरों के लिए, आपको इसके माध्यम से चर के डेटा प्रकार को निर्दिष्ट करना होगा [&lt;Datatype&gt; (#datatype) टैग यदि निकाली गई जानकारी एक डेटटाइम स्ट्रिंग है, तो आप डेटटाइम स्ट्रिंग के प्रारूप को निर्दिष्ट करते हैं [यूनिट विशेषता](#string-time-units) । छद्म sourceName विकल्प हैं:
 
###### वैश्विक: sourceName s{#global-sourcenames} 
प्रत्येक स्रोत डेटा फ़ाइल में एक वैश्विक मेटाडाटा विशेषता को डेटा का एक स्तंभ माना जा सकता है। यदि एक चर है&lt; sourceName &gt; प्रारूप है
```
        <sourceName>global:*attributeName*</sourceName>
```
जब ERDDAP™ डेटा को एक फ़ाइल से पढ़ रहा है, ERDDAP™ उस नाम की वैश्विक विशेषता की तलाश करेंगे (उदाहरण के लिए, पीआई) और विशेषता के मूल्य से भरा एक स्तंभ बनाते हैं। यह उपयोगी है जब विशेषता में विभिन्न स्रोत फ़ाइलों में अलग-अलग मान होते हैं, क्योंकि अन्यथा, उपयोगकर्ता केवल संपूर्ण डेटासेट के लिए उन मूल्यों में से एक देखेंगे। उदाहरण के लिए,
```
        <sourceName>global:PI</sourceName>
```
जब आप डेटा होने की विशेषता को बढ़ावा देते हैं, ERDDAP™ इसी विशेषता को हटा देता है। यह उपयुक्त है क्योंकि मूल्य संभवतः प्रत्येक फ़ाइल में अलग है; जबकि कुल डेटासेट में ERDDAP™ यह केवल एक ही मूल्य होगा। यदि आप चाहते हैं, तो आप जोड़कर पूरे डेटासेट के लिए विशेषता के लिए एक नया मूल्य जोड़ सकते हैं&lt;att name *विशेषता नाम* &gt;&gt; *नया मूल्य* &lt;/att&gt; डेटासेट के वैश्विक [&lt; addAttributes &gt; (#addattributs) । वैश्विक विशेषताओं के लिए ERDDAP™ आवश्यकता है, उदाहरण के लिए, संस्था, आप विशेषता के लिए एक नया मूल्य जोड़ सकते हैं।
     
###### चर: sourceName s{#variable-sourcenames} 
प्रत्येक फ़ाइल में एक परिवर्तनीय मेटाडाटा विशेषता को डेटा का एक स्तंभ माना जा सकता है। यदि एक चर है&lt; [ sourceName ](#sourcename) \\&gt; प्रारूप है
```
        <sourceName>variable:*variableName*:*attributeName*<sourceName>
```
जब ERDDAP™ डेटा को एक फ़ाइल से पढ़ रहा है, ERDDAP™ निर्दिष्ट विशेषता के लिए दिखेगा (उदाहरण के लिए, ID) निर्दिष्ट चर (उदाहरण के लिए, साधन) और विशेषता के मूल्य से भरा एक स्तंभ बनाते हैं। माता-पिता चर (उदाहरण के लिए, साधन) नहीं होना चाहिए dataVariable में डेटासेट की परिभाषा में शामिल ERDDAP । उदाहरण के लिए,
```
        <sourceName>variable:instrument:ID</sourceName>
```
यह उपयोगी है जब विशेषता में विभिन्न स्रोत फ़ाइलों में अलग-अलग मान होते हैं, क्योंकि अन्यथा, उपयोगकर्ता केवल संपूर्ण डेटासेट के लिए उन मूल्यों में से एक देखेंगे।

जब आप डेटा होने की विशेषता को बढ़ावा देते हैं, ERDDAP™ इसी विशेषता को हटा देता है। यह उपयुक्त है क्योंकि मूल्य संभवतः प्रत्येक फ़ाइल में अलग है; जबकि कुल डेटासेट में ERDDAP™ यह केवल एक ही मूल्य होगा। यदि आप चाहते हैं, तो आप जोड़कर पूरे डेटासेट के लिए विशेषता के लिए एक नया मूल्य जोड़ सकते हैं&lt;att name *विशेषता नाम* &gt;&gt; *नया मूल्य* &lt;/att&gt; चर के लिए [&lt; addAttributes &gt; (#addattributs) । विशेषताओं के लिए ERDDAP™ आवश्यकता है, उदाहरण के लिए, ioos\\_category   (अपने सेटअप के आधार पर) , आप विशेषता के लिए एक नया मूल्य जोड़ सकते हैं।
        
###### फ़ाइल नाम sourceName s{#filename-sourcenames} 
आप एक फ़ाइल की फ़ाइल नाम का हिस्सा निकाल सकते हैं और इसे बढ़ावा दे सकते हैं कि डेटा का एक स्तंभ है। इस छद्म के लिए प्रारूप [&lt; sourceName &gt; (#sourcename) है
```
        <sourceName>\\*\\*\\*fileName,*regex*,*captureGroupNumber*</sourceName>
```
उदाहरण के लिए,
```
        <sourceName>\\*\\*\\*fileName,A(\\d{12})\\.slcpV1.nc,1</sourceName>
```
जब EDDTableFromFiles एक फ़ाइल से डेटा पढ़ रहा है, तो यह सुनिश्चित करेगा कि फ़ाइल नाम (उदाहरण के लिए, A201807041442.slcpV1 .nc ) निर्दिष्ट नियमित अभिव्यक्ति से मेल खाता है ("regex") और निर्दिष्ट निकालने (इस मामले में, पहला) समूह (जो माता-पिता से घिरा हुआ हिस्सा है) उदाहरण के लिए, "201807041442"। (इसे देखें [रेगेक्स प्रलेखन](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html) और [Regex ट्यूटोरियल](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html) ।) रेगेक्स को किसी स्ट्रिंग के रूप में निर्दिष्ट किया जा सकता है जिसके साथ या आसपास के उद्धरण के बिना। यदि रेगेक्स को आसपास के उद्धरणों के साथ स्ट्रिंग के रूप में निर्दिष्ट किया जाता है, तो स्ट्रिंग को होना चाहिए। [JSON-style स्ट्रिंग](https://www.json.org/json-en.html)   (विशेष पात्रों के साथ बच) । आम तौर पर कब्जा समूह संख्या 1 है (पहला कैप्चर समूह) लेकिन किसी भी नंबर हो सकता है।
     
###### पथनाम sourceName s{#pathname-sourcenames} 
आप फ़ाइल के पूर्ण पथ का हिस्सा निकाल सकते हैं नाम (/निर्देशिका/fileName.ext) और इसे बढ़ावा देने के लिए डेटा का एक स्तंभ होना। इस छद्म के लिए प्रारूप [&lt; sourceName &gt; (#sourcename) है
```
        <sourceName>\\*\\*\\*pathName,*regex*,*captureGroupNumber*<sourceName>
```
उदाहरण के लिए,
```
        <sourceName>\\*\\*\\*pathName,/data/myDatasetID/(\\[A-Z0-9\\]\\*)/B(\\d{12}).nc,1</sourceName>
```
जब EDDTableFromFiles एक फ़ाइल से डेटा पढ़ रहा है, तो यह सुनिश्चित करेगा कि पूरा पथनाम (उदाहरण के लिए, /data/myDatasetID/BAY17/B201807041442 .nc । इस परीक्षण के लिए, निर्देशिका विभाजक हमेशा होगा '/' कभी नहीं ') निर्दिष्ट नियमित अभिव्यक्ति से मेल खाता है ("regex") और निर्दिष्ट निकालने (इस मामले में, पहला) समूह (जो माता-पिता से घिरा हुआ हिस्सा है) उदाहरण के लिए, "BAY17"। (इसे देखें [रेगेक्स प्रलेखन](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html) और [Regex ट्यूटोरियल](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html) ।) रेगेक्स को किसी स्ट्रिंग के रूप में निर्दिष्ट किया जा सकता है जिसके साथ या आसपास के उद्धरण के बिना। यदि रेगेक्स को आसपास के उद्धरणों के साथ स्ट्रिंग के रूप में निर्दिष्ट किया गया है, तो स्ट्रिंग होना चाहिए [JSON-style स्ट्रिंग](https://www.json.org/json-en.html)   (विशेष पात्रों के साथ बच) । आम तौर पर कब्जा समूह संख्या 1 है (पहला कैप्चर समूह) लेकिन किसी भी नंबर हो सकता है।
         
##### "0 फाइलें" त्रुटि संदेश{#0-files-error-message-2} 
* यदि आप दौड़ते हैं [जनरेट DatasetXml](#generatedatasetsxml) या [दास](#dasdds) यदि आप एक EDDTableFrom लोड करने की कोशिश करते हैं, या यदि आप EDDTableFrom लोड करने की कोशिश करते हैं ... में फ़ाइलें डेटासेट ERDDAP™ , और आपको "0 फाइलें" त्रुटि संदेश मिलता है जो दर्शाता है कि ERDDAP™ निर्देशिका में 0 मिलान फ़ाइलों को पाया (जब आपको लगता है कि उस निर्देशिका में फ़ाइलों को मिलान करना है) :
    * जाँच करें कि वास्तव में फ़ाइलें उस निर्देशिका में हैं।
    * निर्देशिका नाम की वर्तनी की जाँच करें।
    * फ़ाइल NameRegex की जाँच करें। वास्तव में, वास्तव में regexes के साथ गलतियों को करना आसान है। परीक्षण प्रयोजनों के लिए, रेगेक्स की कोशिश करें। (इसे देखें [रेगेक्स प्रलेखन](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html) और [Regex ट्यूटोरियल](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html) ।) 
    * जांचें कि वह उपयोगकर्ता जो प्रोग्राम चला रहा है (उदाहरण के लिए, उपयोगकर्ता=tomcat (?) टॉमकैट के लिए ERDDAP ) उन फ़ाइलों के लिए 'रीड' अनुमति है।
    * कुछ ऑपरेटिंग सिस्टम में (उदाहरण के लिए, SELinux) और सिस्टम सेटिंग्स के आधार पर, जो उपयोगकर्ता ने कार्यक्रम को चलाने के लिए फ़ाइलों की निर्देशिका के लिए अग्रणी डायरेक्टरी की पूरी श्रृंखला के लिए 'रीड' अनुमति होनी चाहिए।
         
##### मानकीकरण क्या{#standardizewhat} 
* जब EDDTableFromFiles का कोई भी उपश्रेणी किसी दिए गए चर के लिए स्रोत फ़ाइलों का एक सेट एकत्र कर रहा है, तो सभी स्रोत फ़ाइलों MUST के पास कई विशेषताओं के लिए समान विशेषता मान हैं: scale\\_factor , add\\_offset , \\_Unsigned, missing\\_value , \\_FillValue, और इकाइयों). इसके बारे में सोचें: यदि एक फ़ाइल में विंडस्पीड यूनिट = नॉट्स है और किसी अन्य में विंडस्पीड यूनिट = m/s है, तो दो फाइलों से डेटा मानों को समान डेटासेट में शामिल नहीं किया जाना चाहिए। इसलिए, जब EDDTableFromFiles पहले डेटासेट बनाता है, तो यह एक फ़ाइल से विशेषता मान पढ़ता है, फिर उन सभी फाइलों को अस्वीकार करता है जिनके पास उन महत्वपूर्ण विशेषताओं के लिए अलग-अलग मान हैं। फ़ाइलों के अधिकांश संग्रह के लिए, यह एक समस्या नहीं है क्योंकि सभी चरों की विशेषताएं सुसंगत हैं। हालांकि, फ़ाइलों के अन्य संग्रहों के लिए, यह 1%, 10%, 50%, 90% या यहां तक कि 99% फाइलों को "bad" फ़ाइलों के रूप में अस्वीकार कर दिया जा सकता है। यह परेशानी है।
    
EDDTableFrom फ़ाइलों को इस समस्या से निपटने के लिए एक प्रणाली है: मानकीकरण क्या? मानकीकरण क्या सेटिंग EDDTableFromFiles को फाइल को मानकीकृत करने के लिए बताती है जैसे ही यह उन्हें पढ़ता है, इससे पहले कि EDDTableFromFiles यह देखने के लिए कि वे सुसंगत हैं या नहीं।
    
फ्लिप साइड है: यदि डेटासेट में इस समस्या को नहीं है, तो मानकीकरण का उपयोग न करें क्या? मानकीकरण जोखिम क्या है (नीचे चर्चा) और अक्षमता। इसलिए यदि आपको वास्तव में मानकीकरण की सुविधाओं की आवश्यकता नहीं है क्या, संभावित जोखिम और अक्षमता का सामना करने की कोई आवश्यकता नहीं है। सबसे बड़ी अक्षमता है: जब विभिन्न मानकीकरण डेटासेट द्वारा किस विकल्प का उपयोग किया जाता है, इसका मतलब है कि स्रोत फाइलें डेटा को काफी अलग तरीके से स्टोर कर रही हैं। (उदाहरण के लिए, विभिन्न के साथ scale\\_factor और add\\_offset विभिन्न प्रारूपों का उपयोग करके या समय स्ट्रिंग के साथ) । इस प्रकार, किसी उपयोगकर्ता अनुरोध में दिए गए बाधा के लिए, कोई रास्ता नहीं है ERDDAP™ एक एकल स्रोत स्तर की बाधा बनाने के लिए जिसे सभी स्रोत फ़ाइलों पर लागू किया जा सकता है। तो ERDDAP™ केवल प्रभावित बाधाओं को उच्च स्तर पर लागू कर सकते हैं। तो ERDDAP™ उच्च, गंतव्य स्तर की बाधाओं को लागू करने से पहले डेटा को अधिक फ़ाइलों से पढ़ना पड़ता है। इसलिए डेटासेट का अनुरोध करता है जो मानकीकरण का उपयोग करता है अब क्या संसाधित किया जा सकता है।
    
इस प्रणाली का उपयोग करने के लिए आपको निर्दिष्ट करना होगा
```
    <standardizeWhat>*standardizeWhat*</standardizeWhat>  
```
में [ datasets.xml EDDTableFrom के लिए ... फ़ाइलें](#eddtablefromfiles-skeleton-xml) (साथ)&lt;डेटासेट&gt; टैग।
    
The The most of the *मानकीकरण क्या* मान निर्दिष्ट करता है कि कौन बदलता है EDDTableFromFiles को लागू करने की कोशिश करनी चाहिए। परिवर्तन कुछ संयोजन के योग हैं:
    
1. अनपैक
यह फ़ाइलों में संख्यात्मक स्तंभों को मानकीकृत करने के लिए कई सामान्य और सुरक्षित संचालन करता है:
    * अगर scale\\_factor और/or add\\_offset विशेषताएँ मौजूद हैं, उन्हें हटा दें और उन्हें डेटा मूल्यों को अनपैक करने के लिए लागू करें।
    * Unpacked विशेषताओं (उदाहरण के लिए, वास्तविक \\min, वास्तविक \\max, actual\\_range , data\\_min , data\\_max , डेटा \\_range, valid\\_min , valid\\_max , valid\\_range ) यदि वेरिएबल पैक किया गया था, और यदि विशेषता मूल्यों को पैक किया गया था, तो, (यह मुश्किल है, लेकिन वास्तव में विश्वसनीय) ।
    * यदि \\_FillValue और/or missing\\_value मौजूद हैं, उन डेटा मूल्यों को परिवर्तित करने के लिए ERDDAP "मानक" लापता मान: पूर्णांक प्रकारों के लिए मैक्स \\_VALUE (उदाहरण के लिए, बाइट्स के लिए 127, लघु के लिए 32,767 और इंट्स के लिए 2,147,483,647, 9223372036854807 लंबे समय तक) और डबल्स और फ्लोट्स के लिए NaN।
    * पुराने \\FillValue और/or निकालें missing\\_value गुण (यदि कोई हो) और उन्हें सिर्फ \\_FillValue= के साथ बदलें \\[ The number of the ERDDAP™ मानक लापता मान \\] ।
         
2. मानकीकृत न्यूमेरिक टाइम्स
यदि एक संख्यात्मक स्तंभ में CF-style संख्यात्मक समय इकाई है (" *समय* बाद में *बेसटाइम* ", उदाहरण के लिए, "दिन 1900-01-01 के बाद से") यह तारीख बदलता है समय मूल्यों में "seconds since 1970-01-01T00:00:00Z" यह इंगित करने के लिए इकाइयों को मान और बदल देता है।
यदि यह चुना गया है और वहाँ एक मौका है कि इस चर है scale\\_factor या add\\_offset , #1 MUST को भी चुना जाना चाहिए।
     
3. स्ट्रिंग लागू करें missing\\_value   
यदि एक स्ट्रिंग कॉलम में \\_FillValue और/or है missing\\_value गुण, यह उन मूल्यों को "" में बदल देता है और विशेषताओं को हटा देता है।
     
4. न्यूमेरिक का पता लगाएं missing\\_value   
यदि एक संख्यात्मक स्तंभ में \\_FillValue या नहीं है missing\\_value गुण, यह एक अपरिभाषित संख्यात्मक की पहचान करने की कोशिश करता है missing\\_value   (उदाहरण के लिए, -999, 9999, 1e37f) और इसके उदाहरणों को "मानक" मानों में परिवर्तित करें (पूर्णांक प्रकार के लिए मैक्स \\_VALUE, और डबल्स और फ्लोट्स के लिए NAN) ।
     **इस विकल्प का जोखिम है:** यदि सबसे बड़ा या छोटा वैध डेटा मान एक लापता मान की तरह दिखता है (उदाहरण के लिए, 999) तब उन वैध डेटा मूल्यों को लापता मूल्यों में परिवर्तित किया जाएगा (उदाहरण के लिए, नान) ।
     
5. स्ट्रिंग बदलें "N/A" to ""
प्रत्येक स्ट्रिंग कॉलम के लिए, कई स्ट्रिंग्स को आमतौर पर "" के लिए एक लापता स्ट्रिंग मान को इंगित करने के लिए उपयोग किया जाता है। वर्तमान में, यह ".", "...", "-", "?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? स्ट्रिंग खोज केस-असंवेदनशील है और स्ट्रिंग्स के बाद लागू होती है। "nd" और "other" विशेष रूप से सूची में नहीं हैं।
     **इस विकल्प का जोखिम है:** जिन स्ट्रिंग्स को आप मानते हैं कि वे वैध मानों को "" में परिवर्तित किया जा सकता है।
     
6. स्ट्रिंग ISO 8601 DateTimes के लिए मानकीकृत
प्रत्येक स्ट्रिंग कॉलम के लिए, पूरी तरह से संख्यात्मक स्ट्रिंग डेटटाइम को बदलने की कोशिश करें (उदाहरण के लिए, "जनवरी 2, 2018") ISO 8601 स्ट्रिंग dateTimes (2018-01-02) ।
     **नोट** कि स्तंभ के लिए सभी डेटा मान उसी प्रारूप का उपयोग करना चाहिए, अन्यथा, यह विकल्प किसी दिए गए कॉलम में कोई बदलाव नहीं करेगा।
     **इस विकल्प का जोखिम है:** यदि स्ट्रिंग मूल्यों के साथ एक स्तंभ होता है जो सिर्फ एक सामान्य तारीख की तरह दिखने वाला होता है टाइम प्रारूप, उन्हें ISO 8601 स्ट्रिंग डेटटाइम्स में परिवर्तित किया जाएगा।
     
7. आईएसओ 8601 डेटटाइम्स के लिए कॉम्पैक्ट डेटटाइम्स को मानकीकृत करें
प्रत्येक स्ट्रिंग या पूर्णांक-प्रकार के कॉलम के लिए, पूरी तरह से संख्यात्मक स्ट्रिंग डेटटाइम्स को बदलने की कोशिश करें (उदाहरण के लिए, "20180102") ISO 8601 स्ट्रिंग dateTimes (2018-01-02) ।
     **नोट** कि स्तंभ के लिए सभी डेटा मान उसी प्रारूप का उपयोग करना चाहिए, अन्यथा, यह विकल्प किसी दिए गए कॉलम में कोई बदलाव नहीं करेगा।
     **इस विकल्प का जोखिम है:** यदि मूल्य के साथ एक स्तंभ है जो कॉम्पैक्ट तारीख नहीं है टाइम्स लेकिन कॉम्पैक्ट डेटटाइम्स की तरह दिखते हैं, उन्हें आईएसओ 8601 स्ट्रिंग डेटटाइम्स में परिवर्तित किया जाएगा।
     
8. मानक इकाइयों
यह प्रत्येक चर के लिए इकाइयों स्ट्रिंग को मानकीकृत करने की कोशिश करता है। उदाहरण के लिए, "मीटर प्रति सेकंड", "मीटर / सेकंड", "m.s^-1" , "m s-1" सभी को "m.s-1" में परिवर्तित किया जाएगा। यह डेटा मान नहीं बदलता है। यह वैध के लिए अच्छी तरह से काम करता है UDUNITS इकाइयों के तार, लेकिन अमान्य या जटिल स्ट्रिंग्स के साथ समस्याएं हो सकती हैं। आप विशिष्ट से जोड़े में निर्दिष्ट करके समस्याओं से निपट सकते हैं&lt;StandardizeUdunits&gt; में ERDDAP '
     \\[ tomcat \\] / webapps/erddap/WEB-INF/classes/gov/noaa/pfel/erddap/util/message.xml फ़ाइल. कृपया किसी भी बदलाव को ईमेल करें जिसे आप क्रिस में बनाते हैं। जॉन noaa.gov पर इसलिए उन्हें डिफ़ॉल्ट संदेश.xml में शामिल किया जा सकता है।
     **इस विकल्प का जोखिम है:** यह कुछ जटिल या अमान्य इकाइयों को जोड़ सकता है; हालांकि, यदि वे होते हैं तो आप समस्याओं को दूर करने के लिए ऊपर वर्णित वर्क-अराउंड का उपयोग कर सकते हैं।
         
    
मानकीकरण का डिफ़ॉल्ट मान 0 क्या है, जो कुछ नहीं करता है।

यदि आप मानकीकरण का मान बदलते हैं क्या, अगली बार डेटासेट को पुनः लोड किया जाता है, ERDDAP™ प्रत्येक फ़ाइल के बारे में जानकारी के साथ मिनी-डाटाबेस का पुनर्निर्माण करने के लिए डेटासेट के लिए सभी डेटा फ़ाइलों को फिर से पढ़ेगा। यदि डेटासेट में बहुत सारी फाइलें हैं, तो यह लंबे समय तक ले जाएगा।
    
नोट्स:

* एक मुश्किल बात है -
मानकीकरण क्या सेटिंग स्रोत फ़ाइल में सभी स्तंभों के लिए प्रयोग किया जाता है। इसलिए, उदाहरण के लिए, #2048 का उपयोग सफलतापूर्वक आईएसओ 8601 स्ट्रिंग डेटटाइम्स में कॉम्पैक्ट स्ट्रिंग डेटटाइम्स के एक स्तंभ को परिवर्तित कर सकता है, लेकिन यह गलती से स्ट्रिंग्स के साथ एक कॉलम को परिवर्तित कर सकता है जो सिर्फ कॉम्पैक्ट डेटटाइम्स की तरह दिखने वाला होता है।
     
*    datasets.xml और GenerateDatasets Xml -
सेटिंग्स को सही करने के लिए विशेष रूप से मुश्किल है datasets.xml अपने डेटासेट को उस तरीके से काम करने के लिए जिसे आप चाहते हैं। सबसे अच्छा दृष्टिकोण (हमेशा) है:
    1. उपयोग [जनरेट DatasetXml](#generatedatasetsxml) मानकीकृत मूल्य निर्दिष्ट करें क्या आप उपयोग करना चाहते हैं?
    2. उपयोग [दास](#dasdds) यह सुनिश्चित करने के लिए कि डेटासेट सही ढंग से लोड हो रहा है और मानकीकरण को प्रतिबिंबित करता है आप किस सेटिंग को निर्दिष्ट करते हैं।
    3. जब यह होता है तो डेटासेट को हाथ से टेस्ट करें ERDDAP™ यह सुनिश्चित करने के लिए कि प्रभावित चर उम्मीद के रूप में काम करते हैं।
         
* जोखिम
विकल्प # 256 और ऊपर जोखिम भरा है, यानी, एक बड़ा मौका है कि ERDDAP™ ऐसा परिवर्तन होगा जिसे नहीं बनाया जाना चाहिए। उदाहरण के लिए, विकल्प #2048 गलती से स्टेशन आईडी स्ट्रिंग्स के साथ एक चर को परिवर्तित कर सकता है जो सभी सिर्फ ISO 8601 "कॉम्पैक्ट" तारीख देखने के लिए होते हैं। (उदाहरण के लिए, 20180102) ISO 8601 में "extended" तारीख (2018-01-02) ।
     
* बदलाव के बाद धीमा --
मानकीकरण का मूल्य क्या डेटा मानों को बदलता है कि EDDTableFromFiles प्रत्येक डेटा फ़ाइल के लिए देखता है, यदि आप मानकीकृत बदलते हैं क्या सेटिंग, EDDTableFromFiles प्रत्येक फ़ाइल के बारे में सभी कैश्ड जानकारी को फेंक देगा (जिसमें प्रत्येक फ़ाइल में प्रत्येक डेटा चर के लिए मिनट और अधिकतम शामिल है) और प्रत्येक डेटा फ़ाइल को फिर से पढ़ें। यदि किसी डेटासेट में बड़ी संख्या में फाइलें हैं, तो यह बहुत समय लेने वाला हो सकता है, इसलिए पहली बार डेटासेट के लिए डेटासेट को फिर से लोड करने का समय लगेगा। ERDDAP™ बदलने के बाद इसे फिर से लोड करें।
     
* हेरिस्टिक्स -
विकल्प # 256 और ऊपर अपने परिवर्तन करने के लिए हेरिस्टिक्स का उपयोग करें। यदि आप एक ऐसी स्थिति में आते हैं जहां हेरिस्टिक्स खराब निर्णय लेते हैं, तो कृपया क्रिस को समस्या का वर्णन ईमेल करें। जॉन नोआ में। सरकार तो हम heuristics में सुधार कर सकते हैं।
     
* विकल्प
यदि मानकीकरण में से एक विकल्प दिए गए डेटासेट के लिए कोई समस्या हल नहीं करता है, तो आप समस्या को हल कर सकते हैं [ .nc मिली फाइल](#ncml-files) प्रत्येक डेटा फ़ाइल को समांतरित करने और फ़ाइलों में चीजों में बदलाव को परिभाषित करने के लिए ताकि फ़ाइलों के अनुरूप हो। फिर, EDDTableFrom को बताएं ... फ़ाइल डेटासेट को कुल करने के लिए .nc मिली फ़ाइलें।
    
या, उपयोग [ NCO ](#netcdf-operators-nco) वास्तव में फ़ाइलों में बदलाव करने के लिए ताकि फ़ाइलों को संगत कर रहे हैं।
        
##### वर्ष के लिए अलग कॉलम, महीना, दिनांक, समय, मिनट, दूसरा{#separate-columns-for-year-month-date-hour-minute-second} 
यह सारणीबद्ध डेटा फ़ाइलों के लिए काफी आम है, जो साल, महीने, तारीख, घंटे, मिनट, दूसरे के लिए अलग-अलग कॉलम हैं। पहले ERDDAP™ v2.10, एकमात्र समाधान उन स्तंभों को एकीकृत समय कॉलम में जोड़ने के लिए डेटा फ़ाइल को संपादित करना था। साथ ERDDAP™ 2.10+, आप उपयोग कर सकते हैं
[&lt; sourceName &gt;= *अभिव्यक्ति* &lt; sourceName &gt; (#sourcename) बताने के लिए ERDDAP™ कैसे एक एकीकृत समय स्तंभ बनाने के लिए स्रोत स्तंभों को गठबंधन करने के लिए, इसलिए अब आपको स्रोत फ़ाइल को संपादित करने की आवश्यकता नहीं है।
##### &lt;कप्तानToRegex&gt;{#skipheadertoregex} 
* [&lt;स्किपहेडरToRegex&gt; (#kipheadertoregex) --
वैकल्पिक। (EDDTableFromAsciiFiles और EDDTableFromColumnarAsciiFiles केवल डेटासेट के लिए।)   
जब EDDTableFromAsciiFiles एक डेटा फ़ाइल पढ़ता है, तो यह सभी लाइनों को अनदेखा करेगा और उस रेखा को शामिल करेगा जो इस नियमित अभिव्यक्ति से मेल खाती है। डिफ़ॉल्ट " है, जो इस विकल्प का उपयोग नहीं करता है। उदाहरण है
```
    <skipHeaderToRegex>\\\*\\\*\\\* END OF HEADER.\\*<skipHeaderToRegex>  
```
जो सभी लाइनों को अप करने के लिए और एक लाइन है कि "के साथ शुरू होता है सहित अनदेखा करेगा\\*\\** हेडर का अंत।

जब आप इस टैग का उपयोग करते हैं,&lt;कॉलमNamesRow&gt; और&lt;पहलेDataRow&gt; यह कार्य करता है कि फ़ाइल पढ़ने से पहले हेडर को हटा दिया गया है। उदाहरण के लिए, यदि कॉलम नाम हेडर के बाद पंक्ति पर हैं तो आप स्तंभ नामों का उपयोग करेंगे।

यदि आप जनरेट करना चाहते हैं डेटासेट Xml एक डेटासेट के साथ जो इस टैग की जरूरत है:

1. मौजूदा फाइल की प्रतिलिपि करके और हेडर को हटाकर एक नया, अस्थायी, नमूना फ़ाइल बनाएं।
2. रन जनरेट डेटासेट XML और उस नमूना फ़ाइल निर्दिष्ट करें।
3. मैन्युअल रूप से जोड़ें&lt;स्किपHeaderToRegex&gt; टैग करने के लिए datasets.xml भाग।
4. अस्थायी, नमूना फ़ाइल को हटा दें।
5. में डेटासेट का उपयोग करें ERDDAP ।
##### &lt;स्किपलिन्स रेगेक्स एंड जीटी;{#skiplinesregex} 
वैकल्पिक। (EDDTableFromAsciiFiles और EDDTableFromColumnarAsciiFiles केवल डेटासेट के लिए।)   
जब EDDTableFromAsciiFiles एक डेटा फ़ाइल पढ़ता है, तो यह उन सभी लाइनों को अनदेखा करेगा जो इस नियमित अभिव्यक्ति से मेल खाते हैं। डिफ़ॉल्ट " है, जो इस विकल्प का उपयोग नहीं करता है। उदाहरण है
```
    <skipLinesRegex>#.\\*<skipLinesRegex>  
```
जो "#" के साथ शुरू होने वाली सभी लाइनों को अनदेखा करेगा।

जब आप इस टैग का उपयोग करते हैं,&lt;कॉलमNamesRow&gt; और&lt;पहलेDataRow&gt; यह कार्य करता है कि फ़ाइल पढ़ने से पहले सभी मिलान लाइनों को हटा दिया गया है। उदाहरण के लिए, आप स्तंभNamesRow=0 का उपयोग करेंगे, भले ही फ़ाइल की शुरुआत में कई लाइनें शुरू हो जाएं।
    
#### EDDTableFromFiles कंकाल XML{#eddtablefromfiles-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDTableFrom...Files" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;nDimensions>...&lt;/nDimensions>  &lt;!-- This was used prior to ERDDAP™  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;version 1.30, but is now ignored. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;updateEveryNMillis>](#updateeverynmillis)...&lt;/updateEveryNMillis> &lt;!-- 0 or 1. For  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDDTableFromFiles subclasses, this uses Java's WatchDirectory system  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to notice new/deleted/changed files quickly and efficiently. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;standardizeWhat>](#standardizewhat)...&lt;/standardizeWhat> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addVariablesWhere>](#addvariableswhere)...&lt;/addVariablesWhere> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;nThreads>](#nthreads)...&lt;/nThreads> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;specialMode>*mode*&lt;/specialMode>  &lt;-- This rarely-used, OPTIONAL tag  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;can be used with EDDTableFromThreddsFiles to specify that special,  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hard-coded rules should be used to determine which files should  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be downloaded from the server. Currently, the only valid *mode*  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is SAMOS which is used with datasets from  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://tds.coaps.fsu.edu/thredds/catalog/samos to download only the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;files with the last version number. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;sourceUrl>...&lt;/sourceUrl>  &lt;-- For subclasses like  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDDTableFromHyraxFiles and EDDTableFromThreddsFiles, this is where  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;you specify the base URL for the files on the remote server.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For subclasses that get data from local files, ERDDAP™ doesn't use  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this information to get the data, but does display the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;information to users. So I usually use "(local files)". -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;fileDir>...&lt;/fileDir> &lt;-- The directory (absolute) with the data  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;files. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;recursive>true|false&lt;/recursive> &lt;!-- 0 or 1. Indicates if  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subdirectories of fileDir have data files, too. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;pathRegex>](#pathregex)...&lt;/pathRegex>  &lt;!-- 0 or 1. Only directory names which  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match the pathRegex (default=".\\*") will be accepted. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;fileNameRegex>...&lt;/fileNameRegex> &lt;-- 0 or 1. A [regular expression](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html)  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([tutorial](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html)) describing valid data file names, for example,  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;".\\*\\.nc" for all .nc files. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaFiles>](#accessibleviafiles)true|false(default)&lt;/accessibleViaFiles>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;metadataFrom>...&lt;/metadataFrom> &lt;-- The file to get metadata  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from ("first" or "last" (the default) based on file's  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastModifiedTime). -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;charset>...&lt;/charset>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- (For EDDTableFromAsciiFiles and EDDTableFromColumnarAsciiFiles  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only) This OPTIONAL tag specifies the character set (case  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sensitive!) of the source files, for example, ISO-8859-1  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(the default) and UTF-8.  -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;skipHeaderToRegex>](#skipheadertoregex)...&lt;/skipHeaderToRegex>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;skipLinesRegex>](#skiplinesregex)...&lt;/skipLinesRegex>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;columnNamesRow>...&lt;/columnNamesRow> &lt;-- (For EDDTableFromAsciiFiles  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only) This specifies the number of the row with the column  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;names in the files. (The first row of the file is "1".  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default = 1.)  If you specify 0, ERDDAP™ will not look for  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column names and will assign names: Column#1, Column#2, ... -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;firstDataRow>...&lt;/firstDataRow>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-- (For EDDTableFromAsciiFiles and EDDTableFromColumnarAsciiFiles  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only) This specifies the number of the first row with data in the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;files. (The first row of the file is "1". Default = 2.) -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dimensionsCSV>...&lt;/dimensionsCSV> &lt;-- (For EDDTableFromNcFiles  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and EDDTableFromMultidimNcFiles only) This is a comma-separated  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list of dimension fullNames. If specified, ERDDAP™ will only read  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variables in the source files which use some or all of these  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dimensions, plus all of the scalar variables. If a dimension  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is in a group, you must specify its fullName,  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.g., "*groupName/dimensionName*". -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-- The next four tags are DEPRECATED. For more information, see  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[File Name Extracts](#filename-sourcenames). -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;preExtractRegex>...&lt;/preExtractRegex>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;postExtractRegex>...&lt;/postExtractRegex>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;extractRegex>...&lt;/extractRegex>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;columnNameForExtract>...&lt;/columnNameForExtract>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;sortedColumnSourceName>...&lt;/sortedColumnSourceName>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-- The [sourceName](#sourcename) of the numeric column that the data files are  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usually already sorted by within each file, for example, "time".  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Don't specify this or use an empty string if no variable is  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suitable. It is ok if not all files are sorted by this column.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If present, this can greatly speed up some data requests.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For EDDTableFromHyraxFiles, EDDTableFromNcFiles and  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDDTableFromThreddsFiles, this must be the leftmost (first) axis variable.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDDTableFromMultidimNcFiles ignores this because it has a better  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;sortFilesBySourceNames>...&lt;/sortFilesBySourceNames>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-- This is a space-separated list of [sourceName](#sourcename)s  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which specifies how the internal list of files should be sorted  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(in ascending order), for example "id time".  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It is the minimum value of the specified columns in each file  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that is used for sorting.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When a data request is filled, data is obtained from the files  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in this order. Thus it determines the overall order of the data  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in the response.  If you specify more than one column name, the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second name is used if there is a tie for the first column; the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;third is used if there is a tie for the first and second  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;columns; ... This is OPTIONAL (the default is  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileDir+fileName order). -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceNeedsExpandedFP\\_EQ>](#sourceneedsexpandedfp_eq)true(default)|false&lt;/sourceNeedsExpandedFP\\_EQ>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fileTableInMemory>](#filetableinmemory)...&lt;/fileTableInMemory> &lt;!-- 0 or 1 (true or  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false (the default)) -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;cacheFromUrl>](#cachefromurl)...&lt;/cacheFromUrl> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;cacheSizeGB>](#cachefromurl)...&lt;/cacheSizeGB> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addAttributes>](#global-attributes)...&lt;/addAttributes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dataVariable>](#datavariable)...&lt;/dataVariable> &lt;!-- 1 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-- For EDDTableFromHyraxFiles, EDDTableFromMultidimNcFiles,  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDDTableFromNcFiles, EDDTableFromNccsvFiles, and  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDDTableFromThreddsFiles, the source's axis variables (for  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;example, time) needn't be first or in any specific order. -->  
>&nbsp;&nbsp;&lt;/dataset>  

### EDDTableFromAsciiService{#eddtablefromasciiservice} 
 [ **EDDTableFromAsciiService** ](#eddtablefromasciiservice) अनिवार्य रूप से एक स्क्रीन स्क्रैपर है। यह डेटा स्रोतों से निपटने का इरादा है जिसमें डेटा अनुरोध करने के लिए एक सरल वेब सेवा है। (अक्सर एक वेब पेज पर HTML फॉर्म) और जो कुछ संरचित ASCII प्रारूप में डेटा वापस कर सकते हैं (उदाहरण के लिए, एक कॉमा-separated-value या स्तंभकार ASCII पाठ प्रारूप, अक्सर पहले और/या डेटा के बाद अन्य जानकारी के साथ) ।

EDDTableFromAsciiService सभी EDDTableFromAsciiService. आप सीधे EDDTableFromAsciiService का उपयोग नहीं कर सकते। इसके बजाय, विशिष्ट प्रकार की सेवाओं को संभालने के लिए EDDTableFromAsciiService के एक उपश्रेणी का उपयोग करें:

*    [EDDTableFromAsciiServiceNOS](#eddtablefromasciiservicenos) से डेटा हो जाता है NOAA NOS की ASCII सेवाएं।

वर्तमान में, कोई अन्य सेवा प्रकार समर्थित नहीं है। लेकिन अगर वे एक समान तरीके से काम करते हैं तो यह आमतौर पर अन्य सेवाओं का समर्थन करने में आसान होता है। यदि आपके पास अनुरोध है तो हमसे संपर्क करें।

#### विवरण{#details} 
निम्नलिखित जानकारी EDDTableFromAsciiService के सभी उपवर्गों पर लागू होती है।

* -- ERDDAP™ सारणीबद्ध डेटा अनुरोध किसी भी परिवर्तनीय पर बाधा डाल सकते हैं। अंतर्निहित सेवा सभी चरों पर बाधाओं की अनुमति नहीं दे सकती है। उदाहरण के लिए, कई सेवाएँ केवल स्टेशन नामों, अक्षांश, देशांतर और समय पर बाधाओं का समर्थन करती हैं। इसलिए जब EDDTableFromAsciiService का एक उपश्रेणी डेटासेट की एक सबसेट के लिए एक अनुरोध प्राप्त करता है, तो यह स्रोत डेटा सेवा के लिए संभव के रूप में कई बाधाओं को गुजरता है और फिर सेवा द्वारा लौटाए गए डेटा के लिए शेष बाधाओं को लागू करता है, उपयोगकर्ता को डेटा सौंपने से पहले।
* मान्य रेंज - कई अन्य डेटासेट प्रकारों के विपरीत, EDDTableFromAsciiService आमतौर पर प्रत्येक चर के लिए डेटा की सीमा को नहीं जानता है, इसलिए यह वैधता सीमा के बाहर डेटा के लिए अनुरोध को तुरंत अस्वीकार नहीं कर सकता है।
* ASCII पाठ प्रतिक्रिया पार्सिंग -- जब EDDTableFromAsciiService को ASCII टेक्स्ट सर्विस से जवाब मिलता है, तो यह सत्यापित करना चाहिए कि प्रतिक्रिया में अपेक्षित प्रारूप और जानकारी है, और फिर डेटा निकालने का अधिकार है। आप इस डेटासेट के लिए XML के हिस्से में विभिन्न विशेष टैग का उपयोग करके प्रारूप को निर्दिष्ट कर सकते हैं:
    *   &lt;beforeData1&gt;&lt;पहलेData10&gt; टैग -- आप पाठ के टुकड़ों की एक श्रृंखला निर्दिष्ट कर सकते हैं (जैसा कि आप चाहते हैं, 10 तक) कि EDDTableFromAsciiService को सेवा द्वारा लौटाए गए ASCII टेक्स्ट के हेडर में देखना होगा।&lt;beforeData1&gt;&lt;पहले Data10&gt; उदाहरण के लिए, यह सत्यापित करने के लिए उपयोगी है कि प्रतिक्रिया में अपेक्षित इकाइयों का उपयोग करके अपेक्षित चर शामिल हैं। पिछले पहलेडेटा टैग जो आप निर्दिष्ट करते हैं, डेटा शुरू होने से पहले सही होने वाले पाठ की पहचान करता है।
    *   &lt;afterData&gt; -- यह उस पाठ को निर्दिष्ट करता है जो EDDTableFromAsciiService उस ASCII पाठ को उस सेवा द्वारा लौटा देगा जो डेटा के अंत को दर्शाता है।
    *   &lt;NoData&gt; -- यदि EDDTableFromAsciiService इस पाठ को सेवा द्वारा लौटाए गए ASCII पाठ में पाता है, तो यह निष्कर्ष निकाला जाता है कि कोई डेटा नहीं है जो अनुरोध से मेल खाता है।
#### EDDTableFromAsciiService कंकाल XML{#eddtablefromasciiservice-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDTableFromAsciiService..." [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addVariablesWhere>](#addvariableswhere)...&lt;/addVariablesWhere> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;sourceUrl>...&lt;/sourceUrl>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;beforeData1>...&lt;beforeData1> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;beforeData10>...&lt;beforeData10> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;afterData>...&lt;afterData> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;noData>...&lt;noData> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addAttributes>](#global-attributes)...&lt;/addAttributes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dataVariable>](#datavariable)...&lt;/dataVariable> &lt;!-- 1 or more -->  
>&nbsp;&nbsp;&lt;/dataset>  

### EDDTableFromAsciiServiceNOS{#eddtablefromasciiservicenos} 
 [ **EDDTableFromAsciiServiceNOS** ](#eddtablefromasciiservicenos) ASCII टेक्स्ट डेटा सेवाओं से EDDTable डेटासेट बनाता है जो द्वारा पेश की जाती है NOAA ' [राष्ट्रीय महासागर सेवा (NOS) ](https://oceanservice.noaa.gov/) । इस वर्ग के कार्यों और इसका उपयोग कैसे करें, इस वर्ग के सुपरक्लास को देखें [EDDTableFromAsciiService](#eddtablefromasciiservice) । यह संभावना नहीं है कि किसी अन्य व्यक्ति को इस उपश्रेणी का उपयोग करने की आवश्यकता होगी।

चूंकि एक NOS सेवा से प्रतिक्रिया के भीतर डेटा एक कॉलमर ASCII टेक्स्ट प्रारूप का उपयोग करता है, अक्षांश और देशांतर के अलावा अन्य डेटा चर में एक विशेष विशेषता होना चाहिए, जो निर्दिष्ट करता है कि प्रत्येक डेटा लाइन के कौन से पात्रों में उस चर का डेटा होता है, उदाहरण के लिए,
```
<att name="responseSubstring">17, 25</att>  
```
 
### EDDTableFromAllDatasets{#eddtablefromalldatasets} 
 [ **EDDTableFromAllDatasets** ](#eddtablefromalldatasets) एक उच्च स्तरीय डेटासेट है जिसमें अन्य सभी डेटासेटों के बारे में जानकारी है जो वर्तमान में आपके डेटा में लोड हो रहे हैं। ERDDAP । अन्य प्रकार के डेटासेट के विपरीत, इसके लिए कोई विनिर्देश नहीं है allDatasets डेटासेट में datasets.xml । ERDDAP™ स्वचालित रूप से एक EDDTableFromAllDatasets डेटासेट बनाता है (साथ datasetID = allDatasets ) । इस प्रकार, एक allDatasets प्रत्येक में डेटासेट बनाया जाएगा ERDDAP™ स्थापना और प्रत्येक में उसी तरह काम करेगा ERDDAP™ स्थापना।

The The most of the allDatasets डेटासेट एक सारणीबद्ध डेटासेट है। इसमें प्रत्येक डेटासेट के लिए जानकारी की एक पंक्ति है। इसमें प्रत्येक डेटासेट के बारे में जानकारी वाले कॉलम हैं, उदाहरण के लिए, datasetID , सुलभ, संस्था, शीर्षक, minLongitude, maxLongitude, minLatitude, maxLatitude, minTime, maxTime, आदि। क्योंकि allDatasets एक सारणीबद्ध डेटासेट है, आप इसे उसी तरह से क्वेरी कर सकते हैं जिसे आप किसी अन्य सारणीबद्ध डेटासेट को क्वेरी कर सकते हैं। ERDDAP™ , और आप प्रतिक्रिया के लिए फ़ाइल प्रकार निर्दिष्ट कर सकते हैं। यह उपयोगकर्ताओं को बहुत शक्तिशाली तरीके से ब्याज के डेटासेट की तलाश करने देता है।
 
### EDDTableFromAsciiFiles{#eddtablefromasciifiles} 
 [ **EDDTableFromAsciiFiles** ](#eddtablefromasciifiles) कॉमा-, टैब-, सेमीकोलॉन-, या स्पेस-सेपरेटेड सारणीबद्ध ASCII डेटा फ़ाइलों से डेटा एकत्र करता है।

* अक्सर फ़ाइलों में पहली पंक्ति और दूसरी पंक्ति पर शुरू होने वाले डेटा पर कॉलम नाम होंगे। (यहां, फ़ाइल की पहली पंक्ति को पंक्ति संख्या 1 कहा जाता है।) लेकिन आप उपयोग कर सकते हैं&lt;कॉलमNamesRow&gt; और&lt;FirstDataRow datasets.xml एक अलग पंक्ति संख्या निर्दिष्ट करने के लिए फ़ाइल।
*    ERDDAP™ डेटा की पंक्तियों को विभिन्न संख्याओं के डेटा मानों की अनुमति देता है। ERDDAP™ मान लीजिए कि लापता डेटा मान पंक्ति में अंतिम कॉलम हैं। ERDDAP™ लापता डेटा मूल्यों के लिए मानक लापता मान मान मान निर्दिष्ट करता है। (जोड़ा गया v1.56) 
* ASCII फ़ाइलों के साथ काम करना आसान है, लेकिन वे डेटा को स्टोर / पुनर्प्राप्त करने का सबसे प्रभावी तरीका नहीं हैं। अधिक दक्षता के लिए, फ़ाइलों को बचाने के लिए NetCDF v3 .nc फ़ाइलें (एक आयाम के साथ, "row", सभी चर द्वारा साझा) इसके बजाय। आप कर सकते हैं [उपयोग ERDDAP™ नई फाइलें उत्पन्न करने के लिए](#millions-of-files) ।
* इस वर्ग के सुपरक्लास को देखें, [EDDTableFromFiles](#eddtablefromfiles) यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है, इस बारे में जानकारी के लिए।
* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। ASCII फ़ाइलों में मेटाडाटा की कुल कमी के कारण, आपको हमेशा जेनरेटडाटासेटएक्सएमएल के परिणामों को संपादित करने की आवश्यकता होगी।
* कब: कब ERDDAP™ ASCII डेटा फ़ाइलों को पढ़ता है, अगर यह किसी दिए गए लाइन पर त्रुटि पाता है (उदाहरण के लिए, वस्तुओं की गलत संख्या) यह एक चेतावनी संदेश लॉग करता है ("WARNING: खराब रेखा (s) डेटा की एक सूची के साथ) to [log.txt फ़ाइल](/docs/server-admin/additional-information#log) और फिर बाकी डेटा फ़ाइल को पढ़ना जारी रखता है। इस प्रकार, समय-समय पर देखने की आपकी ज़िम्मेदारी है (या ऐसा करने के लिए एक स्क्रिप्ट लिखने) लॉग में उस संदेश के लिए। ताकि आप डेटा फ़ाइलों में समस्याओं को ठीक कर सकें। ERDDAP™ इस तरह से सेट किया गया है ताकि उपयोगकर्ता सभी उपलब्ध वैध डेटा को पढ़ना जारी रख सकें, भले ही फ़ाइल की कुछ पंक्तियां त्रुटियां हों।
     
### EDDTableFrom AwsXmlFiles{#eddtablefromawsxmlfiles} 
 [ **EDDTableFrom AwsXmlFiles** ](#eddtablefromawsxmlfiles) स्वचालित मौसम स्टेशन के एक सेट से डेटा एकत्र करता है (एडब्ल्यूएस) XML डेटा फ़ाइलों का उपयोग करके WeatherBug Rest XML API (जो अब सक्रिय नहीं है) ।

* इस प्रकार की फ़ाइल डेटा को स्टोर करने का एक सरल लेकिन अक्षम तरीका है, क्योंकि प्रत्येक फ़ाइल में आमतौर पर सिर्फ एक बार बिंदु से अवलोकन होता है। इसलिए बड़ी संख्या में फाइलें हो सकती हैं। यदि आप प्रदर्शन में सुधार करना चाहते हैं, तो अवलोकनों के समूह को समेकित करने पर विचार करें (सप्ताह के लायक?) में NetCDF v3 .nc फ़ाइलें (सबसे अच्छा: .nc फ़ाइलों के साथ [CF Discrete Sampling Geometries (DSG) Contiguous Ragged Array प्रारूप](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries) ) उपयोग [EDDTableFromMultidimNcFiles](#eddtablefrommultidimncfiles)   (या [EDDTableFromNcCFFiles](#eddtablefromnccffiles) ) डेटा की सेवा करने के लिए। आप कर सकते हैं [उपयोग ERDDAP™ नई फाइलें उत्पन्न करने के लिए](#millions-of-files) ।
* इस वर्ग के सुपरक्लास को देखें, [EDDTableFromFiles](#eddtablefromfiles) यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है, इस बारे में जानकारी के लिए।
     
### EDDTableFromColumnarAsciiFiles{#eddtablefromcolumnarasciifiles} 
 [ **EDDTableFromColumnarAsciiFiles** ](#eddtablefromcolumnarasciifiles) निश्चित चौड़ाई वाले कॉलम के साथ सारणीबद्ध ASCII डेटा फ़ाइलों से डेटा एकत्र करता है।

* अक्सर फ़ाइलों में पहली पंक्ति और दूसरी पंक्ति पर शुरू होने वाले डेटा पर कॉलम नाम होंगे। पहली पंक्ति / पंक्ति फाइल में पंक्ति #1 कहा जाता है। लेकिन आप उपयोग कर सकते हैं&lt;कॉलमNamesRow&gt; और&lt;FirstDataRow datasets.xml एक अलग पंक्ति संख्या निर्दिष्ट करने के लिए फ़ाइल।
* The The most of the&lt; addAttributes प्रत्येक के लिए&lt; dataVariable इन आंकड़ों के लिए MUST में इन दो विशेष विशेषताओं को शामिल किया गया है:
    
    *   &lt;att name=" startColumn"&gt; *पूर्णांक* &lt;Att&gt; - प्रत्येक पंक्ति में वर्ण स्तंभ को निर्दिष्ट करता है जो इस डेटा चर की शुरुआत है।
    *   &lt;att name="stopColumn"&gt; *पूर्णांक* &lt;Att&gt; - प्रत्येक पंक्ति में वर्ण स्तंभ को निर्दिष्ट करता है जो इस डेटा चर के अंत के बाद 1 है।
    
पहले अक्षर स्तंभ को स्तंभ #0 कहा जाता है।
उदाहरण के लिए, इस फ़ाइल के लिए जो समय-समय पर तापमान मूल्यों को बढ़ाता है:
```
      0         1         2        <-- character column number 10's digit
      0123456789012345678901234567 <-- character column number 1's digit
      time                temp
      2014-12-01T12:00:00Z12.3
      2014-12-02T12:00:00Z13.6
      2014-12-03T12:00:00Z11.0
```
समय डेटा चर होगा
```
      <att name="startColumn">0<att>  
      <att name="stopColumn">20<att>  
```
और समय डेटा चर होगा
```
      <att name="startColumn">20<att>  
      <att name="stopColumn">24<att>  
```
इन विशेषताओं को छोड़कर सभी चरों के लिए निर्दिष्ट किया जाना चाहिए [निश्चित मूल्य](#fixed-value-sourcenames) और [फ़ाइल-name-source-name](#filename-sourcenames) चर।
* ASCII फ़ाइलों के साथ काम करना आसान है, लेकिन वे डेटा को स्टोर / पुनर्प्राप्त करने का एक कुशल तरीका नहीं हैं। अधिक दक्षता के लिए, फ़ाइलों को बचाने के लिए NetCDF v3 .nc फ़ाइलें (एक आयाम के साथ, "row", सभी चर द्वारा साझा) इसके बजाय। आप कर सकते हैं [उपयोग ERDDAP™ नई फाइलें उत्पन्न करने के लिए](#millions-of-files) ।
* इस वर्ग के सुपरक्लास को देखें, [EDDTableFromFiles](#eddtablefromfiles) यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है, इस बारे में जानकारी के लिए।
* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। प्रत्येक डेटा कॉलम और ASCII फ़ाइलों में मेटाडाटा की कुल कमी के लिए शुरू और अंत पदों को निर्धारित करने में कठिनाई के कारण, आपको हमेशा जेनरेटडाटासेटएक्सएमएल से परिणाम संपादित करने की आवश्यकता होगी।
     
### EDDTableFromHttpGet{#eddtablefromhttpget} 
EDDTable FromHttpGet डेटासेट के अन्य सभी प्रकार से अलग है ERDDAP™ इसमें एक प्रणाली है जिसके द्वारा विशिष्ट "लेखक" नियमित रूप से डेटासेट से डेटा को डेटा जोड़ने, डेटा को संशोधित करने या डेटा को हटा सकते हैं। HTTP GET या [पोस्ट](#http-post) कंप्यूटर प्रोग्राम, स्क्रिप्ट या ब्राउज़र से अनुरोध करता है। डेटासेट उपयोगकर्ताओं द्वारा समान रूप से क्वेरी करने योग्य है कि अन्य सभी EDDTable डेटासेट में क्वेरी करने योग्य हैं। ERDDAP । इस वर्ग के सुपरक्लास का वर्णन देखें, [EDDTableFromFiles](#eddtablefromfiles) , उस सुपरक्लास से विरासत में मिली सुविधाओं के बारे में पढ़ने के लिए।

EDDTableFromHttpGet की अनूठी विशेषताओं को नीचे वर्णित किया गया है। आपको इस प्रारंभिक अनुभाग को पढ़ने की आवश्यकता है और इसे समझने की आवश्यकता है; अन्यथा, आपके पास अवास्तविक उम्मीदें हो सकती हैं या उन्हें ठीक करने में कठिनाई हो सकती हैं।

#### गहन उपयोग{#intended-use} 
इस प्रणाली का उद्देश्य निम्नलिखित है:

* सारणी (सिट्टू में) डेटा, ग्रिड डेटा नहीं।
* वास्तविक समय डेटा -
लक्ष्य एक लेखक की अनुमति देना है (उदाहरण के लिए, सेंसर, एक स्वचालित क्यूसी स्क्रिप्ट, या एक विशिष्ट मानव) डेटासेट में बदलाव करने के लिए (एक [.insert या .delete कमांड](#insert-and-delete) ) और उस बदलाव को सुलभ बनाना ERDDAP™ उपयोगकर्ता, सभी 1 सेकंड से कम और संभवतः बहुत तेजी से। उस 1 सेकंड का अधिकांश नेटवर्क समय है। ERDDAP™ लगभग 1 ms में अनुरोध को संसाधित कर सकते हैं और डेटा उपयोगकर्ताओं के लिए तुरंत सुलभ है। यह एक है [तेज](#httpget-speed) , [मजबूत](#robust) , और [विश्वसनीय प्रणाली](#system-reliability) ।
* लगभग किसी भी आवृत्ति -
यह प्रणाली लगातार डेटा को स्वीकार कर सकती है (जैसे दैनिक) बहुत लगातार डेटा के माध्यम से (उदाहरण के लिए, 100 हर्ट्ज डेटा) । यदि आप सिस्टम को अनुकूलित करते हैं, तो यह उच्च आवृत्ति डेटा को संभाल सकता है (यदि आप चरम पर जाते हैं तो शायद 10 किलोहर्ट्ज़ डेटा) ।
* एक सेंसर से डेटा या समान सेंसर का एक संग्रह।
*    [संस्करण](#versioning) / [Reproducible Science](https://en.wikipedia.org/wiki/Reproducibility) / DOI S --
जहां आपको डेटा में बदलाव करने में सक्षम होना चाहिए (उदाहरण के लिए, एक गुणवत्ता नियंत्रण ध्वज बदलें) यह जानने के लिए कि कौन से लेखक ने प्रत्येक बदलाव को बनाया है, जब लेखक ने परिवर्तन किया तो टाइमस्टैम्प को पता चलता है, और (अनुरोध पर) परिवर्तन करने से पहले मूल डेटा को देखने में सक्षम होना चाहिए। इस प्रकार, ये डेटासेट के लिए योग्य हैं [ DOI s](https://en.wikipedia.org/wiki/Digital_object_identifier) । क्योंकि वे मिलते हैं DOI आवश्यकता यह है कि डेटासेट अलग होने के अलावा बदल रहा है। सामान्य तौर पर, वास्तविक समय डेटासेट के पास के लिए पात्र नहीं हैं DOI क्योंकि डेटा अक्सर retroactively बदल जाता है (उदाहरण के लिए, QA/QC प्रयोजनों के लिए) ।
     

एक बार डेटा एक EDDTableFromHttpGet डेटासेट में होता है, किसी भी उपयोगकर्ता डेटा को उसी तरह से अनुरोध कर सकता है कि वे किसी अन्य EDDTable डेटासेट से डेटा का अनुरोध करते हैं।
     
#### प्रयोगात्मक: सावधान रहें{#experimental-be-careful} 
चूंकि यह प्रणाली नई है और चूंकि खोए हुए पर्यावरणीय डेटा को प्राप्त नहीं किया जा सकता है, इसलिए आपको प्रयोगात्मक के रूप में EDDTableFromHttpGet का इलाज करना चाहिए। यदि आप किसी अन्य प्रणाली से संक्रमण कर रहे हैं, तो कृपया पुराने सिस्टम और नए सिस्टम को समानांतर में चलाएं जब तक कि आप आश्वस्त न हों कि नई प्रणाली अच्छी तरह से काम करती है। (सप्ताह या महीने, सिर्फ घंटे या दिन) । सभी मामलों में, कृपया सुनिश्चित करें कि आपका सिस्टम अलग-अलग .insert और .delete URL संग्रहीत करता है जो EDDTableFromHttpGet डेटासेट को भेजे जाते हैं। (यहां तक कि अगर सिर्फ अपाचे और / या टॉमकैट लॉग में) कम से कम थोड़ी देर के लिए। और सभी मामलों में, सुनिश्चित करें कि आपके EDDTableFromHttpGet डेटासेट द्वारा बनाई गई डेटा फ़ाइलों को नियमित रूप से बाह्य डेटा भंडारण उपकरणों तक बैकअप लिया जाता है। (ध्यान दें कि [हिन्दी](https://en.wikipedia.org/wiki/Rsync) EDDTableFromHttpGet द्वारा बनाई गई डेटा फ़ाइलों को बहुत कुशलतापूर्वक वापस कर सकते हैं।)   
     
#### .insert और .delete{#insert-and-delete} 

किसी भी डेटासेट के लिए ERDDAP™ जब आप एक अनुरोध भेजते हैं ERDDAP™ डेटासेट में डेटा की एक सबसेट के लिए, आप उस फ़ाइल प्रकार को निर्दिष्ट करते हैं जो आप प्रतिक्रिया के लिए चाहते हैं, उदाहरण के लिए, .csv, .htmlTable , .nc , .json । EDDTableFromHttp दो अतिरिक्त "फ़ाइल प्रकार" का समर्थन करने के लिए इस प्रणाली को बढ़ाता है जो सम्मिलित हो सकता है (या परिवर्तन) या डेटासेट में डेटा को हटा दें:

* Insert
    * अनुरोध को एक मानक एचटीएमएल फॉर्म प्रतिक्रिया की तरह प्रारूपित किया गया है, जिसमें कुंजी = वैल्यू जोड़े, जिसे '&' से अलग किया गया है। उदाहरण के लिए,
        https://*some.erddap.url*/erddap/tabledap/myDataset**.insert**?stationID=46088&time=2016-03-30T12:37:55Z&latitude=10.1&longitude=-150.1&airTemp=17.23&waterTemp=12.3&author=JohnSmith\\_someKey1  
कहना ERDDAP™ डेटा को जोड़ने या बदलने के लिए stationID निर्दिष्ट समय के लिए =46088।
    * इस बदलाव का लेखक JohnSmith है और कुंजी कुछKey1 है।
    * URL में मान्य मान शामिल होना चाहिए (नहीं लापता मान) सभी के लिए [ http प्राप्त करना](#httpgetrequiredvariables-global-attribute) 
    * यदि मूल्य http प्राप्त करना अनुरोध में भिन्नता (उदाहरण के लिए stationID समय) पहले से ही डेटासेट में एक पंक्ति पर मूल्यों से मेल खाते हैं, नए मूल्य प्रभावी ढंग से पुराने मूल्यों को ओवरराइट करते हैं (हालांकि पुराने मान अभी भी सुलभ हैं यदि उपयोगकर्ता पिछले डेटा का अनुरोध करता है [संस्करण](#versioning) डेटासेट) ।
    * .insert URL कभी शामिल नहीं होना चाहिए & timestamp= ( ERDDAP™ वह मान उत्पन्न करता है) (in&command=) (जो .insert द्वारा निर्दिष्ट है (जो कमांड = 0 है) या .delete (कौन है? 1) ) ।
    * यदि .insert URL उन अन्य स्तंभों के मूल्यों को निर्दिष्ट नहीं करता है जो डेटासेट में हैं, तो उन्हें मूल लापता मान माना जाता है। (Integer डेटा प्रकार के लिए मैक्स \\_VALUE, नावों और डबल्स के लिए NaN और स्ट्रिंग्स के लिए "") ।
             
    * .delete
        * अनुरोध को एक मानक एचटीएमएल फॉर्म प्रतिक्रिया की तरह प्रारूपित किया गया है, जिसमें कुंजी = वैल्यू जोड़े, जिसे '&' से अलग किया गया है। उदाहरण के लिए,
            https://*some.erddap.url*/erddap/tabledap/myDataset**.delete**?stationID=46088&time=2016-03-30T12:37:55Z&author=JohnSmith\\_someKey1  
कहना ERDDAP™ डेटा को हटाने के लिए stationID निर्दिष्ट समय पर =46088।
        * इस बदलाव का लेखक JohnSmith है और कुंजी कुछKey1 है।
        * यूआरएल निर्दिष्ट करना चाहिए [ http प्राप्त करना](#httpgetrequiredvariables-global-attribute) अनुरोध में (उदाहरण के लिए stationID समय) । यदि वे मान डेटासेट में पहले से ही पंक्ति पर मानों का मिलान करते हैं (जो आम तौर पर वे करेंगे) पुराने मूल्यों को प्रभावी ढंग से हटा दिया जाता है (हालांकि पुराने मान अभी भी सुलभ हैं अगर कोई उपयोगकर्ता पिछले डेटा का अनुरोध करता है [संस्करण](#versioning) डेटासेट) ।
        * गैर-HttpGetRequiredVariables, लेखक के अलावा अन्य के लिए मूल्यों को निर्दिष्ट करने की कोई आवश्यकता नहीं है, जिसे अनुरोध को प्रमाणित करने की आवश्यकता है।
             
    
विवरण:
    * .insert और .delete अनुरोधों को मानक एचटीएमएल फॉर्म प्रतिक्रियाओं की तरह प्रारूपित किया जाता है, कुंजी = वैल्यू जोड़े के साथ, जिसे '&' से अलग किया जाता है। मान होना चाहिए [प्रतिशत encoded](https://en.wikipedia.org/wiki/Percent-encoding) । इस प्रकार, आपको विशेष वर्णों को %HH के रूप में कोडित करने की आवश्यकता है, जहां HH चरित्र का 2 अंकीय हेक्साडेसिमल मान है। आमतौर पर, आपको बस कुछ punctuation अक्षरों को बदलने की आवश्यकता होती है: % में %25, और %26 में, "%22 में,&lt;%3C में =%3D में&gt;%3E में +%2B में, | %7C में \\[ %5B में \\] %5D में,%20 में अंतरिक्ष, और # 127 से ऊपर के सभी पात्रों को अपने UTF-8 फॉर्म में परिवर्तित करें और फिर %HH प्रारूप में UTF-8 फॉर्म के प्रत्येक बाइट को कोडित करें। (मदद के लिए प्रोग्रामर से पूछें) ।
    * .insert और .delete अनुरोध शामिल होना चाहिए [ http प्राप्त करना](#httpgetrequiredvariables-global-attribute) , उदाहरण के लिए, stationID समय .insert अनुरोध के लिए, वेरिएबल जो अनुरोध में निर्दिष्ट नहीं हैं उन्हें लापता मान माना जाता है (Integer चर के लिए मैक्स \\_VALUE, नाव और डबल चर के लिए NaN, और स्ट्रिंग चर के लिए एक खाली स्ट्रिंग) । अनुरोधों के लिए, गैर-HttpGetRequired के लिए मान चर (लेखक के अलावा, जो आवश्यक है) ध्यान दिया जाता है।
    * .insert और .delete अनुरोध प्रपत्र लेखक = में एक पैरामीटर के माध्यम से लेखक और लेखक की कुंजी का नाम शामिल होना चाहिए *लेखक* अनुरोध में अंतिम पैरामीटर के रूप में। यह सुनिश्चित करने के लिए कि पूरे अनुरोध को प्राप्त किया गया है ERDDAP । केवल लेखक (नहीं) डेटा फ़ाइल में संग्रहीत किया जाएगा। आपको अनुमति की सूची निर्दिष्ट करना होगा *लेखक* वैश्विक विशेषता के माध्यम से [ http GetKeys](#httpgetkeys) 
    * .insert और .delete मापदंडों स्केलर हो सकता है (एकल) फॉर्म में किसी भी लम्बाई के मान या सरणी \\[ value1, value2, value3,..., valueN \\] । किसी दिए गए अनुरोध के लिए, सरणी के साथ सभी चर मूल्यों की समान संख्या के साथ सरणी होना चाहिए (यह एक त्रुटि है) । यदि किसी अनुरोध में स्केलर और सरणी मान हैं, तो स्केलर मान निर्दिष्ट सरणी के समान लंबाई के साथ सरणी बनने के लिए दोहराए जाते हैं, उदाहरण के लिए, और stationID =46088 के रूप में इलाज किया जा सकता है & stationID = \\[ 46088,46088,46088 \\] । Arrays के लिए कुंजी हैं [उच्च throughput](#httpget-speed) । सरणी के बिना, यह एक दूरस्थ लेखक से प्रति सेकंड 8 पंक्तियों से अधिक डेटा को निष्क्रिय या निष्क्रिय करने के लिए चुनौतीपूर्ण होगा। (नेटवर्क के सभी ओवरहेड के कारण) । सरणी के साथ, रिमोट सेंसर से प्रति सेकंड 1000 पंक्तियों से अधिक डेटा को निष्क्रिय करना या निष्क्रिय करना आसान होगा।
    * .insert और .delete स्वीकार करते हैं (त्रुटि संदेश के बिना) जब पूर्णांक की उम्मीद की जाती है तो फ्लोटिंग पॉइंट नंबर। इन मामलों में, डेटासेट मूल्यों को पूर्ण करने के लिए राउंड करता है।
    * .insert और .delete स्वीकार करते हैं (त्रुटि संदेश के बिना) पूर्णांक और अस्थायी बिंदु संख्या जो परिवर्तनीय के डेटा प्रकार की सीमा से बाहर हैं। इन मामलों में, डेटासेट मूल्यों को स्टोर करता है क्योंकि ERDDAP उस डेटा प्रकार के लिए मूल लापता मान (integer प्रकार और नाव के लिए मैक्स \\_VALUE फ्लोट्स और डबल्स के लिए) ।
         
#### जवाब{#response} 
यदि .insert या .delete URL सफल होता है, तो HTTP प्रतिक्रिया कोड 200 हो जाएगा। (ठीक) और जवाब एक साथ पाठ होगा .json वस्तु, जैसे,
```
    {
    "status":"success",
    "nRowsReceived":1,
    "stringTimestamp":"2018-11-05T22:12:19.517Z",
    "numericTimestamp":1.541455939517+E9
    }
```
ध्यान दें कि टाइमस्टैम्प्स में मिलीसेकंड परिशुद्धता है।

यदि .insert या .delete URL विफल हो जाता है, तो आपको 200 से अधिक HTTP प्रतिक्रिया कोड मिलेगा (ओके) , उदाहरण के लिए, त्रुटि 403 अगर आप एक गलत लेखक \\_key मान जमा करते हैं तो मना किया। ERDDAP™ HTTP प्रतिक्रिया कोड भेजता है (नहीं, उदाहरण के लिए, a .json स्वरूपित त्रुटि) क्योंकि यह है कि इंटरनेट में चीजें कैसे की जाती हैं और क्योंकि त्रुटियां सिस्टम में कहीं भी हो सकती हैं (उदाहरण के लिए, नेटवर्क में, जो HTTP त्रुटि देता है) । यदि त्रुटि से है ERDDAP™ , प्रतिक्रिया में कुछ पाठ शामिल हो सकते हैं (नहीं .json ) एक विस्तृत स्पष्टीकरण के साथ जो गलत हो गया, लेकिन HTTP प्रतिक्रिया कोड (200=Okay, कुछ और परेशानी है) यह जांचने का उचित तरीका है कि क्या .insert या .delete सफल रहा है। यदि प्रतिक्रिया कोड की जांच संभव नहीं है या असुविधाजनक है, तो प्रतिक्रिया पाठ में "status": "success" की खोज करें, जिसे सफलता का विश्वसनीय संकेत होना चाहिए।
    
#### लॉग इन करें{#log-files} 
जब EDDTableFromHttpGet को .insert और .delete कमांड प्राप्त होता है, तो यह केवल लॉग फ़ाइलों के एक सेट में प्रासंगिक फ़ाइल को जानकारी प्रदान करता है, जिनमें से प्रत्येक एक तालिका है जिसे एक तालिका में संग्रहीत किया जाता है। [JSON लाइन्स CSV फ़ाइल](https://jsonlines.org/examples/) । जब कोई उपयोगकर्ता डेटा के लिए अनुरोध करता है, ERDDAP™ त्वरित रूप से प्रासंगिक लॉग फ़ाइलों को पढ़ता है, वे किए गए आदेश में डेटासेट में परिवर्तन लागू करता है, और फिर किसी अन्य की तरह उपयोगकर्ता के बाधाओं के माध्यम से अनुरोध को फ़िल्टर करता है। ERDDAP™ डेटा अनुरोध। विभिन्न लॉग फ़ाइलों में डेटा का विभाजन, सूचना के विभिन्न टुकड़ों का भंडारण (उदाहरण के लिए, कमांड का टाइमस्टैम्प, और क्या कमांड .insert था या .delete था) डेटासेट के सेटअप के विभिन्न पहलुओं और सभी इसे संभव बनाते हैं ERDDAP डेटा को स्टोर करने और इस डेटासेट से डेटा पुनर्प्राप्त करने के लिए बहुत जल्दी और बहुत कुशलतापूर्वक।
     
#### सुरक्षा और लेखक{#security-and-author} 
प्रत्येक .insert और .delete कमांड में शामिल होना चाहिए &लेखक = *लेखक* आखिरी पैरामीटर के रूप में, जहां लेखक \\_key लेखक के पहचानकर्ता से बना है (आपने चुना: नाम, प्रारंभिक, छद्मनाम, संख्या) , एक अंडरस्कोर और एक गुप्त कुंजी। The The most of the ERDDAP™ व्यवस्थापक वैध लेखक \\_key मानों की सूची उत्पन्न करने के लिए लेखकों के साथ काम करेगा, जिसे किसी भी समय बदला जा सकता है।
जब EDDTableFromHttpGet को .insert या .delete कमांड प्राप्त होता है, तो यह सुनिश्चित करता है कि लेखकID \\_key अंतिम पैरामीटर और मान्य है। क्योंकि यह अंतिम पैरामीटर है, यह इंगित करता है कि पूरी कमांड लाइन पहुंच गई है ERDDAP™ नहीं था। गुप्त कुंजी यह सुनिश्चित करती है कि केवल विशिष्ट लेखक डेटासेट में डेटा को सम्मिलित या हटा सकते हैं। ERDDAP™ फिर लेखक को निकालता है और उसे बचाता है कि लेखक चर में, ताकि कोई भी देख सके कि कौन डेटासेट में दिए गए बदलाव के लिए जिम्मेदार था।
.insert और .delete कमांड केवल के माध्यम से किया जा सकता है https:   (सुरक्षित)   ERDDAP™ यूआरएल यह सुनिश्चित करता है कि पारगमन के दौरान हस्तांतरित की जा रही जानकारी को गुप्त रखा गया है।
     
#### टाइमस्टैम्प{#timestamp} 
लॉग सिस्टम के हिस्से के रूप में, EDDTableFromHttpGet एक टाइमस्टैम्प जोड़ता है (उस समय ERDDAP अनुरोध प्राप्त) प्रत्येक आदेश के लिए यह लॉग फ़ाइलों में स्टोर करता है। क्योंकि ERDDAP™ टाइमस्टैम्प उत्पन्न करता है, लेखक नहीं, इससे कोई फर्क नहीं पड़ता कि अलग-अलग लेखक घड़ी के साथ कंप्यूटर से बदलाव कर रहे हैं, जो थोड़े अलग-अलग समय तक निर्धारित होते हैं। टाइमस्टैम्प निश्चित रूप से उस समय को इंगित करता है जब डेटासेट में बदलाव किया गया था।
     
#### HTTP POST{#http-post} 
*    [क्या HTTP POST के बारे में?](#http-post)   
HTTP [पोस्ट](https://en.wikipedia.org/wiki/POST_(HTTP) ) बेहतर विकल्प है (तुलना HTTP GET ) किसी क्लाइंट से HTTP सर्वर तक जानकारी भेजने के लिए। यदि आप कर सकते हैं, या यदि आप वास्तव में सुरक्षा में सुधार करना चाहते हैं, तो जानकारी भेजने के बजाय POST का उपयोग करें। ERDDAP । POST अधिक सुरक्षित है क्योंकि: GET के साथ और https यूआरएल को सुरक्षित तरीके से प्रेषित किया जाता है, लेकिन पूरे यूआरएल को सुरक्षित तरीके से प्रसारित किया जाता है। (पैरामीटर सहित, लेखक \\_key सहित) अपाचे, टॉमकैट को लिखा जाएगा, और ERDDAP™ लॉग फाइलें, जहां कोई उन्हें पढ़ सकता है अगर फाइलें ठीक से सुरक्षित नहीं हैं। POST के साथ, मापदंडों को सुरक्षित तरीके से प्रेषित किया जाता है और लॉग फ़ाइलों को नहीं लिखा जाता है। POST क्लाइंट्स के साथ काम करने के लिए थोड़ा कठिन है और क्लाइंट सॉफ्टवेयर द्वारा व्यापक रूप से समर्थन नहीं किया गया है, लेकिन प्रोग्रामिंग भाषाएं इसका समर्थन करती हैं। जिस सामग्री को आप GET या POST के माध्यम से डेटासेट में भेजते हैं, वही होगा, सिर्फ एक अलग तरीके से स्वरूपित।
     
####  http प्राप्त करना वैरिएबल्स ग्लोबल एटट्रिब्यू{#httpgetrequiredvariables-global-attribute} 
इस पूरे सिस्टम को बनाने का एक अनिवार्य हिस्सा आवश्यक वैश्विक विशेषता है http प्राप्त करना वैरिएबल्स, जो कि अल्पसंख्यक सूची है dataVariable स्रोत नाम जो विशिष्ट रूप से डेटा की एक पंक्ति की पहचान करते हैं। यह संभव के रूप में कम से कम होना चाहिए और लगभग हमेशा समय चर शामिल होगा। उदाहरण के लिए, यहां सिफारिश की गई है http प्राप्त करना प्रत्येक के लिए चर [CF Discrete Sampling Geometries (DSG) ](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries)   (बेशक, आईडी नाम आपके डेटासेट में अलग हो सकता है।) :

* टाइम सीरीज़ के लिए: stationID , समय
* ट्रेजेक्टरी के लिए: ट्रेजेक्टरीआईडी, समय
* प्रोफ़ाइल के लिए: समय (assuming time is the प्रोफ़ाइल \\_id) गहराई
* TimeSeries के लिए प्रोफ़ाइल: stationID , समय (assuming time is the प्रोफ़ाइल \\_id) गहराई
* ट्रेजेक्टरी प्रोफ़ाइल: trajectoryID, समय (assuming time is the प्रोफ़ाइल \\_id) गहराई

    
टाइमसीरीज़ को एक उदाहरण के रूप में लेना:
एक .insert कमांड को देखते हुए जिसमें शामिल हैं stationID = 46088 और समय = 2016-06-23T19:53:00Z (अन्य चर के लिए और अन्य मूल्यों) :
* यदि उस स्टेशन के लिए कोई मौजूदा डेटा नहीं है और उस समय, तो प्रभाव डेटासेट में डेटा जोड़ने के लिए होगा।
* यदि उस स्टेशन के लिए मौजूदा डेटा मौजूद है और उस समय, तो प्रभाव इस नए डेटा के साथ डेटा की मौजूदा पंक्ति को प्रतिस्थापित करना होगा। (बेशक, चूंकि ERDDAP™ प्रत्येक आदेश का लॉग इसे प्राप्त करता है, पुराने डेटा अभी भी लॉग में है। यदि कोई उपयोगकर्ता इस परिवर्तन से पहले डेटासेट के संस्करण से डेटा का अनुरोध करता है, तो वे पुराने डेटा देखेंगे।)   
         
####  http GetDirectoryStructure{#httpgetdirectorystructure} 
*    [ http GetDirectory संरचना वैश्विक विशेषता और डेटा (लॉग इन) फ़ाइल का नाम](#httpgetdirectorystructure)   
इस पूरे सिस्टम को कुशलतापूर्वक बनाने का हिस्सा यह है कि ERDDAP™ डेटा का एक सेट बनाता है (लॉग इन) प्रत्येक डेटासेट का एक अलग हिस्सा है। अगर ये अच्छी तरह से सेट हो जाते हैं, ERDDAP™ डेटा के लिए अधिकांश अनुरोधों को जल्दी से जवाब देने में सक्षम होगा। इस सेटअप द्वारा निर्दिष्ट है http GetDirectoryStructure वैश्विक विशेषता, जो एक स्ट्रिंग है जो एक सापेक्ष फ़ाइल नाम की तरह दिखता है, उदाहरण के लिए, " stationID / 10years", लेकिन वास्तव में निर्देशिका संरचना के लिए एक विनिर्देश है। इसके कुछ हिस्सों से संकेत मिलता है कि डेटा के लिए निर्देशिका और फ़ाइल नाम कैसे दिया जाए (लॉग इन) फ़ाइलों का निर्माण किया जाएगा।
    
    * अगर कोई हिस्सा एक पूर्णांक है (&gt;= 1) साथ ही एक समय पेरियोड (मिलीसेकंड, दूसरा, मिनट, घंटे, तारीख, महीना, वर्ष, या उनके बहुवचन) , उदाहरण के लिए, 10years, फिर EDDTableFromHttpGet डेटासेट डेटा की पंक्ति के लिए समय मान लेंगे (उदाहरण के लिए, 2016-06-23T19:53:00Z) उस समय की गणना करें जो उस परिशुद्धता के लिए truncated है (उदाहरण के लिए, 2010) , और उस से एक फ़ोल्डर या फ़ाइल नाम बनाएं।
        
लक्ष्य प्रत्येक फ़ाइल में डेटा का एक उचित रूप से बड़ा हिस्सा प्राप्त करना है, लेकिन 2GB से भी कम है।
        
    * अन्यथा, विनिर्देश का हिस्सा होना चाहिए dataVariable ' sourceName , उदाहरण के लिए, stationID । इस मामले में, EDDTableFromHttpGet डेटा की नई पंक्ति के लिए उस परिवर्तनीय के मूल्य से एक फ़ोल्डर या फ़ाइल नाम बना देगा (उदाहरण के लिए, "46088") ।
    
चूंकि .insert और .delete कमांड डेटा विशिष्ट डेटा में संग्रहीत किया जाता है (लॉग इन) फ़ाइलों, EDDTableFromHttpGet आम तौर पर केवल एक या कुछ डेटा खोलने की जरूरत है (लॉग इन) किसी दिए गए उपयोगकर्ता अनुरोध के लिए डेटा ढूंढने के लिए फाइलें। क्योंकि प्रत्येक डेटा (लॉग इन) फ़ाइल में डेटासेट के अपने हिस्से के लिए सभी प्रासंगिक जानकारी है, यह EDDTableFromHttpGet के लिए एक विशिष्ट संस्करण बनाने के लिए तेज़ और आसान है। (या वर्तमान संस्करण) उस फ़ाइल में डेटासेट के लिए डेटासेट (और पूरे डेटासेट के अनुरोधित संस्करण को उत्पन्न नहीं करना चाहिए) ।
    
सामान्य दिशानिर्देश डेटा की मात्रा और आवृत्ति पर आधारित हैं। यदि हम डेटा की प्रति पंक्ति 100 bytes मानते हैं, तो ...
``` 
    | Frequency  <br>of measurements | Recommended  <br>httpGetDirectoryStructure |
    | --- | --- |
    | \\>=1 per second | *featureID*/1year/1day |
    | \\>=1 per minute | *featureID*/2months |
    | \\>=1 per hour | *featureID*/10years |
    | \\>=1 per day | *featureID* |
```
उदाहरण के लिए, यदि निर्देशिका संरचना है stationID /2माह और आप दो स्टेशनों से डेटा डालने (46088 और 46155) दिसंबर 2015 से मई 2016 तक समय मान के साथ, EDDTableFromHttp 46088 और 46155 नामक निर्देशिकाओं का निर्माण करेगा और प्रत्येक नामित 2015-11 में फ़ाइलों का निर्माण करेगा। .json l, 2016-01 .json l, 2016-03 .json एल, 2016-05 .json एल (प्रत्येक प्रासंगिक स्टेशन के लिए डेटा के 2 महीने का मूल्य रखता है) । भविष्य में किसी भी समय, यदि आप डेटा को बदलने या हटाने के लिए .insert या .delete का उपयोग करते हैं, उदाहरण के लिए, 2016-04-05T14:45:00Z पर स्टेशन 46088, EDDTableFromHttp उस कमांड को 46088/2016-03 तक भेजेगा .json एल, प्रासंगिक डेटा (लॉग इन) फ़ाइल और स्पष्ट रूप से, भविष्य में किसी भी समय अन्य स्टेशनों के लिए डेटा जोड़ना ठीक है, क्योंकि डेटासेट केवल नए स्टेशनों से डेटा रखने की आवश्यकता के रूप में अतिरिक्त निर्देशिकाओं का निर्माण करेगा।
    
####  http GetKeys{#httpgetkeys} 
प्रत्येक EDDTable FromHttp डेटासेट के पास वैश्विक विशेषता होना चाहिए http GetKeys जो अनुमति प्राप्त लेखकों और उनके गुप्त कुंजी की सूची को एक अल्पविराम से अलग सूची के रूप में निर्दिष्ट करता है *लेखक* , उदाहरण के लिए, JohnSmith \\_someKey1, HOBOLogger \\_someKey2, QCScript59 \\_someKey3।
* लेखक \\_key's case-संवेदनशील होते हैं और पूरी तरह से ASCII वर्ण (#33 - #126) होना चाहिए, और बिना किसी वस्तु के, "या पात्र
* कुंजी पासवर्ड की तरह हैं, इसलिए वे MUST होना चाहिए &gt;=8 वर्ण, अनुमान लगाना मुश्किल है, और आंतरिक शब्दकोश शब्दों के बिना। जैसा कि आप पासवर्ड का इलाज करेंगे - उन्हें निजी रखें।
* पहला '\' चरित्र कुंजी से लेखक को अलग करता है, इसलिए लेखक का नाम '\' चरित्र शामिल नहीं किया जा सकता है। (लेकिन एक कुंजी कर सकते हैं) ।
* किसी भी लेखक के पास एक या अधिक लेखक हो सकता है \\key, उदाहरण के लिए, JohnSmith \\_some Key1, JohnSmith \\_some कुंजी 7, आदि
* आप किसी भी समय इस विशेषता का मान बदल सकते हैं। परिवर्तन अगली बार डेटासेट लोड होने पर प्रभाव डालते हैं।
* इस जानकारी को डेटासेट के वैश्विक एट्रिब्यूट्स से हटा दिया जाएगा इससे पहले कि इसे सार्वजनिक कर दिया गया है।
* डेटासेट को डालने या हटाने के लिए प्रत्येक अनुरोध में एक &लेखक = शामिल होना चाहिए *लेखक* पैरामीटर कुंजी की वैधता को सत्यापित करने के बाद, ERDDAP™ केवल लेखक को बचाता है (नहीं) डेटा फ़ाइल में।

#### सेट अप{#set-up} 

यहां एक EDDTableFromHttpGet डेटासेट स्थापित करने के लिए अनुशंसित कदम हैं:

1. इस डेटासेट के डेटा को रखने के लिए मुख्य निर्देशिका बनाएं। इस उदाहरण के लिए, Let's use /data/testGet/. उपयोगकर्ता चल रहा है GenerateDatasetsXml और उपयोगकर्ता चल रहा है ERDDAP™ दोनों ही इस निर्देशिका के लिए पढ़ने लिखने का उपयोग करना चाहिए।
     
2. एक नमूना बनाने के लिए एक पाठ संपादक का उपयोग करें .json एक्सटेंशन के साथ CSV फ़ाइल .json उस निर्देशिका में l
नाम महत्वपूर्ण नहीं है। उदाहरण के लिए, आप इसे नमूना कह सकते हैं .json एल
2 पंक्तियां बनाएं .json l CSV फ़ाइल, पहली पंक्ति और dummy/typical मान पर कॉलम नामों के साथ (सही डेटा प्रकार का) दूसरी पंक्ति में। यहाँ एक नमूना फ़ाइल है जो एक संग्रह के लिए उपयुक्त है featureType = TimeSeries डेटा जो हवा और पानी के तापमान को मापा जाता है।
     \\[ के लिए featureType = ट्रेजेक्टरी, आप बदल सकते हैं stationID to be trajectoryid. \\]   
     \\[ के लिए featureType = प्रोफाइल, आप बदल सकते हैं stationID प्रोफ़ाइल आईडी होना और एक गहराई परिवर्तनीय जोड़ने के लिए। \\] 
    
     \\[ " stationID ", "time" , " अक्षांश", "longitude", "airTemp", "waterTemp", "timestamp", "लेखक", "command" \\] 
     \\[ "myStation", "2018-06-25T17:00Z", 0.0, 0.0, 0.0, 0.0, 0.0, "SomeBody", 0 \\] 
    
ध्यान दें:
    * वास्तविक डेटा मान कोई फर्क नहीं पड़ता क्योंकि आप अंततः इस फ़ाइल को हटा देंगे, लेकिन उन्हें सही डेटा प्रकार का होना चाहिए। विशेष रूप से, समय चर उसी प्रारूप का उपयोग करना चाहिए जो स्रोत से वास्तविक डेटा का उपयोग करेगा।
    * सभी चरों के लिए, sourceName बराबर होगा destinationName इसलिए उस जानकारी के साथ चर होने पर समय, अक्षांश, देशांतर और कभी-कभी गहराई या ऊंचाई सहित सही / अंतिम परिवर्तनीय नामों का उपयोग करें।
    * लगभग हमेशा एक चर नाम का समय होगा जो अवलोकन के समय को रिकॉर्ड करता है। यह डेटाटाइप स्ट्रिंग के साथ हो सकता है [स्ट्रिंग समय के लिए उपयुक्त इकाइयों](#string-time-units)   (उदाहरण के लिए yyyy-MM-dd 'T'H:mm:ss.SSSZ) डेटा टाइप डबल के साथ [संख्यात्मक समय के लिए उपयुक्त इकाइयों](#time-units)   (उदाहरण के लिए, 1970-01-01T00:00:00Z के बाद से सेकंड, या कुछ अन्य आधार समय) ।
    * तीन स्तंभ (आमतौर पर अंतिम तीन) टाइमस्टैम्प, लेखक, कमांड होना चाहिए।
    * टाइमस्टैम्प कॉलम का उपयोग EDDTableFromHttpGet द्वारा एक टाइमस्टैम्प जोड़ने के लिए किया जाएगा, यह दर्शाता है कि डेटा फ़ाइल में डेटा की एक दी गई लाइन को जोड़ा गया है। इसमें 1970-01-01T00:00:00Z के बाद से डेटाटाइप डबल और यूनिट सेकंड होंगे।
    * डेटाटाइप स्ट्रिंग के साथ लेखक कॉलम का उपयोग रिकॉर्ड करने के लिए किया जाएगा जो अधिकृत लेखक ने इस लाइन के डेटा को प्रदान किया। अधिकृत लेखकों द्वारा निर्दिष्ट कर रहे हैं [ http GetKeys वैश्विक विशेषता](#httpgetkeys) । हालांकि कुंजी को निर्दिष्ट किया गया है *लेखक* और उस रूप में "request" URL में हैं, केवल लेखक का हिस्सा डेटा फ़ाइल में बचाया जाता है।
    * डेटाटाइप बाइट के साथ कमांड कॉलम इंगित करेगा कि इस लाइन पर डेटा एक सम्मिलन है या नहीं। (0) या हटाने (1) ।
         
3. रन जेनरेटडाटासेट एक्सएमएल और इसे बताओ
    
    1. डेटासेट प्रकार EDDTableFromHttpGet है
    2. निर्देशिका है (इस उदाहरण के लिए) /data / test प्राप्त करें
    3. नमूना फ़ाइल है (इस उदाहरण के लिए) /data / testGet / स्टार्टअप .json एल
    4. The The most of the http प्राप्त करना चर (इस उदाहरण के लिए)   stationID समय विवरण देखें [ http प्राप्त करना](#httpgetrequiredvariables-global-attribute) नीचे।
    5. यदि डेटा हर 5 मिनट में एकत्र होता है, तो डेटा हर 5 मिनट में एकत्र होता है। http इस उदाहरण के लिए GetDirectoryStructure है stationID /2 महीना। विवरण देखें [ http GetDirectoryStructure](#httpgetdirectorystructure) नीचे।
    6. The The most of the [ http GetKeys](#httpgetkeys) 
    
आउटपुट जोड़ें (का हिस्सा datasets.xml डेटासेट के लिए) to datasets.xml ।
     
4. संपादित करें datasets.xml इस डेटासेट के लिए यह सही और पूरा करने के लिए भाग लें।
विशेष रूप से, सभी को बदलें सही सामग्री के साथ।
     
5. के लिए&lt;फ़ाइलTableInMemory&gt; सेटिंग:
    * इसे सच करने के लिए सेट करें यदि डेटासेट आमतौर पर लगातार .insert और/or .delete अनुरोध प्राप्त करेगा। (उदाहरण के लिए, अक्सर हर 10 सेकंड में एक बार से अधिक बार) । यह EDDTableFromHttpGet की मदद करता है। यदि आप इसे सच करने के लिए सेट करते हैं, तो EDDTableFromHttpGet अभी भी फ़ाइल को सहेज देगा समय-समय पर डिस्क से संबंधित जानकारी (आवश्यकता के रूप में, लगभग हर 5 सेकंड) ।
    * इसे गलत तरीके से सेट करें (डिफ़ॉल्ट) यदि डेटासेट आमतौर पर गलत हो जाएगा। (उदाहरण के लिए, हर 10 सेकंड में एक बार से कम) ।
         
6. ध्यान दें: उपयोग करना संभव है&lt;कैशFromUrl&gt; और संबंधित सेटिंग्स में datasets.xml EDDTable FromHttp किसी अन्य पर दूरस्थ EDDTableFromHttpGet डेटासेट की स्थानीय प्रतिलिपि बनाने और बनाए रखने के तरीके के रूप में डेटासेट प्राप्त करें ERDDAP । हालांकि, इस मामले में, यह स्थानीय डेटासेट किसी भी .insert और .delete अनुरोध को अस्वीकार करेगा।

#### EDDTable FromHttpGet Dataset{#using-eddtablefromhttpget-datasets} 

* लेखक "request" बना सकते हैं जो [डेटासेट से डेटा को कन्वर्ट या हटा दें](#insert-and-delete) ।
     
* डेटासेट में वास्तविक डेटा डालने के बाद, आप मूल नमूना डेटा फ़ाइल को हटा सकते हैं और हटा सकते हैं।
     
* उपयोगकर्ता डेटासेट से डेटा का अनुरोध कर सकते हैं क्योंकि वे किसी अन्य EDDTable डेटासेट के लिए करते हैं ERDDAP । यदि अनुरोध में टाइमस्टैम्प कॉलम पर एक बाधा शामिल नहीं है, तो अनुरोध डेटासेट के वर्तमान संस्करण से डेटा प्राप्त करता है (सभी सम्मिलन और हटाने के आदेशों को संसाधित करने के बाद लॉग फ़ाइल और फिर से वर्गीकरण द्वारा http प्राप्त करना) ।
     
* उपयोगकर्ता उन अनुरोधों को भी बना सकते हैं जो EDDTableFromHttpGet डेटासेट के लिए विशिष्ट हैं:
    * यदि अनुरोध में शामिल है&lt;या&lt;= टाइमस्टैम्प कॉलम की बाधा, फिर ERDDAP™ निर्दिष्ट टाइमस्टैम्प तक लॉग फ़ाइल की पंक्तियों को संसाधित करता है। प्रभाव में, यह अस्थायी रूप से उस समय के बाद से डेटासेट में किए गए सभी परिवर्तनों को हटा देता है। अधिक जानकारी के लिए, देखें [संस्करण](#versioning) ।
    * यदि अनुरोध में एक&gt;,&gt;=, या = टाइमस्टैम्प कॉलम की बाधा, उदाहरण के लिए, और टाइमस्टैम्प शामिल हैं।&lt;=0, फिर ERDDAP™ डेटा फ़ाइलों से डेटा लौटाता है, बिना प्रविष्टि और हटाने के आदेश को संसाधित किए।
* भविष्य में, हम मानते हैं कि उपकरण बनाया जाएगा (हमारे द्वारा? आपके द्वारा?) इन डेटासेट के साथ काम करने के लिए। उदाहरण के लिए, एक स्क्रिप्ट हो सकती है जो कच्चे लॉग फ़ाइलों को पढ़ती है, एक अलग अंशांकन समीकरण लागू करती है, और उस व्युत्पन्न जानकारी के साथ एक अलग डेटासेट उत्पन्न करती है। ध्यान दें कि स्क्रिप्ट को एक अनुरोध के माध्यम से मूल डेटा प्राप्त हो सकता है ERDDAP™   (जो फ़ाइल प्रारूप में डेटा प्राप्त करता है जो स्क्रिप्ट के साथ काम करने के लिए सबसे आसान है) और नए डेटासेट को .insert "request" के माध्यम से उत्पन्न / अद्यतन करने के लिए ERDDAP । स्क्रिप्ट को डेटा फ़ाइलों तक सीधी पहुंच की आवश्यकता नहीं है; यह किसी भी अधिकृत लेखक के कंप्यूटर पर हो सकता है।
     

#### EDDTableFromHttpGet{#detailed-information-about-eddtablefromhttpget} 

विषय हैं:

*    [सेटअप को नहीं बदला&#33;](#dont-change-the-setup) 
*    [CRUD](#crud) 
*    [InvalidRequests](#invalidrequests) 
*    [गति](#httpget-speed) 
*    [रोबस्ट](#robust) 
*    [सिस्टम विश्वसनीयता](#system-reliability) 
*    [संस्करण](#versioning) 
*    ["What about PUT and DELETE?&#33;](#https-put-and-delete) 
*    [नोट्स](#httpget-notes) 
*    [मूल विचार के लिए CHORDS को धन्यवाद।](#thanks) 

यहाँ विस्तृत जानकारी है:

##### सेटअप को नहीं बदला&#33;{#dont-change-the-setup} 
एक बार डेटासेट बनाया गया है और आपने इसमें डेटा जोड़ा है:

* नहीं जोड़ना या हटाना dataVariable S.
* नहीं बदला sourceName या destinationName (d) dataVariable S.
* डेटा को नहीं बदल सकता का प्रकार dataVariable S. लेकिन आप बदल सकते हैं dataVariable मेटाडाटा
* नहीं बदला http प्राप्त करना वैरिएबल्स वैश्विक विशेषता।
* नहीं बदला http GetDirectoryStructure वैश्विक विशेषता.

यदि आपको इन चीजों में से किसी को बदलने की आवश्यकता है, तो एक नया डेटासेट करें और सभी डेटा को नए डेटासेट में स्थानांतरित करें।
     
##### CRUD{#crud} 
कंप्यूटर विज्ञान में, डेटासेट के साथ काम करने के लिए चार मूलभूत आदेश हैं [CREATE, READ, UPDATE, DELETE (CRUD) ](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) । SQL, संबंधिक डेटाबेस के साथ काम करने की भाषा, INSERT, SELECT, UPDATE और DELETE में बराबर है। EDDTableFromHttpGet

* Insert CREATE और UPDATE का एक संयोजन है।
* .delete DELETE है।
* डेटा के सबसेट के अनुरोध के लिए नियमित प्रणाली READ है।

इस प्रकार, EDDTableFromHttpGet डेटासेट के साथ काम करने के लिए सभी बुनियादी आदेशों का समर्थन करता है।
     
* .insert या .delete अनुरोध बिना त्रुटियों के HTTP स्टेटस कोड = 200 और एक JSON ऑब्जेक्ट लौटा देगा, उदाहरण के लिए,
```
    {
    "status":"success",
    "nRowsReceived":1,
    "stringTimestamp":"2018-03-26T15:34:05.552Z",
    "numericTimestamp":1.522078445552E9
    }
```
दो टाइमस्टैम्प मान उसी मिलीसेकंड को संदर्भित करते हैं, जो मिलीसेकंड है जो डेटा की पंक्तियों के लिए टाइमस्टैम्प चर में संग्रहीत किया जाएगा जो डाला गया था या हटा दिया गया था। ERDDAP™ भविष्य में इन प्रमुख मूल्य जोड़ों के नाम और स्वरूपण को नहीं बदलेगा। ERDDAP™ भविष्य में JSON ऑब्जेक्ट में अतिरिक्त कुंजी-मूल्य जोड़े जोड़ सकते हैं।
     
##### InvalidRequests{#invalidrequests} 
Invalid .insert या .delete अनुरोध स्टेटस = 200 के अलावा एक HTTP त्रुटि स्टेटस कोड वापस कर देगा और डेटासेट में कोई बदलाव नहीं किया जाएगा। इसमें गलत लेखक की जानकारी, गलत परिवर्तनीय नाम, विभिन्न चरों के लिए अलग-अलग सरणी लंबाई, लापता आवश्यक चर, लापता आवश्यक चर मान आदि के साथ अनुरोध शामिल हैं। यदि अनुरोध में एक से अधिक डेटा फ़ाइल शामिल है, तो यह संभव है कि अनुरोध का हिस्सा सफल हो जाएगा और भाग विफल हो जाएगा। हालांकि यह एक समस्या नहीं होनी चाहिए अगर सेंसर अनुरोध भेजने से पूर्ण विफलता के रूप में किसी भी विफलता का इलाज होता है। उदाहरण के लिए, यदि आप बताते हैं ERDDAP™ डालने के लिए (या हटाना) एक पंक्ति में दो बार एक ही डेटा, सबसे खराब मामला यह है कि सूचना दो बार संग्रहीत की जाती है, लॉग फ़ाइल में एक साथ बंद होती है। यह देखना मुश्किल है कि कैसे वह परेशानी पैदा कर सकता है।
     
##### HttpGet स्पीड{#httpget-speed} 
.insert या .delete अनुरोध के लिए (गिनती नहीं http ओवरहेड) , बॉलपार्क .insert या .delete की गति है
डेटा की 1 पंक्ति के साथ 1ms प्रति .insert
सरणी में डेटा की 10 पंक्तियों के साथ प्रति .insert 2ms ( \\[  \\] )   
सरणी में डेटा की 100 पंक्तियों के साथ प्रति .insert 3ms ( \\[  \\] )   
सरणी में डेटा की 1000 पंक्तियों के साथ प्रति .insert 13ms ( \\[  \\] )   
स्पष्ट रूप से सरणी के लिए कुंजी हैं [उच्च throughput](#httpget-speed) । सरणी के बिना, यह एक दूरस्थ लेखक से प्रति सेकंड 8 पंक्तियों से अधिक डेटा को निष्क्रिय या निष्क्रिय करने के लिए चुनौतीपूर्ण होगा। (नेटवर्क के सभी ओवरहेड के कारण) । सरणी के साथ, रिमोट सेंसर से प्रति सेकंड 1000 पंक्तियों से अधिक डेटा को निष्क्रिय करना या निष्क्रिय करना आसान होगा।

प्रति अनुरोध बहुत बड़ी मात्रा में डेटा के साथ, आप अधिकतम क्वेरी लंबाई तक टॉमकैट की सीमा को हिट करेंगे (डिफ़ॉल्ट 8KB है?) , लेकिन इसे अपने में अधिकतम HttpHeaderSize सेटिंग को संपादित करके बढ़ाया जा सकता है *tomcat* /conf /server.xml का HTTP / 1.1 कनेक्टर प्रविष्टि

कब ERDDAP™ JSON लाइन्स CSV डेटा पढ़ता है (लॉग इन) फाइलें, द्विआधारी डेटा फ़ाइलों को पढ़ने की तुलना में एक छोटा समय दंड है। हमने महसूस किया कि जब रीडिंग डेटा लिखते समय सिस्टम की गति और मजबूती के लिए भुगतान करने की उचित कीमत थी तो इस समय जुर्माना लगाया गया था। (जो प्राथमिक महत्व का है) ।

##### एसएसडी{#ssd} 
 [अधिक गति के लिए,](#ssd) उपयोग करना [सॉलिड स्टेट ड्राइव (एसएसडी) ](https://en.wikipedia.org/wiki/Solid-state_drive) डेटा को स्टोर करने के लिए। उनके पास बहुत तेज़ फाइल एक्सेस टाइम है ()&lt;हार्ड डिस्क ड्राइव की तुलना में 0.1ms) (3 - 12 ms) । उनके पास एक तेज़ डेटा ट्रांसफर दर भी है (200 - 2500 MB/s) हार्ड डिस्क ड्राइव से (~200 MB/s) । हाल के वर्षों में उनकी लागत काफी कम हो गई है। हालांकि पहले SSD के पास बड़ी संख्या में लिखने के बाद किसी दिए गए ब्लॉक में समस्या थी, लेकिन यह समस्या अब बहुत कम हो गई है। यदि आप एक बार डेटा लिखने के लिए एसएसडी का उपयोग करते हैं तो इसे कई बार पढ़ा जाए, यहां तक कि एक उपभोक्ता-ग्रेड एसएसडी (जो एंटरप्राइज़-ग्रेड एसएसडी की तुलना में काफी कम महंगा है) लंबे समय तक रहना चाहिए।
    
##### रोबस्ट{#robust} 
हमने इस प्रणाली को आसानी से काम करने और जितना संभव हो उतना मजबूत बनाने की कोशिश की है।
* प्रणाली को कई धागे बनाने के लिए डिज़ाइन किया गया है (उदाहरण के लिए, सेंसर, एक स्वचालित क्यूसी स्क्रिप्ट और एक मानव) एक ही डेटासेट और यहां तक कि एक ही फ़ाइल पर काम करते हैं। इसमें से अधिकांश डेटा को संग्रहीत करने और एक बहुत ही सरल फ़ाइल प्रकार का उपयोग करके लॉग फ़ाइल दृष्टिकोण का उपयोग करके संभव बनाया गया है। [JSON लाइन्स CSV फ़ाइलों](https://jsonlines.org/examples/) डेटा को स्टोर करने के लिए।
* JSON लाइन्स CSV के लिए एक और बड़ा लाभ यह है कि यदि कोई फ़ाइल कभी भ्रष्ट हो जाती है (उदाहरण के लिए, एक लाइन पर त्रुटि के कारण अमान्य) फ़ाइल को टेक्स्ट एडिटर में खोलना आसान है और समस्या को ठीक करना आसान है।
* एक अन्य लाभ यह है कि यदि किसी फ़ाइल में एक लाइन पर कोई त्रुटि है, तो सिस्टम अभी भी त्रुटि लाइन से पहले और बाद में सभी डेटा को लाइनों पर पढ़ा सकता है। और सिस्टम अभी भी अतिरिक्त .insert और .delete जानकारी लॉग इन कर सकते हैं।
* एडमिन-सहायक मानक फ़ाइलों का उपयोग करने का एक बड़ा लाभ (एक संबंधिक डेटाबेस या Cassandra या अन्य सॉफ्टवेयर की तुलना में) : कोई अन्य सॉफ्टवेयर नहीं है जिसे बनाए रखा जाना है और जो डेटा को स्टोर करने या पुनर्प्राप्त करने के लिए चल रहा है। और किसी भी समय मानक फ़ाइलों को वापस करना आसान है और एक वृद्धिशील तरीके से क्योंकि डेटा चंक में है। (थोड़ी देर के बाद, प्रत्येक स्टेशन के लिए केवल वर्तमान समय की फ़ाइल बदल जाएगी) । इसके विपरीत, डेटाबेस से और Cassandra से बाहरी बैकअप फ़ाइलों को बनाने के लिए यह काफी प्रयास और सिस्टम डाउन टाइम लेता है।
         
##### सिस्टम विश्वसनीयता{#system-reliability} 
एक सर्वर के साथ उम्मीद करना उचित है ERDDAP™ 99.9% अपटाइम - यह प्रति वर्ष लगभग 9 घंटे का डाउनटाइम है (हालांकि, आप एक बुरी रात में इसका उपयोग कर सकते हैं&#33;) ।
यदि आप मेहनती और भाग्यशाली हैं, तो आपको 99.99% अपटाइम मिल सकता है (प्रति वर्ष 53 मिनट) चूंकि अद्यतन के लिए कुछ ही पुनरारंभ होता है, इसलिए उस समय बहुत कुछ होगा।
आपको चरम उपाय करना होगा (एक अलग बैकअप सर्वर, निर्बाध बिजली की आपूर्ति, बैकअप एयर कंडीशनिंग, साइट की निगरानी के लिए 24x7x365 कर्मियों आदि।) 99.999% uptime (5.25 मिनट प्रति वर्ष डाउनटाइम) । फिर भी, यह बहुत संभावना नहीं है कि आप 99.999% uptime प्राप्त करेंगे (99.99%) क्योंकि समस्याएं अक्सर आपके नियंत्रण के बाहर होती हैं। उदाहरण के लिए, अमेज़ॅन वेब सर्विस और गूगल आश्चर्यजनक रूप से विश्वसनीय वेब सेवाओं की पेशकश करते हैं, फिर भी उनमें से बड़े वर्गों को कभी-कभी घंटों के लिए नीचे दिया जाता है।

इसे चेहरा, हर कोई चाहता है ERDDAP™ 100% uptime, या कम से कम vaunted "six nines" (99.9999% अपटाइम प्रति वर्ष डाउनटाइम के 32 सेकंड के बराबर है) लेकिन ऐसा कोई तरीका नहीं है कि आप इसे कितना समय, प्रयास और पैसा खर्च करते हैं।

लेकिन ERDDAP™ अपटाइम यहाँ वास्तविक लक्ष्य नहीं है। लक्ष्य विश्वसनीय बनाना है **प्रणाली** किसी भी डेटा को खोना नहीं है। यह एक सोल्वेबल समस्या है।

समाधान यह है: कंप्यूटर सॉफ्टवेयर में गलती-सहिष्णुता का निर्माण जो डेटा को डेटा भेज रहा है ERDDAP । विशेष रूप से, सॉफ़्टवेयर को डेटा के एक कतार को बनाए रखना चाहिए जो जाने की प्रतीक्षा करता है ERDDAP । जब डेटा कतार में जोड़ा जाता है, तो सॉफ़्टवेयर को प्रतिक्रिया की जांच करनी चाहिए ERDDAP । यदि प्रतिक्रिया में डेटा प्राप्त नहीं होता है। कोई त्रुटि नहीं, फिर सॉफ्टवेयर को कतार में डेटा छोड़ देना चाहिए। जब अधिक डेटा उत्पन्न होता है और कतार में जोड़ा जाता है, तो सॉफ्टवेयर को फिर से कतार में डेटा को इंसर्ट करने की कोशिश करनी चाहिए। (शायद \\[  \\] प्रणाली) । यह सफल होगा या विफल हो जाएगा। यदि यह विफल हो जाता है, तो यह बाद में फिर से कोशिश करेगा। यदि आप इस तरह से काम करने के लिए सॉफ्टवेयर लिखते हैं और यदि सॉफ्टवेयर डेटा के कुछ दिनों के लिए कतार बनाने के लिए तैयार है, तो आपके पास वास्तव में सेंसर के डेटा का 100% अपलोड करने का एक अच्छा मौका है। ERDDAP । और आपने इसे बिना किसी प्रयास या व्यय के किया होगा।

 \\[ पृष्ठभूमि: हम यह नहीं सोचते थे। [यह कैसे कंप्यूटर नेटवर्क विश्वसनीयता प्राप्त करते हैं।](https://en.wikipedia.org/wiki/Reliability_(computer_networking) ) कंप्यूटर नेटवर्क स्वाभाविक रूप से अविश्वसनीय हैं। जब आप एक कंप्यूटर से दूसरे कंप्यूटर में एक फ़ाइल ट्रांसफर करते हैं, तो भेजने वाले सॉफ्टवेयर को पता चलता है कि कुछ पैकेट खो सकते हैं। यदि इसे प्राप्तकर्ता से दिए गए पैकेट के लिए उचित स्वीकृति नहीं मिलती है, तो यह खोए हुए पैकेट को फिर से भेज देता है। इस दृष्टिकोण के साथ, अपेक्षाकृत सरल प्रेषक और रिसीवर सॉफ्टवेयर एक अविश्वसनीय नेटवर्क के शीर्ष पर एक विश्वसनीय फ़ाइल ट्रांसफर सिस्टम का निर्माण कर सकता है। \\] 
    
##### क्यों JSON लाइन्स CSV फ़ाइलें?{#why-json-lines-csv-files} 
EDDTableFromHttpGet उपयोग [JSON लाइन्स CSV फ़ाइलों](https://jsonlines.org/examples/) डेटा भंडारण के लिए। कारण हैं:

* मुख्य कारण यह है: JSON लाइन्स CSV फ़ाइलों की सादगी एकाधिक धागे को दिए गए फ़ाइल में लिखने की अनुमति देने के लिए एक तेज़, आसान और विश्वसनीय तरीका प्रदान करती है। (उदाहरण के लिए, फ़ाइल नाम पर सिंक्रनाइज़ करके) ।
* अगर एक JSON लाइन CSV फ़ाइल कभी भ्रष्ट हो गया (उदाहरण के लिए, एक लाइन पर त्रुटि के कारण अमान्य) , EDDTableFromFromHttpGet अभी भी त्रुटि रेखा से पहले और बाद में सभी लाइनों पर डेटा पढ़ा सकता है। और .insert और .delete प्रणाली डेटा फ़ाइल में नए डेटा जोड़ने के लिए जारी रख सकता है।
* चूंकि JSON लाइन्स CSV फाइलें ASCII फाइलें हैं, यदि कभी कोई फ़ाइल भ्रष्ट हो गई तो यह तय करना आसान होगा। (पाठ संपादक में) ।
* JSON लाइन्स CSV समर्थन यूनिकोड तार।
* JSON लाइन्स CSV परिवर्तनीय लंबाई स्ट्रिंग का समर्थन करता है (कुछ अधिकतम लंबाई तक सीमित नहीं) ।
* JSON लाइन्स CSV 64 बिट पूर्णांक का समर्थन करता है (लंबा) ।
* JSON लाइन्स CSV के औपचारिक प्रकृति और अतिरिक्त वाक्यविन्यास (पुराने स्कूल CSV बनाम) कुछ अतिरिक्त आश्वासन प्रदान करता है कि किसी दिए गए लाइन को भ्रष्ट नहीं किया गया है।

हमने शुरू में उपयोग करने की कोशिश की .nc एक असीमित आयाम के साथ 3 फाइलें। हालांकि, समस्याएं थीं:

* मुख्य समस्या थी: एकाधिक धागे को लिखने की अनुमति देने का कोई विश्वसनीय तरीका नहीं है .nc 3 फ़ाइल, भले ही धागे एक सिंक्रनाइज़ तरीके से लिखने के द्वारा सहयोग करते हैं।
* यदि .nc 3 फ़ाइल भ्रष्ट हो जाती है, .insert और .delete प्रणाली फ़ाइल का उपयोग जारी नहीं रख सकती है।
* क्योंकि .nc 3 फाइलें द्विआधारी हैं, यदि कोई फ़ाइल भ्रष्ट हो जाती है (जो वे बहु-थ्रेडिंग समस्या के कारण करते हैं) वे निश्चित रूप से कठिन या असंभव हैं। मरम्मत के लिए कोई उपकरण नहीं है।
* CF में स्ट्रिंग्स की एन्कोडिंग को निर्दिष्ट करने का कोई तरीका नहीं है, इसलिए यूनिकोड, उदाहरण के लिए, UTF-8 एन्कोडिंग का समर्थन करने का कोई आधिकारिक तरीका नहीं है। हम एक \\_Encoding विशेषता का समर्थन करने के लिए CF प्राप्त करने की कोशिश की लेकिन किसी भी प्रगति करने में असमर्थ थे। ( Unidata उनके क्रेडिट के लिए, \\_Encoding विशेषता का समर्थन करता है।) 
*    .nc 3 फाइलें केवल निश्चित लंबाई स्ट्रिंग का समर्थन करती हैं। फिर, हमने CF प्राप्त करने की कोशिश की और Unidata चर लंबाई स्ट्रिंग का समर्थन करने के लिए लेकिन किसी भी प्रगति को बनाने में असमर्थ थे।
*    .nc 3 फाइलें स्ट्रिंग चर से एकल वर्ण चर को अलग करने के लिए एक आसान तरीका का समर्थन नहीं करती हैं। फिर, हमने CF प्राप्त करने की कोशिश की और Unidata इन दो डेटा प्रकारों को अलग करने के लिए एक प्रणाली का समर्थन करने के लिए, लेकिन किसी भी प्रगति को बनाने में असमर्थ थे।
*    .nc 3 फाइलें केवल एक निर्दिष्ट एन्कोडिंग के साथ 8-बिट वर्णों का समर्थन करती हैं। फिर, हमने CF प्राप्त करने की कोशिश की और Unidata एन्कोडिंग निर्दिष्ट करने के लिए एक प्रणाली का समर्थन करने के लिए, लेकिन कोई प्रगति करने में असमर्थ थे।
*    .nc 3 फाइलें 64-बिट पूर्णांक का समर्थन नहीं करती हैं (लंबा) । फिर, हमने CF प्राप्त करने की कोशिश की और Unidata लंबे समय तक सिस्टम का समर्थन करने के लिए, लेकिन किसी भी प्रगति को बनाने में असमर्थ थे।
         
##### संस्करण{#versioning} 
क्योंकि EDDTable FromHttp टाइमस्टैम्प और प्रत्येक परिवर्तन के लेखक के साथ डेटासेट में सभी परिवर्तनों का एक लॉग स्टोर करें, यह जल्दी से उस डेटासेट को किसी भी समय के रूप में पुनर्निर्मित कर सकता है। एक अर्थ में, समय में किसी भी बिंदु के लिए एक संस्करण है। यदि डेटा के लिए उपयोगकर्ता के अनुरोध में टाइमस्टैम्प शामिल है&lt;= constraint, उदाहरण के लिए, और timestamp&lt;= 2016-06-23T16:32:22.128Z (या किसी भी समय बिंदु) लेकिन लेखक या आदेश की कोई बाधा नहीं है। ERDDAP™ पहली बार उस समय के रूप में डेटासेट के एक संस्करण उत्पन्न करके अनुरोध का जवाब देगा। फिर, ERDDAP™ उपयोगकर्ता की अन्य बाधाओं को लागू करता है, जैसा कि डेटा के लिए किसी अन्य अनुरोध के साथ ERDDAP । EDDTableFromHttpGet स्थापित किया गया है ताकि यह प्रक्रिया बहुत तेज और कुशल हो, यहां तक कि बहुत बड़े डेटासेट के लिए भी।

इसी तरह, एक उपयोगकर्ता तब पता लगा सकता है जब डेटासेट को अनुरोध करके अद्यतन किया गया था। (टाइमस्टैम्प) और निर्धारित () 

और डेटा के लिए किसी भी अनुरोध के लिए, डेटासेट के किसी भी संस्करण के लिए, उपयोगकर्ता देख सकते हैं कि कौन से लेखक ने कौन-सा परिवर्तन किया है, और जब उन्होंने उन्हें बनाया।

यह संस्करण सिस्टम सक्षम बनाता है [Reproducible Science](https://en.wikipedia.org/wiki/Reproducibility) किसी भी समय, किसी भी समय, किसी भी समय डेटासेट के संस्करण से डेटा अनुरोध कर सकता है। यह ठीक-ग्रेन संस्करण किसी अन्य प्रणाली के साथ संभव नहीं है जिसे हम जानते हैं। अंतर्निहित तंत्र बहुत कुशल है, जिसमें कोई अतिरिक्त भंडारण स्थान की आवश्यकता नहीं है, और प्रसंस्करण ओवरहेड वास्तव में न्यूनतम है।

हर किसी के पास इस प्रकार के ठीक-ग्रेन संस्करण की आवश्यकता नहीं है, लेकिन यह बहुत उपयोगी है, शायद आवश्यक है, एक बड़े डेटा प्रबंधन संगठन के संदर्भ में (उदाहरण के लिए, OOI, अर्थ क्यूब, डेटा वन और NOAA एनसीईआरटी) जहां डेटासेट में एकाधिक लेखक हो सकते हैं (उदाहरण के लिए, सेंसर, एक स्वचालित क्यूसी स्क्रिप्ट और एक मानव संपादक) ।

 \\[ इतिहास: इस प्रकार के संस्करण की आवश्यकता पहले मेरे लिए आई थी (बॉब) 2008 में OI के बारे में पढ़ने और चर्चा करते समय। उस समय, OOI में गिट पर आधारित संस्करण के लिए एक बोझिल, धीमी, अक्षम प्रणाली थी। गिट क्या यह के लिए डिजाइन किया गया था के लिए महान है, लेकिन यह नहीं। 2008 में, जबकि एक OOI चर्चा में, मैंने डेटा प्रबंधन के लिए एक व्यापक, कुशल वैकल्पिक-से-OOI प्रणाली तैयार की, जिसमें कई विशेषताएं शामिल हैं जिन्हें मैंने जोड़ा है। ERDDAP™ तब से, और इस संस्करण प्रणाली सहित। उस समय और उसके बाद से, ओओआई अपने संस्करण प्रणाली के लिए प्रतिबद्ध था और विकल्पों में रुचि नहीं थी। 2016 में, इस योजना के अन्य पहलू सामने आए और मैंने इसे लागू करना शुरू कर दिया। क्योंकि अन्य परियोजनाओं पर काम करने के लिए कई रुकावटें थीं, मैंने 2018 तक खत्म नहीं किया था। अब भी, मैं किसी भी अन्य वैज्ञानिक डेटा सिस्टम से अवगत नहीं हूं जो अक्सर डेटासेट बदलने के लिए किसी भी समय किसी भी बिंदु से डेटा के एक संस्करण तक ऐसी त्वरित और आसान पहुंच प्रदान करता है। सरल फ़ाइल सिस्टम इसे प्रदान नहीं करते हैं। रिलेशनल डेटाबेस नहीं है। Cassandra नहीं है। \\] 
    
##### https://www.youtu.com{#https-put-and-delete} 
*    ["What के बारे में HTTPS PUT और DELETE?&#33;](#https-put-and-delete)   
     [हाइपरटेक्स्ट ट्रांसफर प्रोटोकॉल (HTTP) ](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) वर्ल्ड वाइड वेब का आधार है और कारण यह है कि वेब पेज यूआरएल "के साथ शुरू होता हैhttp://"या "https://"। HTTP एक अतिरिक्त सुरक्षा परत के साथ है। हर दिन, ब्राउज़र, स्क्रिप्ट और कंप्यूटर प्रोग्राम अरबों HTTP बनाते हैं (एस)   **भुगतान** दूरस्थ स्रोतों से जानकारी प्राप्त करने का अनुरोध करता है। HTTP (एस) अन्य भी शामिल है [क्रिया](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods) विशेष रूप से पुट (सर्वर पर डेटा को धक्का देने के लिए) और DELETE (सर्वर से डेटा DELETE करने के लिए) । हाँ, PUT और DELETE HTTP के माध्यम से डेटासेट से डेटा को डालने और हटाने का उचित तरीका है। (एस) । GET सॉफ़्टवेयर के प्रत्येक टुकड़े द्वारा समर्थित है जो HTTP के साथ काम कर सकता है (एस) । वास्तव में काम करना आसान है। सभी पहले से ही जानते हैं कि कैसे काम करने के लिए? (जिसका उपयोग अनिवार्य रूप से उसी तरह किया जा सकता है जैसे GET) इसलिए हमने EDDTableFromHttpGet को GET और POST के साथ काम किया। बहुत कम लोग (कंप्यूटर प्रोग्रामर) कभी कभी PUT और DELETE के साथ काम किया है। PUT और DELETE आम तौर पर केवल कंप्यूटर भाषाओं द्वारा समर्थित होते हैं, इसलिए उनका उपयोग एक कुशल कार्यक्रम की आवश्यकता होती है। इसलिए PUT और DELETE आमतौर पर उपकरण विकसित करने के तरीके को देखते हुए एक बहुत अधिक बोझिल दृष्टिकोण होता है।
     
##### HttpGet Notes{#httpget-notes} 
*    [नोट्स](#httpget-notes) 
    * नहीं dataVariable डेटा टाइप = चार हो सकता है। इसके बजाय datatype=String का प्रयोग करें। यदि आपको वास्तव में डेटा टाइप = चार, ईमेल क्रिस की आवश्यकता है। जॉन at noaa.gov.
         
##### धन्यवाद{#thanks} 
*    [मूल विचार के लिए CHORDS को धन्यवाद।](#thanks)   
EDDTableFromHttpGet के लिए बुनियादी विचार (यानी, एक का उपयोग करना HTTP GET डेटासेट में डेटा जोड़ने का अनुरोध करें) यूसीएआर से है (NCAR?)   [क्लाउड-होस्टेड रियल टाइम डेटा सर्विसेज (मंडल) ](https://github.com/earthcubeprojects-chords) परियोजना अनुरोध में मापदंडों के लिए प्रारूप (बार-बार *नाम = मूल्य* , अलग करके और) एक ही मानक प्रारूप है कि वेब पृष्ठों पर HTML रूपों द्वारा प्रयोग किया जाता है। यह एक सरल और शानदार विचार है और इससे भी अधिक है क्योंकि यह पूरी तरह से साथ मेज़ करता है ERDDAP सारणीबद्ध डेटा से निपटने के लिए मौजूदा प्रणाली। विचार बाधा में स्पष्ट है, लेकिन मैं (बॉब) इसके बारे में नहीं सोचा था। EDDTableFromHttp उस बुनियादी विचार का उपयोग करें, इसे लागू करने के हमारे विचारों के साथ मिलकर, सिस्टम बनाने के लिए ERDDAP™ डेटा अपलोड करने के लिए। सिस्टम में डेटा को पुश करने के लिए GET का उपयोग करने के मूल विचार के अलावा, EDDTableFromHttpGet कार्यान्वयन पूरी तरह से अलग है और पूरी तरह से CHORDS से स्वतंत्र है और इसमें विभिन्न विशेषताएं हैं। (उदाहरण के लिए, लॉग फाइलें, डेटा का मिश्रण, विभिन्न सुरक्षा प्रणाली, CRUD समर्थन, पुन: प्रयोज्य डेटा) । CHORDS के लिए हमारा एक्सपोजर सिर्फ एक वेबिनार था। हमने अपने कोड को नहीं देखा या उनकी परियोजना के बारे में पढ़ा क्योंकि हम तुरंत जानते थे कि हम सिस्टम को एक अलग तरीके से लागू करना चाहते थे। लेकिन हम उन्हें बुनियादी विचार के लिए आभारी हैं। CHORDS का पूरा संदर्भ है
Daniels, M.D., Kerkez, B., चंद्रसेकर, V., Graves, S., Stamps, D.S., Martin, C., Dye, M., Gooch, R., Bartos, M., Jones, J., Keiser, K. (2014) । भूविज्ञान के लिए क्लाउड-होस्टेड रियल टाइम डेटा सर्विसेज (मंडल) सॉफ्टवेयर UCAR/NCAR - पृथ्वी अवलोकन प्रयोगशाला। [https://doi.org/10.5065/d6v1236q](https://doi.org/10.5065/d6v1236q)   
     
### EDDTableFrom Hyrax फ़ाइलें{#eddtablefromhyraxfiles} 
 [ **EDDTableFrom Hyrax फ़ाइलें** ](#eddtablefromhyraxfiles)   (विकृत) कई चर के साथ डेटा फ़ाइलों को एकत्रित करता है, प्रत्येक एक या अधिक साझा आयाम के साथ (उदाहरण के लिए, समय, ऊंचाई (या गहराई) अक्षांश) , और एक द्वारा सेवा की [ Hyrax   OPeNDAP सर्वर](https://www.opendap.org/software/hyrax-data-server) ।

* यह डेटासेट प्रकार है **डिप्रेषित** । नए और अधिक सामान्य समाधान का उपयोग करना है [कैश EDDTable विकल्प सेफिल](#cachefromurl)   (या एक संस्करण) , जो दूरस्थ फ़ाइलों की एक स्थानीय प्रतिलिपि बनाता है और स्थानीय फ़ाइलों से डेटा प्रदान करता है। The The most of the&lt;कैशFromUrl&gt; विकल्प किसी भी प्रकार के सारणीबद्ध डेटा फ़ाइल के साथ इस्तेमाल किया जा सकता है। **   
यदि आप कुछ कारणों से काम नहीं कर सकते हैं तो क्रिस को ईमेल करें। जॉन at noaa.gov.
यदि 2020 से पहले कोई शिकायत नहीं है, तो इस डेटासेट प्रकार को हटाया जा सकता है। ** 
* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं।
* अधिकांश मामलों में, प्रत्येक फ़ाइल में बाईं ओर एकाधिक मान होते हैं। (पहला) आयाम, उदाहरण के लिए, समय।
* अक्सर फ़ाइलें (लेकिन नहीं करना चाहिए) अन्य आयामों के लिए एक एकल मान है (उदाहरण के लिए, ऊंचाई (या गहराई) अक्षांश) ।
* फ़ाइलों में अतिरिक्त आयाम के साथ वर्ण चर हो सकता है (उदाहरण के लिए, nCharacter) ।
*    Hyrax सर्वर को यूआरएल में "/dods-bin/nph-dods/" या "/opendap/" द्वारा पहचाना जा सकता है।
* इस वर्ग स्क्रीन स्क्रैप Hyrax प्रत्येक निर्देशिका में फ़ाइलों की सूची के साथ वेब पेज। इसके कारण, यह वर्तमान प्रारूप के लिए बहुत विशिष्ट है Hyrax वेब पेज हम समायोजित करने की कोशिश करेंगे ERDDAP™ जल्दी अगर/जब भविष्य के संस्करण Hyrax फ़ाइलों को कैसे सूचीबद्ध किया जाता है।
* The The most of the&lt;फ़ाइलDir&gt; सेटिंग को नजरअंदाज कर दिया गया है। चूंकि यह वर्ग डाउनलोड करता है और प्रत्येक दूरस्थ डेटा फ़ाइल की स्थानीय प्रति बनाता है, ERDDAP™ फाइल को मजबूर करता है देना *बड़ाParentDirectory* साइटमैप * datasetID * /।
* के लिए&lt; sourceUrl &gt;, डेटासेट की आधार निर्देशिका के URL का उपयोग करें Hyrax सर्वर उदाहरण के लिए,
    &lt; sourceUrl &gt;http://edac-dap.northerngulfinstitute.org/dods-bin/nph-dods/WCOS/nmsp/wcos/&lt;/ sourceUrl &gt;
     (लेकिन इसे एक पंक्ति में डाल दिया)   (खेद है कि सर्वर अब उपलब्ध नहीं है) ।
The The most of the sourceUrl आमतौर पर वेब पेज में " होता है OPeNDAP सर्वर सूचकांक \\[ निर्देशिकानाम \\] "ऊपर"।
* चूंकि यह वर्ग हमेशा डाउनलोड करता है और प्रत्येक दूरस्थ डेटा फ़ाइल की स्थानीय प्रतिलिपि बनाता है, इसलिए आपको कभी भी इस डेटासेट को लपेटना नहीं चाहिए। [EDDTableCopy](#eddtablecopy) ।
* इस वर्ग के सुपरक्लास को देखें, [EDDTableFromFiles](#eddtablefromfiles) यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है, इस बारे में जानकारी के लिए।
* 1D, 2D, 3D और 4D उदाहरणों के लिए देखें [EDDTableFromNcFiles](#eddtablefromncfiles) ।
     
### EDDTableFromInvalidCRAFiles{#eddtablefrominvalidcrafiles} 
 [ **EDDTableFromInvalidCRAFiles** ](#eddtablefrominvalidcrafiles) से डेटा एकत्र करना NetCDF   (v3)   .nc फ़ाइलें जो CF DSG Contiguous Ragged Array का एक विशिष्ट, अवैध, संस्करण का उपयोग करती हैं (सीआरए) फ़ाइलें हालांकि ERDDAP™ इस फ़ाइल प्रकार का समर्थन करता है, यह एक अमान्य फ़ाइल प्रकार है जिसे कोई भी उपयोग करना शुरू नहीं करना चाहिए। वर्तमान में इस फ़ाइल प्रकार का उपयोग करने वाले समूह को दृढ़ता से उपयोग करने के लिए प्रोत्साहित किया जाता है ERDDAP™ मान्य CF DSG CRA फ़ाइलों को उत्पन्न करने और इन फ़ाइलों का उपयोग बंद करने के लिए।

विवरण: इन फ़ाइलों में एकाधिक पंक्ति \\_size चर होते हैं, प्रत्येक नमूना \\_dimension विशेषता के साथ। फाइलें गैर-सीएफ मानक फाइलें हैं क्योंकि एकाधिक नमूना (ओब) आयाम इस अतिरिक्त नियम और वादा के साथ एक दूसरे से संबंधित हैं जो CF DSG विनिर्देश का हिस्सा नहीं है: "आप दिए गए उदाहरण, तापमान मूल्य को जोड़ सकते हैं। (अस्थायी \\_obs आयाम) दी गई गहराई मान के साथ (z \\_obs आयाम, सबसे अधिक मूल्यों के साथ आयाम) , क्योंकि: तापमान पंक्ति \\_size (दिए गए कलाकारों के लिए) या तो 0 या इसी गहराई पंक्ति \\_size के बराबर होगा (उस कास्ट के लिए)   (यह नियम है) । इसलिए, यदि तापमान पंक्ति \\_size 0 नहीं है, तो उस कास्ट के लिए n तापमान मान उस कास्ट के लिए सीधे n गहराई मानों से संबंधित हैं (यह वादा है) "

इन फ़ाइलों के साथ एक और समस्या: प्रिंसिपल \\_Investigator पंक्ति \\_size चर में एक नमूना \\_dimension विशेषता नहीं है और उपरोक्त नियम का पालन नहीं करता है।

इस डेटासेट प्रकार के लिए नमूना फ़ाइलों को पाया जा सकता हैhttps://data.nodc.noaa.gov/thredds/catalog/ncei/wod/  \\[ 2020-10-21 यह सर्वर अब विश्वसनीय नहीं है \\] ।

इस वर्ग के सुपरक्लास को देखें, [EDDTableFromFiles](#eddtablefromfiles) यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है, इस बारे में जानकारी के लिए।

हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं।

पहली चीज GenDatasets Xml इस प्रकार के डेटासेट के लिए करता है जब आप सवालों का जवाब देते हैं, तो नमूना फ़ाइल की एनसीडंप जैसी संरचना को मुद्रित किया जाता है। तो अगर आप जनरेटडाटासेट के माध्यम से पहले पाश के लिए कुछ गौफी जवाब में प्रवेश करते हैं Xml, कम से कम आप देख सकते हैं कि क्या ERDDAP™ फ़ाइल को पढ़ सकते हैं और देख सकते हैं कि कौन से आयाम और चर फाइल में हैं। फिर आप जेनरेटडाटासेटएक्सएमएल के माध्यम से दूसरे लूप के लिए बेहतर जवाब दे सकते हैं।
 
### EDDTableFromJsonlCSVFiles{#eddtablefromjsonlcsvfiles} 
 [ **EDDTableFromJsonlCSVFiles** ](#eddtablefromjsonlcsvfiles) से डेटा एकत्र करना [JSON लाइन्स CSV फ़ाइलों](https://jsonlines.org/examples/) । इस वर्ग के सुपरक्लास को देखें, [EDDTableFromFiles](#eddtablefromfiles) यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है, इस बारे में जानकारी के लिए।

* जैसा कि jsonlines.org कहते हैं, यह प्रारूप "सीएसवी से बेहतर" है। (और कानूनी तौर पर, एक संघीय कर्मचारी के रूप में, मैं उनसे सहमत या असहमति नहीं कर सकता - कितना पागल है?) । CSV कभी औपचारिक रूप से परिभाषित नहीं किया गया है और मूल स्प्रेडशीट कार्यक्रमों के संबंध से संबंधित ऐतिहासिक बैगेज द्वारा बाधित है। JSON लाइन्स CSV, तुलना में, व्यापक रूप से उपयोग किए जाने वाले JSON मानक के कनेक्शन से पूरी तरह से परिभाषित और लाभ प्राप्त होता है, जो इसके कनेक्शन से उसके बदले लाभ में लाभ देता है। Java स्क्रिप्ट और स्क्रिप्ट Java । विशेष रूप से, लंबे पूर्णांकों और स्ट्रिंग्स में यूनिकोड वर्णों के लिए पूर्ण समर्थन है, और अन्य विशेष वर्णों को शामिल करने का एक स्पष्ट तरीका है। (विशेष रूप से टैब और न्यूलाइन) स्ट्रिंग के भीतर।
    
यह प्रारूप विशेष रूप से डेटासेट के लिए अच्छा है जहां आपको समय-समय पर किसी दिए गए डेटा फ़ाइल के अंत में अतिरिक्त पंक्तियों को जोड़ना होगा। उस कारण और दूसरों के लिए (ऊपर देखें) , [EDDTableFromHttpGet](#eddtablefromhttpget) डेटा भंडारण के लिए जेसन लाइन्स CSV फ़ाइलों का उपयोग करता है।
    
* इनपुट फ़ाइलों को UTF-8 कोडित माना जाता है। हालांकि, \\u दिया *हिन्दी* विशेष वर्णों को एन्कोड करने के लिए प्रारूप (उदाहरण के लिए, \\u20ac यूरो चरित्र के लिए एन्कोडिंग है) , आपके पास फ़ाइलों को लिखने का विकल्प है ताकि उनमें केवल 7-बिट ASCII वर्ण होते हैं, जिनका उपयोग \\u *हिन्दी* #127 से ऊपर सभी अक्षरों को एन्कोड करने के लिए।
     
* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं।
    
पहली चीज GenDatasetsXml इस प्रकार के डेटासेट के लिए करता है जब आप जवाब देते हैं तो सवाल नमूना फ़ाइल की एनसीडंप जैसी संरचना को प्रिंट करता है। तो अगर आप जनरेटडाटासेट के माध्यम से पहले पाश के लिए कुछ गौफी जवाब में प्रवेश करते हैं Xml, कम से कम आप देख सकते हैं कि क्या ERDDAP™ फ़ाइल को पढ़ सकते हैं और देख सकते हैं कि कौन से आयाम और चर फाइल में हैं। फिर आप जेनरेटडाटासेटएक्सएमएल के माध्यम से दूसरे लूप के लिए बेहतर जवाब दे सकते हैं।
    
* कब: कब ERDDAP™ JSON पढ़ा लाइन्स CSV डेटा फ़ाइलों, अगर यह किसी दिए गए लाइन पर एक त्रुटि मिलती है (उदाहरण के लिए, वस्तुओं की गलत संख्या) यह एक चेतावनी संदेश लॉग करता है ("WARNING: खराब रेखा (s) डेटा की एक सूची के साथ) to [log.txt फ़ाइल](/docs/server-admin/additional-information#log) और फिर बाकी डेटा फ़ाइल को पढ़ना जारी रखता है। इस प्रकार, समय-समय पर देखने की आपकी ज़िम्मेदारी है (या ऐसा करने के लिए एक स्क्रिप्ट लिखने) लॉग में उस संदेश के लिए। ताकि आप डेटा फ़ाइलों में समस्याओं को ठीक कर सकें। ERDDAP™ इस तरह से सेट किया गया है ताकि उपयोगकर्ता सभी उपलब्ध वैध डेटा को पढ़ना जारी रख सकें, भले ही फ़ाइल की कुछ पंक्तियां त्रुटियां हों।
     
### EDDTableFromMultidimNcFiles{#eddtablefrommultidimncfiles} 
 [ **EDDTableFromMultidimNcFiles** ](#eddtablefrommultidimncfiles) से डेटा एकत्र करना NetCDF   (v3)   .nc   (या [ .nc एमएल](#ncml-files) ) कई चर के साथ फ़ाइलों, प्रत्येक एक या अधिक साझा आयाम के साथ। फ़ाइलों के साथ या एक अतिरिक्त आयाम के बिना वर्ण चर हो सकता है (उदाहरण के लिए, STRING14) । इस वर्ग के सुपरक्लास को देखें, [EDDTableFromFiles](#eddtablefromfiles) यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है, इस बारे में जानकारी के लिए।

* यदि फ़ाइल बहुआयामी CF DSG संस्करण हैं, तो इस डेटासेट प्रकार का उपयोग इसके बजाय करें [EDDTableFromNcCFFiles](#eddtablefromncfiles) ।
     
* से नए सारणीबद्ध डेटासेट के लिए .nc पुरानी कोशिश करने से पहले इस विकल्प का उपयोग करें [EDDTableFromNcFiles](#eddtablefromncfiles) । इस वर्ग के कुछ फायदे हैं:
    * यह वर्ग विभिन्न प्रकार की फ़ाइल संरचनाओं से अधिक चर पढ़ सकता है। यदि आप निर्दिष्ट कर रहे हैं DimensionCSV (आयाम नामों की एक comma-separated सूची) में GenerateDatasets Xml (or)&lt;आयाम CSV&gt; datasets.xml इन डेटासेटों में से एक के लिए जानकारी, फिर ERDDAP™ केवल स्रोत फ़ाइलों में चर पढ़ेगा जो इन आयामों में से कुछ या सभी का उपयोग करते हैं, साथ ही सभी स्केलर वेरिएबल भी पढ़ सकते हैं। यदि कोई आयाम समूह में है, तो आपको अपना पूरा नाम निर्दिष्ट करना होगा, उदाहरण के लिए, " *समूहनाम/आयामनाम* "।
    * यह वर्ग अक्सर फ़ाइलों को बहुत जल्दी अस्वीकार कर सकता है यदि वे अनुरोध के बाधाओं से मेल नहीं खाते हैं। तो बड़े संग्रह से डेटा पढ़ने अक्सर बहुत तेजी से जाना होगा।
    * यह वर्ग वास्तविक चार चर संभालती है (गैर स्ट्रिंग चर) सही ढंग से।
    * यह वर्ग स्ट्रिंग चर को ट्रिम कर सकता है जब निर्माता ने Netcdf-java के लिखने वाले स्ट्रिंग्स का उपयोग नहीं किया था। (जो स्ट्रिंग के अंत को चिह्नित करने के लिए char #0 का पालन करता है) ।
    * यह वर्ग व्यक्तिगत फ़ाइलों से निपटने में बेहतर है, जिसमें कुछ चर या आयामों की कमी होती है।
    * यह वर्ग लापता मूल्यों के साथ पंक्तियों के ब्लॉकों को हटा सकता है जैसा कि निर्दिष्ट है [CF Discrete Sampling Geometries (DSG) पूर्ण बहुआयामी ऐरे फाइलें](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#_incomplete_multidimensional_array_representation)   
         
* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं।
    
पहली चीज GenDatasetsXml इस प्रकार के डेटासेट के लिए करता है जब आप जवाब देते हैं तो सवाल नमूना फ़ाइल की एनसीडंप जैसी संरचना को प्रिंट करता है। तो अगर आप जनरेटडाटासेट के माध्यम से पहले पाश के लिए कुछ गौफी जवाब में प्रवेश करते हैं Xml, कम से कम आप देख सकते हैं कि क्या ERDDAP™ फ़ाइल को पढ़ सकते हैं और देख सकते हैं कि कौन से आयाम और चर फाइल में हैं। फिर आप जेनरेटडाटासेटएक्सएमएल के माध्यम से दूसरे लूप के लिए बेहतर जवाब दे सकते हैं।
    
समूह जनगणना Xml एक "समूह" के लिए पूछेंगे। आप किसी भी समूह की खोज करने के लिए "" दर्ज कर सकते हैं, " *कुछ समूह* " *कुछसमूह/कुछ* "इसने एक विशिष्ट समूह की खोज की है, या " \\[ जड़ \\] "यह सिर्फ मूल समूह की खोज करने के लिए। "समूह" स्ट्रिंग बन जाती है&lt;समूह&gt; में datasets.xml डेटासेट के लिए जानकारी (हालांकि " \\[ जड़ \\] "") ।
    
आयाम CSV - जेनरेटडाटासेट Xml एक "DimensionCSV" स्ट्रिंग के लिए पूछेंगे। यह आयामों के एक सेट के स्रोत नामों की एक तुलनात्मक-मूल्य सूची है। जनगणना Xml केवल नमूना में डेटा चर पढ़ा होगा .nc जो कुछ या सभी आयामों का उपयोग करते हैं (कोई अन्य आयाम) इसके अलावा, फ़ाइल में सभी स्केलर वेरिएबल्स और उन डेटा वेरिएबल्स से डेटासेट बनाते हैं। यदि कोई आयाम समूह में है, तो आपको अपना पूरा नाम निर्दिष्ट करना होगा, उदाहरण के लिए, " *समूहनाम/आयामनाम* "।
यदि आप कुछ निर्दिष्ट नहीं करते हैं (एक खाली स्ट्रिंग) जेनरेट डाटासेट Xml अधिकांश आयामों के साथ चर की तलाश करेगा, इस सिद्धांत पर कि वे सबसे दिलचस्प होंगे, लेकिन ऐसा समय हो सकता है जब आप डेटा चर के कुछ अन्य समूह से डेटासेट बनाना चाहते हैं जो आयामों के कुछ अन्य समूह का उपयोग करते हैं।
यदि आप एक आयाम नाम निर्दिष्ट करते हैं जो मौजूद नहीं है (उदाहरण के लिए, NO \\_MATCH) , ERDDAP™ केवल सभी स्केलर चर पाएंगे।
"DimensionCSV" स्ट्रिंग हो जाता है&lt;आयाम CSV&gt; datasets.xml डेटासेट के लिए जानकारी।
    
#### इलाजDimensionA{#treatdimensionsas} 
अमान्य की एक श्रेणी है .nc फ़ाइलें (क्योंकि वे सीएफ नियमों का पालन नहीं करते हैं) इसमें कई आयाम हैं (उदाहरण के लिए, lat, lon, समय) जब वे सिर्फ एक आयाम का उपयोग करते हैं (उदाहरण के लिए, समय) उदाहरण के लिए:
```
    dimensions:
        time = UNLIMITED ; // (1437 currently)
        depth = 10;
        lat = 1437 ;
        lon = 1437 ;
    variables:
        double time(time) ;
        double lat(lat) ;
        double lon(lon) ;
        float temperature(time, depth) ;
```
EDDTableFromMultidimNcFiles में इन फ़ाइलों से निपटने के लिए एक विशेष विशेषता है: यदि आप वैश्विक विशेषता "treatDimensionAs" जोड़ते हैं तो डेटासेट वैश्विक addAttributes , आप कह सकते हैं ERDDAP™ कुछ आयामों का इलाज करने के लिए (उदाहरण के लिए, lat और lon) जैसा कि वे एक और आयाम थे (उदाहरण के लिए, समय) । विशेषता मान एक अल्पविराम अलग सूची होना चाहिए जो "से" आयाम निर्दिष्ट करती है और फिर "से" आयाम निर्दिष्ट करती है, उदाहरण के लिए,
 <att name="treatDimensionsAs"> lat, lon, समय </att>   
फिर ERDDAP™ अगर यह था तो फ़ाइल पढ़ेगा:
```
    dimensions:
        time = UNLIMITED ; // (1437 currently)
        depth = 10;
    variables:
        double time(time) ;
        double lat(time) ;
        double lon(time) ;
        float temperature(time, depth) ;
```
बेशक, सूची में प्रत्येक आयाम का वर्तमान आकार समान होना चाहिए; अन्यथा, ERDDAP™ फ़ाइल को "Bad फ़ाइल" के रूप में व्यवहार करेगा।

ध्यान दें कि ये फाइलें अमान्य हैं क्योंकि वे CF नियमों का पालन नहीं करते हैं। हालांकि ERDDAP™ उन्हें पढ़ सकते हैं, हम दृढ़ता से अनुशंसा करते हैं कि आप इस तरह की फ़ाइलों को नहीं बनाते क्योंकि अन्य CF आधारित सॉफ़्टवेयर टूल उन्हें सही ढंग से पढ़ने में सक्षम नहीं होंगे। यदि आपके पास पहले से ही ऐसी फाइलें हैं, तो हम जितनी जल्दी हो सके उन्हें वैध फ़ाइलों के साथ बदलने की सलाह देते हैं।
    
### EDDTableFromNcFiles{#eddtablefromncfiles} 
 [ **EDDTableFromNcFiles** ](#eddtablefromncfiles) से डेटा एकत्र करना NetCDF   (v3)   .nc   (या [ .nc एमएल](#ncml-files) ) फ़ाइलें [जैर](https://github.com/zarr-developers/zarr-python) फ़ाइलें (संस्करण 2.25) कई चर के साथ, प्रत्येक एक साझा आयाम के साथ (उदाहरण के लिए, समय) या एक से अधिक साझा आयाम (उदाहरण के लिए, समय, ऊंचाई (या गहराई) अक्षांश) । फाइलों में समान आयाम नाम होना चाहिए। किसी दिए गए फ़ाइल में प्रत्येक आयाम के लिए एकाधिक मान हो सकते हैं और मान विभिन्न स्रोत फ़ाइलों में भिन्न हो सकते हैं। फ़ाइलों में अतिरिक्त आयाम के साथ वर्ण चर हो सकता है (उदाहरण के लिए, STRING14) । इस वर्ग के सुपरक्लास को देखें, [EDDTableFromFiles](#eddtablefromfiles) यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है, इस बारे में जानकारी के लिए।

Zarr फ़ाइलों में थोड़ा अलग व्यवहार होता है और या तो फ़ाइलNameRegex या pathRegex को "zarr" शामिल करने की आवश्यकता होती है।

* यदि .nc फ़ाइलों में से एक का उपयोग करें [CF Discrete Sampling Geometries (DSG) ](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries) फ़ाइल प्रारूपों का उपयोग करने का प्रयास करें [EDDTableFromNcCFFiles](#eddtablefromncfiles) इससे पहले।
     
* से नए सारणीबद्ध डेटासेट के लिए .nc फ़ाइलें, नया प्रयास करें [EDDTableFromMultidimNcFiles](#eddtablefrommultidimncfiles) पहला।
     
* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं।
    
पहली चीज GenDatasetsXml इस प्रकार के डेटासेट के लिए करता है जब आप जवाब देते हैं तो सवाल नमूना फ़ाइल की एनसीडंप जैसी संरचना को प्रिंट करता है। तो अगर आप जनरेटडाटासेट के माध्यम से पहले पाश के लिए कुछ गौफी जवाब में प्रवेश करते हैं Xml, कम से कम आप देख सकते हैं कि क्या ERDDAP™ फ़ाइल को पढ़ सकते हैं और देख सकते हैं कि कौन से आयाम और चर फाइल में हैं। फिर आप जेनरेटडाटासेटएक्सएमएल के माध्यम से दूसरे लूप के लिए बेहतर जवाब दे सकते हैं।
    
आयाम CSV - जेनरेटडाटासेट Xml एक "DimensionCSV" स्ट्रिंग के लिए पूछेंगे। यह आयामों के एक सेट के स्रोत नामों की एक तुलनात्मक-मूल्य सूची है। जनगणना Xml में डेटा चर मिलेगा .nc जो कुछ या सभी आयामों का उपयोग करते हैं, साथ ही सभी स्केलर वेरिएबल्स, और उन डेटा चर से डेटासेट बनाते हैं। यदि आप कुछ निर्दिष्ट नहीं करते हैं (एक खाली स्ट्रिंग) जेनरेट डाटासेट Xml अधिकांश आयामों के साथ चर की तलाश करेगा, इस सिद्धांत पर कि वे सबसे दिलचस्प होंगे, लेकिन ऐसा समय हो सकता है जब आप डेटा चर के कुछ अन्य समूह से डेटासेट बनाना चाहते हैं जो आयामों के कुछ अन्य समूह का उपयोग करते हैं।
    
* 1 डी उदाहरण: 1 डी फाइलें 2 डी, 3 डी, 4 डी, ... फ़ाइलों से कुछ अलग हैं।
    * आप का एक सेट हो सकता है .nc डेटा फाइलें जहां प्रत्येक फ़ाइल में एक महीने का डेटा एक बहती हुई buoy से है।
    * प्रत्येक फ़ाइल में 1 आयाम होगा, उदाहरण के लिए, समय (आकार = \\[ कई \\] ) ।
    * प्रत्येक फ़ाइल में एक या अधिक 1D चर होंगे जो उस आयाम का उपयोग करते हैं, उदाहरण के लिए, समय, देशांतर, अक्षांश, हवा का तापमान, ....
    * प्रत्येक फ़ाइल में 2D वर्ण चर हो सकते हैं, उदाहरण के लिए, आयाम के साथ (समय, nCharacter) ।
         
* 2D उदाहरण:
    * आप का एक सेट हो सकता है .nc डेटा फाइलें जहां प्रत्येक फ़ाइल में एक महीने का डेटा एक बहती हुई buoy से है।
    * प्रत्येक फ़ाइल में 2 आयाम होंगे, उदाहरण के लिए, समय (आकार = \\[ कई \\] ) और आईडी (आकार = 1) ।
    * प्रत्येक फ़ाइल में आयाम के समान नामों के साथ 2 1D वेरिएबल होंगे और समान नाम आयाम का उपयोग करेंगे, उदाहरण के लिए, समय (समय) , आईडी (आईडी) । इन 1D चरों की सूची में शामिल किया जाना चाहिए&lt; dataVariable &gt; dataset XML में है।
    * प्रत्येक फ़ाइल में एक या अधिक 2D चर होंगे, उदाहरण के लिए, देशांतर, अक्षांश, हवा का तापमान, पानी का तापमान, ...
    * प्रत्येक फ़ाइल में 3 डी वर्ण चर हो सकते हैं, उदाहरण के लिए, आयाम के साथ (समय,id, nCharacter) ।
         
* 3D उदाहरण:
    * आप का एक सेट हो सकता है .nc प्रत्येक फ़ाइल में एक महीने का डेटा एक स्थिर buoy से है।
    * प्रत्येक फ़ाइल में 3 आयाम होंगे, उदाहरण के लिए, समय (आकार = \\[ कई \\] ) , लैट (आकार = 1) , और lon (आकार = 1) ।
    * प्रत्येक फ़ाइल में आयाम के समान नामों के साथ 3 1D वेरिएबल होंगे और समान नाम आयाम का उपयोग करेगा, उदाहरण के लिए, समय (समय) , लैट (लेट) , lon (lon) । इन 1D चरों की सूची में शामिल किया जाना चाहिए&lt; dataVariable &gt; dataset XML में है।
    * प्रत्येक फ़ाइल में एक या अधिक 3D चर होंगे, उदाहरण के लिए, हवा का तापमान, पानी का तापमान, ...
    * प्रत्येक फ़ाइल में 4D वर्ण चर हो सकते हैं, उदाहरण के लिए, आयाम के साथ (समय, लैटिना,lon,nCharacters) ।
    * फ़ाइल का नाम फ़ाइल के नाम के भीतर buoy का नाम हो सकता है।
         
* 4D उदाहरण:
    * आप का एक सेट हो सकता है .nc डेटा फाइलें जहां प्रत्येक फ़ाइल में एक महीने का डेटा एक स्टेशन से है। प्रत्येक समय, स्टेशन गहराई की एक श्रृंखला पर रीडिंग लेता है।
    * प्रत्येक फ़ाइल में 4 आयाम होंगे, उदाहरण के लिए, समय (आकार = \\[ कई \\] ) गहराई (आकार = \\[ कई \\] ) , लैट (आकार = 1) , और lon (आकार = 1) ।
    * प्रत्येक फ़ाइल में आयाम के समान नामों के साथ 4 1D वेरिएबल होंगे और समान नाम आयाम का उपयोग करेंगे, उदाहरण के लिए, समय (समय) गहराई (गहराई) , लैट (लेट) , lon (lon) । इन 1D चरों की सूची में शामिल किया जाना चाहिए&lt; dataVariable &gt; dataset XML में है।
    * प्रत्येक फ़ाइल में एक या अधिक 4D चर होंगे, उदाहरण के लिए, हवा का तापमान, पानी का तापमान, ...
    * प्रत्येक फ़ाइल में 5D वर्ण चर हो सकते हैं, उदाहरण के लिए, आयाम के साथ (समय, गहराई, अक्षांश,lon, nCharacter) ।
    * फ़ाइल का नाम फ़ाइल के नाम के भीतर buoy का नाम हो सकता है।
         
### EDDTableFromNcCFFiles{#eddtablefromnccffiles} 
 [ **EDDTableFromNcCFFiles** ](#eddtablefromnccffiles) से डेटा एकत्र करता है NetCDF   (v3)   .nc   (या [ .nc एमएल](#ncml-files) ) जो फ़ाइलों द्वारा निर्दिष्ट फ़ाइल प्रारूपों में से एक का उपयोग करते हैं [CF Discrete Sampling Geometries (DSG) ](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries) सम्मेलन। इस वर्ग के सुपरक्लास को देखें, [EDDTableFromFiles](#eddtablefromfiles) यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है, इस बारे में जानकारी के लिए।

बहुआयामी CF DSG वेरिएंट में से एक का उपयोग करके फ़ाइलों के लिए, उपयोग करें [EDDTableFromMultidimNcFiles](#eddtablefrommultidimncfiles) इसके बजाय।

CF DSG सम्मेलन दर्जनों फ़ाइल प्रारूपों को परिभाषित करता है और इसमें कई मामूली विविधताएं शामिल हैं। यह वर्ग उन सभी विविधताओं से संबंधित है जिन्हें हम जानते हैं, लेकिन हम एक याद रख सकते हैं (या अधिक) । इसलिए यदि यह वर्ग आपके CF DSG फ़ाइलों से डेटा नहीं पढ़ सकता है, तो कृपया कृपया ध्यान दें कि इस श्रेणी में आपके CF DSG फ़ाइलों से डेटा नहीं पढ़ा जा सकता है। [अतिरिक्त समर्थन के लिए पहुंचना](/docs/intro#support) ।

हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं।
 
### EDDTableFromNccsvFiles{#eddtablefromnccsvfiles} 
 [ **EDDTableFromNccsvFiles** ](#eddtablefromnccsvfiles) से डेटा एकत्र करना [एनसीसीएसवी](/docs/user/nccsv-1.00) ASCII फ़ाइलें. इस वर्ग के सुपरक्लास को देखें, [EDDTableFromFiles](#eddtablefromfiles) यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है, इस बारे में जानकारी के लिए।

* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं।
    
पहली चीज GenDatasetsXml इस प्रकार के डेटासेट के लिए करता है जब आप जवाब देते हैं तो सवाल नमूना फ़ाइल की एनसीडंप जैसी संरचना को प्रिंट करता है। तो अगर आप जनरेटडाटासेट के माध्यम से पहले पाश के लिए कुछ गौफी जवाब में प्रवेश करते हैं Xml, कम से कम आप देख सकते हैं कि क्या ERDDAP™ फ़ाइल को पढ़ सकते हैं और देख सकते हैं कि कौन से आयाम और चर फाइल में हैं। फिर आप जेनरेटडाटासेटएक्सएमएल के माध्यम से दूसरे लूप के लिए बेहतर जवाब दे सकते हैं।
    
* कब: कब ERDDAP™ एनसीसीएसवी डेटा फ़ाइलों को पढ़ता है, अगर यह किसी दिए गए लाइन पर त्रुटि पाता है (उदाहरण के लिए, वस्तुओं की गलत संख्या) यह एक चेतावनी संदेश लॉग करता है ("WARNING: खराब रेखा (s) डेटा की एक सूची के साथ) to [log.txt फ़ाइल](/docs/server-admin/additional-information#log) और फिर बाकी डेटा फ़ाइल को पढ़ना जारी रखता है। इस प्रकार, समय-समय पर देखने की आपकी ज़िम्मेदारी है (या ऐसा करने के लिए एक स्क्रिप्ट लिखने) लॉग में उस संदेश के लिए। ताकि आप डेटा फ़ाइलों में समस्याओं को ठीक कर सकें। ERDDAP™ इस तरह से सेट किया गया है ताकि उपयोगकर्ता सभी उपलब्ध वैध डेटा को पढ़ना जारी रख सकें, भले ही फ़ाइल की कुछ पंक्तियां त्रुटियां हों।
     
### EDDTableFromNOS{#eddtablefromnos} 
 [ **EDDTableFromNOS** ](#eddtablefromnos)   (डिप्रेषित) डेटा को एक से संभालता है NOAA   [NOS](https://opendap.co-ops.nos.noaa.gov/axis/) स्रोत, जो उपयोग करता है [ SOAP+XML ](https://www.w3schools.com/xml/xml_soap.asp) अनुरोधों और प्रतिक्रियाओं के लिए। यह बहुत विशिष्ट है NOAA NOS XML. Dataset2.xml में नमूना EDDTableFromNOS डेटासेट देखें।
 
### EDDTableFromOBIS{#eddtablefromobis} 
 [ **EDDTableFromOBIS** ](#eddtablefromobis) एक महासागर जीवविज्ञान सूचना प्रणाली से डेटा को संभालती है (ओबीआईएस) सर्वर (थाhttp://www.iobis.org ) । यह संभव है कि अधिक सक्रिय सर्वर नहीं हैं जो अब ओबीआईएस सर्वर सिस्टम के आउट-ऑफ-डेट प्रकार का उपयोग करते हैं।

* ओबीआईएस सर्वर एक XML अनुरोध की उम्मीद करते हैं और XML प्रतिक्रिया वापस करते हैं।
* चूंकि सभी ओबीआईएस सर्वर समान चरों की सेवा करते हैं (थाhttp://iobis.org/tech/provider/questions) , आपको एक ओबीआईएस डाटासेट स्थापित करने के लिए बहुत कुछ निर्दिष्ट नहीं करना है ERDDAP ।
* You MUST in a " creator\\_email "वैश्विक में विशेषता addAttributes चूंकि उस सूचना का उपयोग लाइसेंस के भीतर किया जाता है। SourceURL से XML प्रतिक्रिया पढ़ने के द्वारा उपयुक्त ईमेल पता पाया जा सकता है।
* आप वैश्विक विशेषता प्राप्त करने में सक्षम हो सकते हैं या नहीं&lt; subsetVariables &gt; (#subsetvariables) किसी दिए गए ओबीआईएस सर्वर के साथ काम करने के लिए। यदि आप कोशिश करते हैं, तो सिर्फ एक चर प्रयास करें (उदाहरण के लिए, वैज्ञानिकनाम या जेनस) ।
#### EDDTableFromOBIS कंकाल XML{#eddtablefromobis-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDTableFromOBIS" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceUrl>](#sourceurl)...&lt;/sourceUrl>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;sourceCode>...&lt;/sourceCode>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- If you read the XML response from the sourceUrl, the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source code (for example, GHMP) is the value from one of the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;resource>&lt;code> tags. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addVariablesWhere>](#addvariableswhere)...&lt;/addVariablesWhere> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-- All ...SourceMinimum and Maximum tags are OPTIONAL -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;longitudeSourceMinimum>...&lt;/longitudeSourceMinimum>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;longitudeSourceMaximum>...&lt;/longitudeSourceMaximum>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;latitudeSourceMinimum>...&lt;/latitudeSourceMinimum>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;latitudeSourceMaximum>...&lt;/latitudeSourceMaximum>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;altitudeSourceMinimum>...&lt;/altitudeSourceMinimum>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;altitudeSourceMaximum>...&lt;/altitudeSourceMaximum>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-- For timeSource... tags, use yyyy-MM-dd'T'HH:mm:ssZ format. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;timeSourceMinimum>...&lt;/timeSourceMinimum>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;timeSourceMaximum>...&lt;/timeSourceMaximum>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceNeedsExpandedFP\\_EQ>](#sourceneedsexpandedfp_eq)true(default)|false&lt;/sourceNeedsExpandedFP\\_EQ>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addAttributes>](#global-attributes)...&lt;/addAttributes> &lt;!-- 0 or 1.  This MUST include  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"creator\\_email" -->  
>&nbsp;&nbsp;&lt;/dataset>  

### EDDTableFromParquetFiles{#eddtablefromparquetfiles} 
 [ **EDDTableFromParquetFiles** ](#eddtablefromparquetfiles) डेटा को संभालना [लकड़ी](https://parquet.apache.org/) । इस वर्ग के सुपरक्लास को देखें, [EDDTableFromFiles](#eddtablefromfiles) यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है, इस बारे में जानकारी के लिए।

* लकड़ी की छत को बहुत कुशलता से संपीड़ित करने के लिए डिज़ाइन किया गया है, इसलिए यह आपको अन्य प्रारूपों की तुलना में छोटी फ़ाइल आकार दे सकता है।
* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं।
* कब: कब ERDDAP™ अगर यह किसी दिए गए लाइन पर एक त्रुटि पाता है तो Parquet डेटा फ़ाइलों को पढ़ता है (उदाहरण के लिए, वस्तुओं की गलत संख्या) यह एक चेतावनी संदेश लॉग करता है ("WARNING: खराब रेखा (s) डेटा की एक सूची के साथ) to [log.txt फ़ाइल](/docs/server-admin/additional-information#log) और फिर बाकी डेटा फ़ाइल को पढ़ना जारी रखता है। इस प्रकार, समय-समय पर देखने की आपकी ज़िम्मेदारी है (या ऐसा करने के लिए एक स्क्रिप्ट लिखने) लॉग में उस संदेश के लिए। ताकि आप डेटा फ़ाइलों में समस्याओं को ठीक कर सकें। ERDDAP™ इस तरह से सेट किया गया है ताकि उपयोगकर्ता सभी उपलब्ध वैध डेटा को पढ़ना जारी रख सकें, भले ही फ़ाइल की कुछ पंक्तियां त्रुटियां हों।
     
### EDDTableFrom SOS  {#eddtablefromsos} 
 [ **EDDTableFrom SOS ** ](#eddtablefromsos) एक सेंसर अवलोकन सेवा से डेटा संभालती है (SWE/ [ SOS ](https://www.ogc.org/standards/sos) ) सर्वर

* यह डेटासेट प्रकार स्टेशनों के एक समूह से डेटा एकत्र करता है जो सभी एक द्वारा सेवा प्रदान किए जाते हैं SOS सर्वर
* स्टेशन सभी चर के समान सेट की सेवा करते हैं (हालांकि प्रत्येक स्टेशन के लिए स्रोत को सभी चरों की सेवा नहीं करनी चाहिए) ।
*    SOS सर्वर XML अनुरोध की उम्मीद करते हैं और XML प्रतिक्रिया वापस करते हैं।
* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं। इसके लिए डेटासेट XML उत्पन्न करना आसान नहीं है SOS हाथ से डेटासेट। आवश्यक जानकारी प्राप्त करने के लिए, आपको जाना चाहिए sourceUrl + सेवा SOS &request GetCapabilities "एक ब्राउज़र में; XML को देखें; हाथ से एक GetObservation अनुरोध करें; और अनुरोध के लिए XML प्रतिक्रिया को देखें।
* नए प्रकार के अतिरिक्त SOS सर्वर और पुराने सर्वर में बदलाव, यह कठिन हो रहा है ERDDAP™ सर्वर की प्रतिक्रियाओं से सर्वर प्रकार का स्वचालित रूप से पता लगाने के लिए। उपयोग&lt;sosServertype&gt; (IOOS \\_NDBC, IOOS \\_NOS के मूल्य के साथ, OOSTethys डब्ल्यूएचओआई) अब STRONGLY RECOMMENDED है। यदि आपके पास इस प्रकार के किसी भी डेटासेट के साथ कोई समस्या है, तो फिर से जारी करने की कोशिश करें GenerateDatasets XML के लिए SOS सर्वर उत्पन्न करना डेटासेट एक्सएमएल आपको अलग-अलग कोशिश करने देगा&lt;जब तक आप किसी दिए गए सर्वर के लिए सही खोजने के लिए sosServertype&gt; विकल्प।
*    SOS अवलोकन:
    * SWE (सेंसर वेब सक्षमता) और SOS   (सेंसर अवलोकन सेवा) हैं [OpenGIS® मानकों](https://www.ogc.org/standards) । इस वेबसाइट के मानक दस्तावेज हैं।
    * The The most of the OGC वेब सर्विसेज कॉमन विशिष्टता ver 1.1.0 ( OGC 06-121r3) GET और POST प्रश्नों के निर्माण को कवर करता है (अनुभाग 7.2.3 और अनुभाग 9 देखें) ।
    * यदि आप एक प्राप्त करने की क्षमता xml अनुरोध भेजते हैं तो SOS सर्वर ( sourceUrl "?service= SOS &request GetCapabilities ") , आपको स्टेशनों की सूची और मनाया जाने वाला एक xml परिणाम मिलता है गुण जो उनके पास डेटा है।
    * एक मनायाProperty एक संपत्ति के लिए एक औपचारिक URI संदर्भ है। उदाहरण के लिए, urn:ogc:phenomenon: देशांतर: wgs84 याhttps://mmisw.org/ont/cf/parameter/sea\\_water\\_temperature
    * एक मनायाProperty एक चर नहीं है।
    * एक से अधिक चर में वही देखा जा सकता है संपत्ति (उदाहरण के लिए, अंदर टेम्प और बाहर दोनों को देखा जा सकता है संपत्तिhttps://mmisw.org/ont/cf/parameter/air\\_temperature) ।
    * यदि आप एक जांच xml अनुरोध भेजने के लिए एक SOS सर्वर, आपको प्रतिक्रिया, फील्ड इकाइयों और डेटा में फ़ील्ड नामों के विवरण के साथ xml परिणाम मिलता है। क्षेत्र के नामों में लम्बाई, अक्षांश, गहराई शामिल होगी (शायद) समय
    * प्रत्येक dataVariable EDDTableFrom SOS एक "observedProperty" विशेषता शामिल होना चाहिए, जो उस परिवर्तनीय को प्राप्त करने के लिए सर्वर से अनुरोध किया जाना चाहिए कि मनायाProperty की पहचान करता है। अक्सर, कई dataVariable s एक ही समग्र मनायाProperty सूची होगा।
    * प्रत्येक के लिए डेटाटाइप dataVariable सर्वर द्वारा निर्दिष्ट नहीं किया जा सकता है। यदि हां, तो आपको सर्वर से XML डेटा प्रतिक्रियाओं को देखना होगा और उचित निर्दिष्ट करना होगा [&lt;Datatype&gt;s (#datatype) में ERDDAP™ डेटासेट dataVariable परिभाषाएं।
    *    (इसे लिखने के समय) कुछ SOS सर्वर एक से अधिक अवलोकन अनुरोधों का जवाब देते हैं संपत्ति केवल देखी गई संपत्ति के पहले के लिए परिणाम वापस कर रही है। (कोई त्रुटि संदेश&#33;) निर्माता पैरामीटर अनुरोध देखें अक्सर पूछे जाने वाले प्रश्न
* EDDTableFrom SOS स्वचालित रूप से जोड़ता है
  >  <att name="[subsetVariables](#subsetvariables)">station\\_id, longitude, latitude</att>  
डेटासेट के वैश्विक गुणों के लिए जब डेटासेट बनाया जाता है।
*    SOS सर्वर आम तौर पर एक्सप्रेस [यूनिट](#units) साथ [UCUM](https://unitsofmeasure.org/ucum.html) प्रणाली। सबसे ज्यादा ERDDAP™ सर्वर एक्सप्रेस इकाइयों के साथ [ UDUNITS ](https://www.unidata.ucar.edu/software/udunits/) प्रणाली। यदि आपको दो प्रणालियों के बीच कन्वर्ट करने की आवश्यकता है, तो आप उपयोग कर सकते हैं [ ERDDAP UCUM इकाइयों को / से परिवर्तित करने के लिए वेब सेवा UDUNITS ](https://coastwatch.pfeg.noaa.gov/erddap/convert/units.html) ।
#### EDDTableFrom SOS कंकाल XML{#eddtablefromsos-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDTableFromSOS" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceUrl>](#sourceurl)...&lt;/sourceUrl>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addVariablesWhere>](#addvariableswhere)...&lt;/addVariablesWhere> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;sosServerType>...&lt;/sosServerType> &lt;!-- 0 or 1, but STRONGLY  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RECOMMENDED. This lets you specify the type of SOS server  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(so ERDDAP™ doesn't have to figure it out).  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Valid values are: IOOS\\_NDBC, IOOS\\_NOS, OOSTethys, and WHOI. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;responseFormat>...&lt;/responseFormat> &lt;!-- 0 or 1. Use this only if  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;you need to override the default responseFormat for the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specified sosServerType.  -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;stationIdSourceName>...&lt;/stationIdSourceName> &lt;!-- 0 or 1.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default="station\\_id". -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;longitudeSourceName>...&lt;/longitudeSourceName>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;latitudeSourceName>...&lt;/latitudeSourceName>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;altitudeSourceName>...&lt;/altitudeSourceName>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;altitudeSourceMinimum>...&lt;/altitudeSourceMinimum> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;altitudeSourceMaximum>...&lt;/altitudeSourceMaximum> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;altitudeMetersPerSourceUnit>](#altitudemeterspersourceunit)...&lt;/altitudeMetersPerSourceUnit>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;timeSourceName>...&lt;/timeSourceName>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;timeSourceFormat>...&lt;/timeSourceFormat>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- timeSourceFormat MUST be either  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\* For numeric data: a [UDUnits](https://www.unidata.ucar.edu/software/udunits/)\\-compatible string (with the format  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"*units* since *baseTime*") describing how to interpret  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source time values (for example,  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"seconds since 1970-01-01T00:00:00Z"), where the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base time is an ISO 8601:2004(E) formatted date time  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string (yyyy-MM-dd'T'HH:mm:ssZ).  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\* For String date time data: specify  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[units suitable for string times](#string-time-units)  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;describing how to interpret string times  (for example, the  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ISO8601TZ\\_FORMAT "yyyy-MM-dd'T'HH:mm:ssZ"). -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;observationOfferingIdRegex>...&lt;/observationOfferingIdRegex>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- Only observationOfferings with IDs (usually the station names)  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which match this [regular expression](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html) ([tutorial](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html)) will be included  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in the dataset (".+" will catch all station names). -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;requestObservedPropertiesSeparately>true|false(default)  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/requestObservedPropertiesSeparately>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;sourceNeedsExpandedFP\\_EQ>](#sourceneedsexpandedfp_eq)true(default)|false&lt;/sourceNeedsExpandedFP\\_EQ>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addAttributes>](#global-attributes)...&lt;/addAttributes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dataVariable>](#datavariable)...&lt;/dataVariable> &lt;!-- 1 or more.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\* Each dataVariable MUST include the [dataType](#datatype) tag.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\* Each dataVariable MUST include the observedProperty attribute.  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\* For IOOS SOS servers, \\*every\\* variable returned in the text/csv  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response MUST be included in this ERDDAP™ dataset definition. -->  
>&nbsp;&nbsp;&lt;/dataset>  

### EDDTableFromThreddsFiles{#eddtablefromthreddsfiles} 
 [ **EDDTableFromThreddsFiles** ](#eddtablefromthreddsfiles)   (विकृत) कई चर के साथ डेटा फ़ाइलों को एकत्रित करता है, प्रत्येक एक या अधिक साझा आयाम के साथ (उदाहरण के लिए, समय, ऊंचाई (या गहराई) अक्षांश) , और एक द्वारा सेवा की [थर्ड OPeNDAP सर्वर](https://www.unidata.ucar.edu/software/tds/) ।

* यह डेटासेट प्रकार है **डिप्रेषित** । नए और अधिक सामान्य समाधान का उपयोग करना है [कैश EDDTable विकल्प सेफिल](#cachefromurl)   (या एक संस्करण) , जो दूरस्थ फ़ाइलों की एक स्थानीय प्रतिलिपि बनाता है और स्थानीय फ़ाइलों से डेटा प्रदान करता है। The The most of the&lt;कैशFromUrl&gt; विकल्प किसी भी वेब आधारित स्रोत से किसी भी प्रकार के सारणीबद्ध डेटा फ़ाइल के साथ इस्तेमाल किया जा सकता है जो फ़ाइलों की निर्देशिका जैसी सूची प्रकाशित करता है। **   
यदि आप कुछ कारणों से काम नहीं कर सकते हैं तो क्रिस को ईमेल करें। जॉन at noaa.gov.
यदि 2020 से पहले कोई शिकायत नहीं है, तो इस डेटासेट प्रकार को हटाया जा सकता है। ** 
* हम दृढ़ता से उपयोग करने की सलाह देते हैं [जनगणना Xml कार्यक्रम](#generatedatasetsxml) का एक मोटे ड्राफ्ट बनाने के लिए datasets.xml इस डेटासेट के लिए भाग लें। तब आप इसे ठीक करने के लिए संपादित कर सकते हैं।
* अधिकांश मामलों में, प्रत्येक फ़ाइल में बाईं ओर एकाधिक मान होते हैं। (पहला) आयाम, उदाहरण के लिए, समय।
* अक्सर फ़ाइलें (लेकिन नहीं करना चाहिए) अन्य आयामों के लिए एक एकल मान है (उदाहरण के लिए, ऊंचाई (या गहराई) अक्षांश) ।
* फ़ाइलों में अतिरिक्त आयाम के साथ वर्ण चर हो सकता है (उदाहरण के लिए, nCharacter) ।
* THREDDS सर्वर को URL में "/thredds/" द्वारा पहचाना जा सकता है। उदाहरण के लिए,
```
    https://www.ncei.noaa.gov/thredds/catalog/uv/6h\\_strs\\_agg/catalog.html
```
* THREDDS सर्वर विभिन्न स्थानों में सूची है। इस वर्ग की आवश्यकता है कि यूआरएल में "/thredds/catalog/" शामिल हैं। आप आमतौर पर रूट कैटलॉग में एक ब्राउज़र में शुरू करके इस परिवर्तनीय को पा सकते हैं, और फिर वांछित subcatalog पर क्लिक कर सकते हैं।
* इस वर्ग ने THREDDS द्वारा सेवा की गई catalog.xml फ़ाइलों को पढ़ा है, जिसमें सूची की गई है।&lt;कैटलॉग (अतिरिक्त catalog.xml उप फ़ाइल के संदर्भ) और&lt;डेटासेट&gt; (डेटा फाइलें) ।
* The The most of the&lt;फ़ाइलDir&gt; सेटिंग को नजरअंदाज कर दिया गया है। चूंकि यह वर्ग डाउनलोड करता है और प्रत्येक दूरस्थ डेटा फ़ाइल की स्थानीय प्रति बनाता है, ERDDAP™ फाइल को मजबूर करता है देना *बड़ाParentDirectory* साइटमैप * datasetID * /।
* के लिए&lt; sourceUrl &gt;, THREDDS सर्वर में डेटासेट के लिए catalog.xml फ़ाइल के URL का उपयोग करें, उदाहरण के लिए: इस URL के लिए जिसका उपयोग वेब ब्राउज़र में किया जा सकता है।
    https://data.nodc.noaa.gov/thredds/catalog/nmsp/wcos/catalog.html  \\[ 2020-10-21 यह सर्वर अब विश्वसनीय नहीं है। \\] ,
उपयोग&lt; sourceUrl &gt;https://data.nodc.noaa.gov/thredds/catalog/nmsp/wcos/catalog.xml&lt;/ sourceUrl &gt;
     (लेकिन इसे एक पंक्ति में डाल दिया) ।
* चूंकि यह वर्ग हमेशा डाउनलोड करता है और प्रत्येक दूरस्थ डेटा फ़ाइल की स्थानीय प्रतिलिपि बनाता है, इसलिए आपको कभी भी इस डेटासेट को लपेटना नहीं चाहिए। [EDDTableCopy](#eddtablecopy) ।
* यह डेटासेट प्रकार एक वैकल्पिक, शायद ही कभी इस्तेमाल किया, विशेष टैग का समर्थन करता है,&lt;विशेष मोड&gt; *मोड* &lt;/specialMode&gt; जिसका उपयोग यह निर्दिष्ट करने के लिए किया जा सकता है कि विशेष, हार्ड-कोडित नियमों का उपयोग यह निर्धारित करने के लिए किया जाना चाहिए कि कौन से फ़ाइलों को सर्वर से डाउनलोड किया जाना चाहिए। वर्तमान में, एकमात्र मान्य *मोड* SAMOS है जो डेटासेट के साथ प्रयोग किया जाता हैhttps://tds.coaps.fsu.edu/thredds/catalog/samosकेवल अंतिम संस्करण संख्या के साथ फ़ाइलों को डाउनलोड करने के लिए।
* इस वर्ग के सुपरक्लास को देखें, [EDDTableFromFiles](#eddtablefromfiles) यह कैसे काम करता है और इसका उपयोग कैसे किया जाता है, इस बारे में जानकारी के लिए।
* 1D, 2D, 3D और 4D उदाहरणों के लिए देखें [EDDTableFromNcFiles](#eddtablefromncfiles) ।
     
### EDDTableFrom WFS फ़ाइलें{#eddtablefromwfsfiles} 
 [ **EDDTableFrom WFS फ़ाइलें** ](#eddtablefromwfsfiles)   (डिप्रेषित) सभी डेटा की एक स्थानीय प्रति बनाता है ArcGIS MapServer WFS इसलिए डेटा को फिर से संरक्षित किया जा सकता है ERDDAP™ उपयोगकर्ता

* आपको एक विशेष स्वरूपित निर्दिष्ट करने की आवश्यकता है sourceUrl वैश्विक विशेषता बताने के लिए ERDDAP™ सर्वर से सुविधा जानकारी का अनुरोध कैसे करें। कृपया इस उदाहरण का उपयोग टेम्पलेट के रूप में करें:
```
    <att name="sourceUrl">http://*someUrl/dir1/dir2*/MapServer/WFSServer?request=GetFeature&amp;service=WFS&amp;typename=aasg:BoreholeTemperature&amp;format=&quot;text/xml;%20subType=gml/3.1.1/profiles/gmlsf/1.0.0/0"</att>  
```
     (लेकिन यह सब एक पंक्ति में डाल दिया) 
* आपको बताने के लिए एक विशेष वैश्विक विशेषता जोड़ने की आवश्यकता है ERDDAP™ डेटा के टुकड़ों के नाम की पहचान कैसे करें जिसे डाउनलोड किया जाना चाहिए। यह संभवतः सभी EDDTableFrom के लिए काम करेगा WFS फ़ाइल डेटासेट:
```
    <att name="rowElementXPath">/wfs:FeatureCollection/gml:featureMember</att>
```
* चूंकि यह वर्ग हमेशा डाउनलोड करता है और प्रत्येक दूरस्थ डेटा फ़ाइल की स्थानीय प्रतिलिपि बनाता है, इसलिए आपको कभी भी इस डेटासेट को लपेटना नहीं चाहिए। [EDDTableCopy](#eddtablecopy) ।
* इस वर्ग के सुपरक्लास को देखें, [EDDTableFromFiles](#eddtablefromfiles) कैसे इस वर्ग के काम करता है और इसका उपयोग करने के बारे में अतिरिक्त जानकारी के लिए।
     
### EDDTableAggregateRows{#eddtableaggregaterows} 
 [ **EDDTableAggregateRows** ](#eddtableaggregaterows) "child" EDDTable डेटासेट के एक समूह से EDDTable डेटासेट बना सकते हैं।

* यहां EDDTableAggregateRows के लिए कुछ उपयोग दिए गए हैं:
    * आप EDDTableAggregateRows Dataset को दो अलग-अलग प्रकार की फाइलों या डेटा स्रोतों से बना सकते हैं, उदाहरण के लिए, पिछले महीने के अंत तक डेटासेट के साथ डेटासेट में संग्रहीत किया गया। .nc CF फ़ाइलों और वर्तमान महीने के लिए डेटा के साथ एक डेटासेट एक संबंधिक डेटाबेस में संग्रहीत।
    * आप स्रोत फ़ाइलों में बदलाव के साथ निपटने के लिए EDDTableAggregateRows Dataset बना सकते हैं (उदाहरण के लिए, टाइम प्रारूप बदल गया, या एक परिवर्तनीय नाम बदल गया, या डेटा प्रकार scale\\_factor / add\\_offset बदलना) । इस मामले में, एक बच्चा परिवर्तन से पहले की गई फ़ाइलों से डेटा प्राप्त करेगा और दूसरा बच्चा परिवर्तन के बाद की गई फ़ाइलों से डेटा प्राप्त करेगा। EDDTableAggregateRows का यह उपयोग करने का विकल्प है [एनसीएमएल](#ncml-files) या [ NCO ](#netcdf-operators-nco) । जब तक फ़ाइल नाम में कोई विशिष्ट विशेषता नहीं है ( इसलिए आप उपयोग कर सकते हैं)&lt;फ़ाइलNameRegex&gt; यह निर्धारित करने के लिए कि कौन सी फ़ाइल किस बच्चे के डेटासेट से संबंधित है, आपको शायद विभिन्न निर्देशिकाओं में दो बच्चे डेटासेट के लिए फ़ाइलों को स्टोर करने की आवश्यकता है।
    * आप एक EDDTableAggregateRows Dataset बना सकते हैं जिसमें एक या अधिक समान लेकिन अलग-अलग डेटासेट के चर का एक साझा सबसेट होता है, उदाहरण के लिए, एक डेटासेट जो प्रोफ़ाइल डेटासेट के संयोजन से एक प्रोफाइल डेटासेट बनाता है, एक टाइमसेरीप्रोफ़ाइल डेटासेट और एक ट्रेजेक्टरीप्रोफाइल डेटासेट (जिसमें कुछ अलग वैरिएबल और कुछ वैरिएबल्स आम तौर पर होते हैं - जिस मामले में आपको बच्चे के डेटासेट के लिए विशेष वेरिएंट बनाना होगा, सिर्फ इन-आम वेरिएबल के साथ) ।
    * आपके पास कई स्टैंडअलोन डेटासेट हो सकते हैं, प्रत्येक में एक ही प्रकार के डेटा के साथ लेकिन एक अलग स्टेशन से। आप उन डेटासेट को बरकरार रख सकते हैं, लेकिन एक EDDTableAggregateRows डेटासेट भी बना सकते हैं, जिसमें सभी स्टेशनों से डेटा है - प्रत्येक बच्चे डेटासेट एक सरल हो सकता है। [EDDTableFromErddap](#eddfromerddap) , जो मौजूदा स्टेशन डेटासेट में से एक को इंगित करता है। यदि आप ऐसा करते हैं, तो प्रत्येक EDDTableFromErddap डेटासेट को अलग-अलग करें datasetID मूल स्टैंडअलोन डेटासेट की तुलना में, उदाहरण के लिए, मूल में "बाल" को गिरफ्तार करके datasetID ।
* प्रत्येक बच्चे&lt;डेटासेट&gt; का निर्दिष्ट एक पूर्ण डेटासेट होना चाहिए, जैसे कि यह एक स्टैंड-अलोन डेटासेट था। प्रत्येक होना चाहिए [ dataVariable s](#datavariable) उसी क्रम में, उसी क्रम में, उसी के साथ [ destinationName s](#destinationname) , [डेटा प्रकार](#datatype) , [ missing\\_value s](#missing_value) , [\\_FillValues](#missing_value) , और [यूनिट](#units) । EDDTableAggregateRows Dataset के लिए प्रत्येक चर के लिए मेटाडाटा पहले बच्चे डेटासेट में चर से आता है, लेकिन EDDTableAggregateRows अद्यतन करेगा। [ actual\\_range ](#actual_range) मेटाडाटा सभी बच्चों के लिए वास्तविक रेंज होना चाहिए।
* सिफारिश: प्रत्येक बच्चे के डेटासेट स्टैंड-अलोन डेटासेट के रूप में काम करते हैं। फिर EDDTableAggregateRows Dataset को काटने और चिपकाने की कोशिश करें datasets.xml प्रत्येक के लिए नए EDDTableAggregate में भाग लें पंक्तियां डेटासेट।
* डेटासेट डिफ़ॉल्ट क्रम -- चाइल्ड डेटासेट का आदेश परिणामों के समग्र डिफ़ॉल्ट प्रकार के आदेश को निर्धारित करता है। बेशक, उपयोगकर्ता अपील करके परिणामों के दिए गए सेट के लिए अलग-अलग ऑर्डर का अनुरोध कर सकते हैं और orderBy  (" *चरों की अल्पसंख्यक सूची* ") उनके प्रश्नों के अंत तक।
* "source" [वैश्विक गुण](#global-attributes) EDDTableAggregateRows के लिए संयुक्त वैश्विक हैप्रथम बच्चे डेटासेट से योगदान करता है। EDDTableAggregate पंक्तियाँ वैश्विक हो सकती हैं&lt; addAttributes &gt; अतिरिक्त वैश्विक विशेषताओं को प्रदान करने या स्रोत वैश्विक विशेषताओं को ओवरराइड करने के लिए।
#### EDDTableAggregate पंक्तियों कंकाल XML{#eddtableaggregaterows-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDTableAggregateRows" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaFiles>](#accessibleviafiles)true|false(default)&lt;/accessibleViaFiles>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;updateEveryNMillis>](#updateeverynmillis)...&lt;/updateEveryNMillis> &lt;!-- 0 or 1. -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addVariablesWhere>](#addvariableswhere)...&lt;/addVariablesWhere> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dataset>...&lt;/dataset> &lt;!-- 1 or more -->  
>&nbsp;&nbsp;&lt;/dataset>  

### EDDTableCopy{#eddtablecopy} 
 [ **EDDTableCopy** ](#eddtablecopy) कई प्रकार के EDDTable डेटासेट की स्थानीय प्रतिलिपि बना सकते हैं और फिर स्थानीय प्रतिलिपि से डेटा को जल्दी से संरक्षित कर सकते हैं।

* EDDTableCopy (और ग्रिड डेटा के लिए, [ EDDGrid कॉपी](#eddgridcopy) ) उपयोग करना बहुत आसान है और एक बहुत प्रभावी है **दूरस्थ डेटा स्रोतों से डेटा की सेवा के साथ कुछ सबसे बड़ी समस्याओं का समाधान:** 
    * दूरस्थ डेटा स्रोत से डेटा तक पहुंच धीमी हो सकती है।
        * क्योंकि वे स्वाभाविक रूप से धीमा हो सकते हैं (उदाहरण के लिए, सर्वर का एक अक्षम प्रकार) ,
        * क्योंकि वे बहुत सारे अनुरोधों से अभिभूत हैं,
        * या क्योंकि आपका सर्वर या रिमोट सर्वर बैंडविड्थ सीमित है।
    * दूरस्थ डेटासेट कभी-कभी अनुपलब्ध है (फिर, विभिन्न कारणों के लिए) ।
    * डेटा के लिए एक स्रोत पर निर्भर करना अच्छी तरह से स्केल नहीं करता है (उदाहरण के लिए, जब कई उपयोगकर्ता और कई ERDDAP इसका उपयोग) ।
         
* यह कैसे काम करता है - EDDTableCopy स्वचालित रूप से डेटा की एक स्थानीय प्रतिलिपि बनाने और स्थानीय प्रतिलिपि से डेटा की सेवा करके इन समस्याओं को हल करता है। ERDDAP™ बहुत जल्दी स्थानीय प्रतिलिपि से डेटा की सेवा कर सकते हैं। और स्थानीय प्रतिलिपि का उपयोग करके दूरस्थ सर्वर पर बोझ को राहत देता है। और स्थानीय प्रतिलिपि मूल का बैकअप है, जो स्थिति में कुछ मूल होता है।
    
डेटासेट की स्थानीय प्रतिलिपि बनाने के बारे में कुछ नया नहीं है। यहाँ नया क्या है कि यह वर्ग इसे बनाता है\\*आसान\\*बनाना और बनाना\\*रखरखाव\\*डेटा की एक स्थानीय प्रतिलिपि\\*विविधता\\*दूरस्थ डेटा स्रोतों के प्रकार और\\*मेटाडाटा\\*डेटा की प्रतिलिपि बनाते समय।
    
#### EDDTableCopy बनाम&lt;कैशFromUrl&gt;{#eddtablecopy-vs-cachefromurl} 
&lt;CashFromUrl&gt; EDDTableCopy का विकल्प है। वे अलग-अलग काम करते हैं।

* EDDTable एक दूरस्थ सेवा से डेटा के टुकड़ों का अनुरोध करके और स्थानीय फ़ाइलों में उन टुकड़ों को संग्रहीत करके काम करता है। इस प्रकार, EDDTableCopy कुछ मामलों में उपयोगी है जहां डेटा दूरस्थ सेवा के माध्यम से सुलभ है।
* [&lt;CashFromUrl&gt; (#cachefromurl) दूरस्थ वेबसाइट पर सूचीबद्ध मौजूदा फ़ाइलों को डाउनलोड करें।&lt;कैशFromUrl&gt; का उपयोग करना आसान है और अधिक विश्वसनीय है क्योंकि यह आसानी से बता सकता है कि एक नई दूरस्थ डेटा फ़ाइल कब है या जब एक दूरस्थ डेटा फ़ाइल बदल गई है और इस प्रकार इसे डाउनलोड करने की आवश्यकता है।

यदि ऐसी स्थितियां हैं जहां EDDTableCopy या EDDTableCopy&lt;CashFromUrl&gt; का उपयोग किया जा सकता है, उपयोग किया जा सकता है&lt;CashFromUrl&gt; क्योंकि यह आसान और विश्वसनीय है।
     
#### &lt;निकासी नाम और gt;{#extractdestinationnames} 
EDDTable प्रतिलिपि दूरस्थ डेटासेट से डेटा के टुकड़ों का अनुरोध करके डेटा की स्थानीय प्रतिलिपि बनाती है। EDDTable प्रतिलिपि यह निर्धारित करती है कि कौन-कौन से हिस्से को अनुरोध करके अनुरोध करने के लिए अनुरोध किया जाता है () मूल्य&lt;निष्कर्षण गंतव्यनाम (में निर्दिष्ट datasets.xml नीचे देखें) , जो दूरस्थ डेटासेट में चर के स्थानबद्ध गंतव्य नाम हैं। उदाहरण के लिए,
```
    <extractDestinationNames>drifter profile</extractDestinationNames>  
```
drifter=tig17,profile=1017, drifter=tig17,profile=1095, ... drifter=une12,profile=1223, drifter=une12,profile=1251, drifter=une12,profile=1251, ....

उन स्थितियों में जहां एक स्तंभ (उदाहरण के लिए, प्रोफ़ाइल) उन सभी हो सकते हैं जिन्हें विशिष्ट रूप से डेटा की पंक्तियों के एक समूह की पहचान करने की आवश्यकता होती है, यदि बहुत बड़ी संख्या में हैं, उदाहरण के लिए, प्रोफाइल, यह भी एक अतिरिक्त उद्धरण निर्दिष्ट करने के लिए उपयोगी हो सकता है गंतव्य नाम (उदाहरण के लिए, drifter) जो प्रोफाइल को विभाजित करने के लिए कार्य करता है। यह किसी दिए गए निर्देशिका में कम डेटा फ़ाइलों की ओर जाता है, जिससे तेजी से पहुंच हो सकती है।
    
#### स्थानीय फ़ाइलें{#local-files} 
डेटा का प्रत्येक हिस्सा एक अलग में संग्रहीत किया जाता है NetCDF एक subdirectory में फ़ाइल *बड़ाParentDirectory* साइटमैप * datasetID * / (यथा निर्दिष्ट [साइटमैप](/docs/server-admin/deploy-install#setupxml) ) । सभी के लिए एक उपनिर्देशिका स्तर है लेकिन अंतिम निकालने के लिए गंतव्य नाम है। उदाहरण के लिए, tig17+1017 के लिए डेटा में संग्रहीत किया जाएगा
     *बड़ाParentDirectory* /copy/sampleDataset/tig17/1017 .nc ।
उदाहरण के लिए, une12+1251 के लिए डेटा में संग्रहीत किया जाएगा
     *बड़ाParentDirectory* /copy/sampleDataset/une12/1251 .nc ।
डेटा मूल्यों से बनाए गए निर्देशिका और फ़ाइल नाम को उन्हें फ़ाइल नाम-सुरक्षित बनाने के लिए संशोधित किया गया है (उदाहरण के लिए, अंतरिक्ष को "x20" द्वारा प्रतिस्थापित किया जाता है।) - यह वास्तविक डेटा को प्रभावित नहीं करता है।
     
#### नया डेटा{#new-data} 
प्रत्येक बार EDDTable प्रतिलिपि को फिर से लोड किया गया है, यह देखने के लिए दूरस्थ डेटासेट की जांच करता है कि क्या अलग-अलग हिस्से उपलब्ध हैं। यदि डेटा के एक हिस्से के लिए फ़ाइल पहले से मौजूद नहीं है, तो एक अनुरोध प्राप्त करने के लिए चंक को एक कतार में जोड़ा जाता है। ERDDAP 'टास्कथ्रेड डेटा के टुकड़ों, एक-एक-एक-एक-एक-एक के लिए सभी प्रश्न अनुरोधों को संसाधित करता है। आप कार्य के लिए आंकड़े देख सकते हैंथ्रेड की गतिविधि पर [स्थिति पृष्ठ](/docs/server-admin/additional-information#status-page) और में [दैनिक रिपोर्ट](/docs/server-admin/additional-information#daily-report) । (हाँ, ERDDAP™ इस प्रक्रिया के लिए कई कार्यों को असाइन कर सकता है, लेकिन यह बहुत सारे दूरस्थ डेटा स्रोत की बैंडविड्थ, मेमोरी और सीपीयू समय का उपयोग करेगा, और स्थानीय लोगों के बहुत सारे ERDDAP बैंडविड्थ, मेमोरी और सीपीयू समय, जिनमें से कोई भी अच्छा विचार नहीं है।) 
    
ध्यान दें: पहली बार एक EDDTableCopy लोड हो रहा है, (अगर सब ठीक हो जाता है) डेटा के बहुत सारे अनुरोधों को टाटथ्रेड के कतार में जोड़ा जाएगा, लेकिन कोई स्थानीय डेटा फ़ाइलों का निर्माण नहीं किया जाएगा। इसलिए निर्माता विफल हो जाएगा लेकिन टास्कथ्रेड स्थानीय फ़ाइलों को काम करने और बनाने के लिए जारी रहेगा। यदि सब ठीक हो जाता है, तो टास्कथ्रेड कुछ स्थानीय डेटा फाइलें बना देगा और डेटासेट को फिर से लोड करने का अगला प्रयास करेगा। (~15 मिनट) शुरू में डेटा की एक सीमित राशि के साथ सफल होगा।
    
नोट: स्थानीय डेटासेट के कुछ डेटा होते हैं और आपके डेटा में दिखाई देते हैं ERDDAP यदि दूरस्थ डेटासेट अस्थायी रूप से या स्थायी रूप से सुलभ नहीं है, तो स्थानीय डेटासेट अभी भी काम करेगा।
    
चेतावनी: यदि दूरस्थ डेटासेट बड़ा है और/या दूरस्थ सर्वर धीमी है (यह समस्या नहीं है?) , यह एक पूर्ण स्थानीय प्रतिलिपि बनाने के लिए एक लंबे समय तक ले जाएगा। कुछ मामलों में, आवश्यक समय अस्वीकार्य होगा। उदाहरण के लिए, T1 लाइन पर 1 टीबी डेटा को ट्रांसमिट करना (0.15 जीबी / एस) इष्टतम परिस्थितियों में कम से कम 60 दिन लगते हैं। इसके अलावा, यह दूरस्थ और स्थानीय कंप्यूटर पर बैंडविड्थ, मेमोरी और सीपीयू टाइम का उपयोग करता है। समाधान दूरस्थ डेटा सेट के प्रशासक को एक हार्ड ड्राइव मेल करना है ताकि वह डेटासेट की एक प्रति बना सके और हार्ड ड्राइव को आपके पास भेज सकें। उस डेटा को शुरुआती बिंदु के रूप में उपयोग करें और EDDTableCopy उस पर डेटा जोड़ देगा। (यही कारण है कि अमेज़ॅन की EC2 क्लाउड सर्विस ने समस्या को संभालने के लिए इस्तेमाल किया, भले ही उनके सिस्टम में बैंडविड्थ बहुत अधिक हो।) 
    
WARNING: यदि मूल्यों का कोई संयोजन दूरस्थ डेटासेट से गायब हो जाता है, तो EDDTableCopy स्थानीय कॉपी की गई फ़ाइल को हटा नहीं देता है। यदि आप चाहते हैं, तो आप इसे स्वयं हटा सकते हैं।
    
#### टेबलकॉपी&lt;चेकSourceData&gt;{#tablecopy-checksourcedata} 
The The most of the datasets.xml इस डेटासेट के लिए एक वैकल्पिक टैग हो सकता है
```
    <checkSourceData>true</checkSourceData>  
```
डिफ़ॉल्ट मान सही है। यदि आप इसे झूठ में सेट करते हैं, तो डेटासेट कभी भी यह देखने के लिए स्रोत डेटासेट की जांच नहीं करेगा कि क्या अतिरिक्त डेटा उपलब्ध है।
     
#### अनुशंसित उपयोग{#recommended-use} 
1. बनाना&lt;डेटासेट&gt; प्रवेश (देशी प्रकार, नहीं EDDTableCopy) दूरस्थ डेटा स्रोत के लिए। **यह सही ढंग से काम कर रहा है, जिसमें सभी वांछित मेटाडाटा शामिल हैं।** 
2. यदि यह बहुत धीमा है, तो इसे EDDTableCopy डेटासेट में लपेटने के लिए XML कोड जोड़ें।
    * एक अलग datasetID   (शायद बदलकर datasetID पुराने datasetID थोड़ा) ।
    * कॉपी करें&lt;सुलभ To&gt;&lt;ReloadEveryNMinutes&gt; और&lt;onChange&gt; दूरस्थ EDDTable के XML से EDDTableCopy के XML में। (EDDTableCopy मामले के लिए उनके मूल्यों; आंतरिक डेटासेट के लिए उनके मूल्यों अप्रासंगिक हो जाते हैं।) 
    * बनाना&lt;निकालने का गंतव्यनाम&gt; टैग (ऊपर देखें) ।
    *   &lt;OrderExtractBy&gt; दूरस्थ डेटासेट में गंतव्य परिवर्तनीय नामों की एक वैकल्पिक स्थान अलग सूची है। जब डेटा के प्रत्येक हिस्से को दूरस्थ सर्वर से डाउनलोड किया जाता है, तो इस खंड को इन चरों द्वारा क्रमबद्ध किया जाएगा। (पहले चर द्वारा, फिर दूसरे चर द्वारा यदि पहला चर बंधा हुआ है, तो ...) । कुछ मामलों में, ERDDAP™ यदि सूची में पहला परिवर्तनीय एक संख्यात्मक चर है तो स्थानीय डेटा फ़ाइलों से डेटा को तेजी से निकालने में सक्षम होगा ( "time" एक संख्यात्मक चर के रूप में गिनती) । लेकिन इन चरों को एक तरह से चुनें जो डेटासेट के लिए उपयुक्त है।
3.   ERDDAP™ डेटा की एक स्थानीय प्रतिलिपि बनाने और बनाए रखने के लिए।
         
* चेतावनी: EDDTableCopy मान लेता है कि प्रत्येक भाग के लिए डेटा मान कभी नहीं बदलता है। अगर वे करते हैं, तो आपको मैन्युअल रूप से चंकने वाली फ़ाइलों को हटाने की आवश्यकता है *बड़ाParentDirectory* साइटमैप * datasetID * / जो बदल गया है और [झंडा](/docs/server-admin/additional-information#flag) डेटासेट को फिर से लोड किया जाना चाहिए ताकि हटाए गए हिस्से को प्रतिस्थापित किया जा सके। यदि आपके पास डेटासेट के लिए एक ईमेल सदस्यता है, तो आपको दो ईमेल मिलेंगे: एक जब डेटासेट पहली बार फिर से लोड हो जाता है और डेटा कॉपी करना शुरू कर देता है, और दूसरा जब डेटासेट फिर से लोड हो जाता है (स्वचालित रूप से) और नए स्थानीय डेटा फ़ाइलों का पता लगाता है।
     
* मेटाडाटा बदलें -- यदि आपको कोई बदलाव करना है addAttributes या स्रोत डेटासेट से जुड़े चर के आदेश को बदलने:
    1. परिवर्तन addAttributes में स्रोत डेटासेट के लिए datasets.xml , आवश्यकतानुसार।
    2. प्रतिलिपिबद्ध फ़ाइलों में से एक को हटा दें।
    3. एक सेट [झंडा](/docs/server-admin/additional-information#flag) तुरंत डेटासेट को पुनः लोड करने के लिए। यदि आप एक ध्वज का उपयोग करते हैं और आपके पास डेटासेट के लिए एक ईमेल सदस्यता है, तो आपको दो ईमेल मिलेंगे: एक जब डेटासेट पहली बार फिर से लोड हो जाता है और डेटा कॉपी करना शुरू कर देता है, और दूसरा जब डेटासेट फिर से लोड हो जाता है (स्वचालित रूप से) और नए स्थानीय डेटा फ़ाइलों का पता लगाता है।
    4. हटाई गई फ़ाइल को नए मेटाडाटा के साथ फिर से बनाया जाएगा। यदि स्रोत डेटासेट कभी अनुपलब्ध है, तो EDDTableCopy डेटासेट को पुनर्जन्मित फ़ाइल से मेटाडाटा मिलेगा, क्योंकि यह सबसे छोटा फ़ाइल है।
         
*    [ EDDGrid कॉपी](#eddgridcopy) EDDTableCopy के समान है, लेकिन ग्रिड डेटासेट के साथ काम करता है।
#### EDDTableCopy कंकाल XML{#eddtablecopy-skeleton-xml} 
>&nbsp;&nbsp;&lt;dataset type="EDDTableCopy" [datasetID](#datasetid)\\="..." [active](#active)\\="..." >  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleTo>](#accessibleto)...&lt;/accessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;graphsAccessibleTo>](#graphsaccessibleto)auto|public&lt;/graphsAccessibleTo> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;accessibleViaFiles>](#accessibleviafiles)true|false(default)&lt;/accessibleViaFiles>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;reloadEveryNMinutes>](#reloadeverynminutes)...&lt;/reloadEveryNMinutes> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultDataQuery>](#defaultdataquery)...&lt;/defaultDataQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;defaultGraphQuery>](#defaultgraphquery)...&lt;/defaultGraphQuery> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;addVariablesWhere>](#addvariableswhere)...&lt;/addVariablesWhere> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fgdcFile>](#fgdcfile)...&lt;/fgdcFile> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;iso19115File>](#iso19115file)...&lt;/iso19115File> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;onChange>](#onchange)...&lt;/onChange> &lt;!-- 0 or more -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;extractDestinationNames>...&lt;/extractDestinationNames>  &lt;!-- 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;orderExtractBy>...&lt;/orderExtractBy> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;fileTableInMemory>](#filetableinmemory)...&lt;/fileTableInMemory> &lt;!-- 0 or 1 (true or false  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(the default)) -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;checkSourceData>](#tablecopy-checksourcedata)...&lt;/checkSourceData> &lt;!-- 0 or 1 -->  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dataset>...&lt;/dataset> &lt;!-- 1 -->  
>&nbsp;&nbsp;&lt;/dataset>  

- -

## विवरण{#details-1} 

यहाँ सामान्य टैग और विशेषताओं के विस्तृत विवरण दिए गए हैं।

### &lt;AngularDegreeUnits&gt;{#angulardegreeunits} 
* [ ** &lt;कोणीयDegreeUnits&gt; ** ] (#angulardegreeunits) शायद ही कभी एक के भीतर OPTIONAL टैग का इस्तेमाल किया जाता है&lt;erddapDatasets टैग में datasets.xml जिसमें इकाइयों के तारों की एक अल्पसंख्यक सूची शामिल है जो कि इकाइयों के तारों की सूची होती है। ERDDAP™ कोणीय डिग्री इकाइयों के रूप में इलाज करना चाहिए। यदि एक चर इन इकाइयों में से एक है, tabledap ' orderByMean फिल्टर एक विशेष तरीके से मतलब की गणना करेगा, फिर -180 से 180 तक के मूल्य के रूप में इस अर्थ की रिपोर्ट करेगा। देखें ERDDAP वर्तमान डिफ़ॉल्ट सूची के लिए EDStatic.java स्रोत कोड फ़ाइल। इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) ।
### &lt;AngularDegreeTrueUnits&gt;{#angulardegreetrueunits} 
* [ ** &lt;कोणीय डिग्रीTrueUnits&gt; ** ] (#angulardegreetrueunits) शायद ही कभी एक के भीतर OPTIONAL टैग का इस्तेमाल किया जाता है&lt;erddapDatasets टैग में datasets.xml जिसमें इकाइयों के तारों की एक अल्पसंख्यक सूची शामिल है जो कि इकाइयों के तारों की सूची होती है। ERDDAP™ कोणीय डिग्री वास्तविक इकाइयों के रूप में इलाज करना चाहिए। यदि एक चर इन इकाइयों में से एक है, tabledap ' orderByMean फिल्टर एक विशेष तरीके से मतलब की गणना करेगा, फिर 0 से 360 तक मूल्य के रूप में इस बीच रिपोर्ट करेगा। देखें ERDDAP वर्तमान डिफ़ॉल्ट सूची के लिए EDStatic.java स्रोत फ़ाइल। इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) ।
     
### &lt;सामान्य मानक नाम और GT;{#commonstandardnames} 
* [ ** &lt;सामान्य StandardNames ** ] (#commonstandardname) शायद ही कभी एक के भीतर OPTIONAL टैग का इस्तेमाल किया जाता है&lt;erddapDatasets टैग में datasets.xml आम की एक अल्पसंख्यक सूची निर्दिष्ट करने के लिए [CF मानक नाम](https://cfconventions.org/Data/cf-standard-names/current/build/cf-standard-name-table.html) । E.g.
```
    <commonStandardNames>air\\_pressure, ..., wind\\_to\\_direction</commonStandardNames>  
```
इस सूची का उपयोग DataProviderForm3.html में उपयोगकर्ताओं की सुविधा के रूप में किया जाता है।
यदि आप इस जानकारी को प्रदान करना चाहते हैं datasets.xml वर्तमान डिफ़ॉल्ट सूची को कॉपी करके शुरू करें&lt;DEFAULT \\_commonStandardNames&gt; में ERDDAP '
 \\[ tomcat \\] / webapps/erddap/WEB-INF/classes/gov/noaa/pfel/erddap/util/message.xml फ़ाइल.
     
### &lt;कैशमिन्यूट एंड GT;{#cacheminutes} 
* [ ** &lt;कैश मिनट&gt; ** ] (#cachemins) शायद ही कभी एक के भीतर OPTIONAL टैग का इस्तेमाल किया जाता है&lt;erddapDatasets टैग में datasets.xml उम्र निर्दिष्ट करने के लिए (मिनट) जिस पर कैश में फ़ाइलों को हटा दिया जाना चाहिए (डिफ़ॉल्ट=60) । E.g.
```
    <cacheMinutes>60</cacheMinutes>  
```
सामान्य तौर पर, केवल छवि फ़ाइलों (क्योंकि समान छवियों को अक्सर बार-बार अनुरोध किया जाता है) और .nc फ़ाइलें (क्योंकि उन्हें उपयोगकर्ता को भेजने से पहले पूरी तरह से बनाया जाना चाहिए) कैश्ड हैं। हालांकि ऐसा लग सकता है कि किसी दिए गए अनुरोध की तरह हमेशा उसी प्रतिक्रिया को वापस करना चाहिए, यह सच नहीं है। उदाहरण के लिए, एक tabledap अनुरोध जिसमें समय शामिल है&gt; *कुछ समय* डेटासेट के लिए आने पर नया डेटा बदल जाएगा। और एक ग्रिडडैप अनुरोध जिसमें शामिल है \\[ अंतिम \\] जब नया डेटा डेटा सेट के लिए आता है तो समय आयाम बदल जाएगा। इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) । पहले ERDDAP™ v2.00, यह सेटअप.xml में निर्दिष्ट किया गया था, जो अभी भी अनुमति है लेकिन हतोत्साहित है।

### &lt;कैशक्लियर मिनट&gt;{#cacheclearminutes} 
* [ ** &lt;कैशक्लियर मिनट&gt; ** ] (#cacheclearmins) शायद ही कभी एक के भीतर OPTIONAL टैग का इस्तेमाल किया जाता है&lt;erddapDatasets टैग में datasets.xml कैश्ड फ़ाइलों की जांच करने और पुराने लोगों को हटाने के लिए आवृत्ति निर्दिष्ट करने के लिए (मिनट)   (डिफ़ॉल्ट=15) । E.g.
```
    <cacheClearMinutes>15</cacheClearMinutes>  
```
जब सर्वर एक अनुरोध को संभालने के लिए समाप्त होता है तो यह जांच करेगा कि आखिरी कैश क्लियर कितने समय पहले था। यदि यह बहुत लंबे समय तक था, तो यह कैश को साफ़ करने के लिए टास्कथ्रेड पर एक कार्य को कतार करेगा। इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) । यह सेटअप.xml में निर्दिष्ट में निर्दिष्ट किया जा सकता है, लेकिन यह हतोत्साहित है।
     
### &lt;InterpolateRequestCSVExample&gt;{#convertinterpolaterequestcsvexample} 
* [ ** &lt;InterpolateRequestCSVExample ** ] (#changinginterpolaterequestcsvexample) एक के भीतर एक OPTIONAL टैग है&lt;erddapDatasets टैग में datasets.xml   \\[ शुरू ERDDAP™ v2.10 \\] जिसमें एक उदाहरण होता है जो इंटरप्लेट कनवर्टर के वेब पेज पर दिखाया जाएगा। डिफ़ॉल्ट मान है: jplmu RSS T41/analysed \\_ sst /Bilinear / 4।
### &lt;ConvertinterpolateDatasetIDVariableList&gt;{#convertinterpolatedatasetidvariablelist} 
* [ ** &lt;InterpolateDatasetIDVariableलिस्ट&gt; ** ] (#changinginterpolatedatasetidvariablelist) एक के भीतर एक OPTIONAL टैग है&lt;erddapDatasets टैग में datasets.xml   \\[ शुरू ERDDAP™ v2.10 \\] जिसमें CSV की सूची शामिल है datasetID परिवर्तनीय नाम उदाहरण जो इंटरप्लेट कनवर्टर के वेब पेज द्वारा सुझावों के रूप में इस्तेमाल किया जाएगा। डिफ़ॉल्ट मान है: jplmu RSS T41/analysed \\_ sst ।
### &lt;ConvertTopublicSourceUrl&gt;{#converttopublicsourceurl} 
* [ ** &lt;ConvertTopublicSourceUrl&gt; ** ] (#converttopublicsourceurl) एक के भीतर एक OPTIONAL टैग है&lt;erddapDatasets टैग में datasets.xml जिसमें एक "से" और "से" गुण होता है, जो बताता है कि मिलान करने वाले स्थानीय को कैसे परिवर्तित किया जाए sourceUrl   (आमतौर पर आईपी संख्या) जनता में sourceUrl   (डोमेन नाम) "से" होना चाहिए \\[ कुछ \\] // \\[ कुछ \\] / इन टैगों में से 0 या अधिक हो सकते हैं। अधिक जानकारी के लिए देखें&lt; sourceUrl &gt; (#sourceurl) । उदाहरण के लिए,
```
    <convertToPublicSourceUrl from="https://192.168.31.18/" to="https://oceanwatch.pfeg.noaa.gov/" />  
```
स्थानीय मिलान करना sourceUrl   (जैसेhttps://192.168.31.18/thredds/dodsC/satellite/BA/ssta/5day)   
जनता में sourceUrl   (https://oceanwatch.pfeg.noaa.gov/thredds/dodsC/satellite/BA/ssta/5day) ।
इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) ।

लेकिन, सदस्यता प्रणाली से संबंधित सुरक्षा कारणों और कारणों के लिए, **इस टैग का उपयोग नहीं करें&#33;**   
इसके बजाय, हमेशा सार्वजनिक डोमेन नाम का उपयोग करते हैं&lt; sourceUrl &gt; टैग और उपयोग [/etc/hosts table](https://linux.die.net/man/5/hosts) अपने सर्वर पर एक DNS सर्वर का उपयोग किए बिना स्थानीय डोमेन नामों को IP नंबर में बदलने के लिए। आप परीक्षण कर सकते हैं कि क्या डोमेन नाम को ठीक से IP नंबर में बदल दिया गया है:
पिंग *कुछ डोमेन नाम*   
     
### Englishالعربية中文(简体)हिन्दी; हिंदीاردو{#dataimagepngbase64} 
* जब कोई उपयोगकर्ता अनुरोध करता है .htmlTable से प्रतिक्रिया ERDDAP™ यदि किसी स्ट्रिंग सेल में डेटा में डेटा शामिल है:image/png;base64, उसके बाद एक base64 encoded.png छवि, ERDDAP™ एक आइकन प्रदर्शित करेगा (इसलिए उपयोगकर्ता छवि को देख सकता है यदि वे उस पर पड़ते हैं) और बटन पाठ या छवि को क्लिपबोर्ड पर सहेजने के लिए। इस सुविधा में जोड़ा गया था ERDDAP™ v2.19 मार्को अल्बा द्वारा।
###  drawLandMask  {#drawlandmask} 
*    [ ** drawLandMask ** ](#drawlandmask) डिफ़ॉल्ट सेटिंग को निर्दिष्ट करता है जो जब और कैसे लैंडमास्क को खींचा जाना चाहिए ERDDAP™ एक नक्शा खींचता है। इसे तीन अलग स्थानों में निर्दिष्ट किया जा सकता है datasets.xml   (न्यूनतम से उच्चतम प्राथमिकता तक सूचीबद्ध) :
    
    1. अगर drawLandMask भीतर निर्दिष्ट है&lt;erddapDatasets (किसी विशिष्ट डेटासेट से जुड़ा नहीं है) तब यह डिफ़ॉल्ट मान को निर्दिष्ट करता है drawLandMask सभी डेटासेट में सभी चर के लिए। उदाहरण के लिए,
    ```
        <drawLandMask>under</drawLandMask>  
    ```
इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP पढ़ना datasets.xml ।
यदि यह टैग मौजूद नहीं है, तो अंतर्निहित डिफ़ॉल्ट मान नीचे है।
         
    2. अगर drawLandMask किसी दिए गए डेटासेट की वैश्विक विशेषता के रूप में निर्दिष्ट किया गया है, फिर यह डिफ़ॉल्ट मान को निर्दिष्ट करता है drawLandMask उस डेटासेट में सभी चरों के लिए, किसी भी कम प्राथमिकता सेटिंग को ओवरराइड करना। उदाहरण के लिए,
    ```
        <att name="drawLandMask">under</att>  
    ```
इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ उस डेटासेट को पुनः लोड करता है।
         
    3. अगर drawLandMask किसी दिए गए डेटासेट में एक चर की विशेषता के रूप में निर्दिष्ट किया गया है, फिर यह डिफ़ॉल्ट मान को निर्दिष्ट करता है drawLandMask उस डेटासेट में उस चर के लिए, किसी भी कम प्राथमिकता सेटिंग को ओवरराइड करना। उदाहरण के लिए,
    ```
        <att name="drawLandMask">under</att>  
    ```
इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ उस डेटासेट को पुनः लोड करता है।
    
एक उपयोगकर्ता डिफ़ॉल्ट ओवरराइड कर सकता है (जहां भी यह निर्दिष्ट है) डेटासेट के मेक ए ग्राफ वेब पेज पर ड्रॉपडाउन सूची से "ड्रॉ लैंड मास्क" के लिए एक मूल्य का चयन करके, या सहित &.land= *मूल्य* URL में जो एक मानचित्र का अनुरोध करता है ERDDAP ।
    
सभी स्थितियों में, विशेषता के लिए 4 संभावित मान हैं:
    
    * इससे पहले कि यह मानचित्र पर डेटा खींचता है, "under" लैंडमास्क खींचता है।
ग्रिड डेटासेट के लिए, जमीन एक स्थिर हल्के भूरे रंग के रूप में दिखाई देती है।
सारणीबद्ध डेटासेट के लिए, "under" भूमि और महासागरों पर स्थलाकृति डेटा दिखाता है।
    * "over" ग्रिड डेटासेट के लिए, "ओवर" मानचित्रों पर डेटा आकर्षित करने के बाद लैंडमास्क को आकर्षित करता है ताकि यह जमीन पर किसी भी डेटा को मास्क कर सके। सारणीबद्ध डेटासेट के लिए, "ओवर" समुद्र के स्नानागार को दर्शाता है और एक स्थिर प्रकाश धूसर जहां भूमि है, दोनों डेटा के तहत खींचा गया है।
    * "outline" सिर्फ भू-मास्क, राजनीतिक सीमाओं, झीलों और नदियों की रूपरेखा तैयार करता है।
    * "बंद" कुछ नहीं खींचता है।
### &lt;EmailDiagnosticsToErdData&gt;{#emaildiagnosticstoerddata} 
* [ ** &lt;EmailDiagnosticsToErdData ** ] (#emaildiagnosticstoerddata) शायद ही कभी एक के भीतर OPTIONAL टैग का इस्तेमाल किया जाता है&lt;erddapDatasets टैग में datasets.xml । टैग का मान सही हो सकता है (डिफ़ॉल्ट) या झूठा। यदि सच हो, ERDDAP™ क्रिस को स्टैक ट्रेस ईमेल करेंगे। जॉन नोआ में। सरकारी (The number of the ERDDAP™ विकास दल) । यह सुरक्षित और सुरक्षित होना चाहिए क्योंकि कोई गोपनीय जानकारी नहीं (उदाहरण के लिए, अनुरोधUrl) ईमेल में शामिल है। यह किसी भी अस्पष्ट, पूरी तरह से अप्रत्याशित बग है कि NullPointerException के लिए नेतृत्व करने के लिए संभव बनाना चाहिए। अन्यथा, उपयोगकर्ता अपवाद देखता है, लेकिन ERDDAP™ विकास दल नहीं करता (इसलिए हम नहीं जानते कि वहाँ एक समस्या है जिसे तय करने की आवश्यकता है) ।
     
### &lt;graphbackgroundColor&gt;{#graphbackgroundcolor} 
* [ ** &lt;ग्राफ़ बैकग्राउंड कलर&gt; ** ] (#graphbackgroundcolor) शायद ही कभी एक के भीतर OPTIONAL टैग का इस्तेमाल किया जाता है&lt;erddapDatasets टैग में datasets.xml ग्राफ़ पर डिफ़ॉल्ट पृष्ठभूमि रंग निर्दिष्ट करने के लिए। यह लगभग सभी ग्राफों को प्रभावित करता है। कुछ स्थितियों में प्रभावित नहीं होते हैं। रंग 0xAARRGGBB, जहां AA, RR, GG, और BB क्रमशः अस्पष्टता, लाल, हरे और नीले घटकों के रूप में निर्दिष्ट है। "0x" मामला संवेदनशील है, लेकिन हेक्साडेसिमल अंक संवेदनशील नहीं हैं। उदाहरण के लिए, एक पूरी तरह से अपारदर्शी (एफएफ) red=22, green=88, blue=ee के साथ हरे-नीले रंग 0xff2288ee होगा। अपारदर्शी सफेद 0xffffff है। डिफ़ॉल्ट opaque प्रकाश नीला है (0xffccff) , जिसमें सफेद से अलग होने का लाभ होता है, जो कई पैलेटों में एक महत्वपूर्ण रंग है जो डेटा आकर्षित करने के लिए उपयोग किया जाता है। उदाहरण के लिए,
    ```
    <graphBackgroundColor>0xffffffff</graphBackgroundColor>  
    ```
इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) ।
### &lt;IPAddressMaxRequest&gt;{#ipaddressmaxrequests} 
* [ ** &lt;IpAddressMaxRequests&gt; ** ] (#ipaddressmaxrequest) शायद ही कभी इस्तेमाल किया वैकल्पिक टैग है (पहली बार ERDDAP™ v2.12.) भीतर&lt;erddapDatasets टैग में datasets.xml यह एक प्रणाली का हिस्सा है जो अत्यधिक आक्रामक वैध उपयोगकर्ताओं और दुर्भावनापूर्ण उपयोगकर्ताओं की क्षमता को सीमित करने के लिए एक साथ अनुरोधों की एक बड़ी संख्या बनाने के लिए है जो अन्य उपयोगकर्ताओं के लिए सिस्टम प्रदर्शन को कम करेगा। IpAddress MaxRequests एक साथ अनुरोधों की अधिकतम संख्या निर्दिष्ट करता है जो किसी विशिष्ट आईपी पते से स्वीकार किए जाएंगे। अतिरिक्त अनुरोधों को HTTP 429 त्रुटि प्राप्त होगी: बहुत सारे अनुरोध। erddap/download/और erddap/images/ में छोटी, स्थिर फाइलें इस गिनती से मुक्त नहीं हैं। डिफ़ॉल्ट है 15. अधिकतम अनुमति 1000 है, जो पागल उच्च है - यह मत करो&#33; ERDDAP™ 6 से कम संख्या को स्वीकार नहीं किया क्योंकि कई वैध उपयोगकर्ता (वेब ब्राउज़र WMS ग्राहक) एक समय में 6 अनुरोध करने के लिए। The The most of the ERDDAP™ डेली रिपोर्ट और प्रत्येक मेजर डेटासेट रीलोड के साथ log.txt फ़ाइल को लिखने वाली समान जानकारी, अब "Requester's IP address" शीर्षक के तहत इन IP पते के अनुरोधों का एक लंबा हिस्सा होगा। (बहुत सारे अनुरोध) "।
इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) ।
    
"Major LoadDatasets Time Series" स्थिति का अनुभाग.html में एक "tooMany" कॉलम शामिल है जो अनुरोधों की संख्या को सूचीबद्ध करता है जो उपयोगकर्ता की ipAddressMaxRequests सेटिंग से अधिक है और इस प्रकार "Too Many request" त्रुटि देखी गई है। इससे आपको आसानी से देखने की अनुमति मिलती है जब आप अत्यधिक आक्रामक वैध उपयोगकर्ताओं और दुर्भावनापूर्ण उपयोगकर्ताओं को सक्रिय कर सकते हैं। (वैकल्पिक) log.txt फ़ाइल को देखें और यह तय करें कि क्या आप उन उपयोगकर्ताओं को ब्लैकलिस्ट करना चाहते हैं।
    
यह एक उच्च संख्या के लिए निर्धारित करने के साथ विशेष रूप से गलत नहीं है। यह तुम्हारे ऊपर है। लेकिन ऐसा करने से लोगों को सिस्टम स्थापित करने की अनुमति मिलती है जो परियोजनाओं पर काम करने के लिए बड़ी संख्या में धागे का उपयोग करते हैं और फिर उन्हें कोई प्रतिक्रिया नहीं मिलती है कि वे क्या कर रहे हैं उन्हें कोई लाभ नहीं मिल रहा है।
### &lt;IPAddressMaxRequestActive&gt;{#ipaddressmaxrequestsactive} 
* [ ** &lt;IpAddressMaxRequestActive&gt; ** ] (#ipaddressmaxrequestactive) शायद ही कभी इस्तेमाल किया वैकल्पिक टैग है (पहली बार ERDDAP™ v2.12.) भीतर&lt;erddapDatasets टैग में datasets.xml यह एक प्रणाली का हिस्सा है जो अत्यधिक आक्रामक वैध उपयोगकर्ताओं और दुर्भावनापूर्ण उपयोगकर्ताओं की क्षमता को सीमित करने के लिए एक साथ अनुरोधों की एक बड़ी संख्या बनाने के लिए है जो अन्य उपयोगकर्ताओं के लिए सिस्टम प्रदर्शन को कम करेगा। IPAddressMaxRequestsActive एक साथ अनुरोधों की अधिकतम संख्या को निर्दिष्ट करता है जिसे सक्रिय रूप से किसी विशिष्ट IP पते से संसाधित किया जाएगा। अतिरिक्त अनुरोध एक कतार में बैठ जाएगा जब तक कि पिछले अनुरोधों को संसाधित नहीं किया गया है। erddap/download/और erddap/images/ में छोटी, स्थिर फाइलें इस गिनती और संबंधित थ्रॉटलिंग से मुक्त हैं। डिफ़ॉल्ट है 2. अधिकतम अनुमति 100 है, जो पागल उच्च है - यह मत करो&#33; आप इसे सख्त होने के लिए सेट कर सकते हैं, खासकर अगर आपके पास अत्यधिक आक्रामक या दुर्भावनापूर्ण उपयोगकर्ताओं के साथ समस्याएं हैं। उपयोगकर्ता अभी भी जल्दी से सभी डेटा वे अनुरोध करते हैं (ipAddressMaxRequests तक) लेकिन वे सिस्टम संसाधनों को हॉग करने में सक्षम नहीं होंगे। हम इसे एक बड़ी संख्या में सेट करने की सलाह नहीं देते क्योंकि यह अत्यधिक आक्रामक वैध उपयोगकर्ताओं और दुर्भावनापूर्ण उपयोगकर्ताओं को हावी करने की अनुमति देता है ERDDAP प्रसंस्करण क्षमता।
इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) ।
     
### &lt;IPAddressUnlimited&gt;{#ipaddressunlimited} 
* [ ** &lt;ipAddressUnlimited&gt; ** ] (#ipaddressunlimited) शायद ही कभी इस्तेमाल किया वैकल्पिक टैग है (पहली बार ERDDAP™ v2.12.) भीतर&lt;erddapDatasets टैग में datasets.xml यह एक प्रणाली का हिस्सा है जो अत्यधिक आक्रामक वैध उपयोगकर्ताओं और दुर्भावनापूर्ण उपयोगकर्ताओं की क्षमता को सीमित करने के लिए एक साथ अनुरोधों की एक बड़ी संख्या बनाने के लिए है जो अन्य उपयोगकर्ताओं के लिए सिस्टम प्रदर्शन को कम करेगा। IPAddressUnlimited आईपी पते की एक अल्पसंख्यक सूची है जिसे आप अपनी असीमित पहुंच की अनुमति देना चाहते हैं। ERDDAP । लॉग इन करें यह देखने के लिए कि कौन से प्रारूप आपका सर्वर आईपी पते के लिए उपयोग कर रहा है। कुछ सर्वरों पर, आईपी पते प्रारूप # में होंगे।# (जहां # 0 से 255 तक एक पूर्णांक है) जबकि दूसरों पर यह प्रारूप #:#:#:#:#:#:#:#:#:#:#:#:# । इस सूची में अनुरोधकर्ता या तो ipAddressMaxRequests या ipAddressMaxRequestsActive सेटिंग्स के अधीन नहीं हैं। यह एक माध्यमिक हो सकता है ERDDAP™ या अपने सिस्टम में कुछ उपयोगकर्ताओं या सर्वरों के लिए। ERDDAP™ हमेशा कहते हैं " (अज्ञातIPAddress) " ERDDAP™ जब अनुरोधकर्ता के आईपी पते को निर्धारित नहीं किया जा सकता है, उदाहरण के लिए, उसी सर्वर पर चल रही अन्य प्रक्रियाओं के लिए।
इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) ।
    
यदि किसी कारण से सभी उपयोगकर्ता के अनुरोधों को त्रुटि संदेश "टाइमआउट को प्रोसेस करने के लिए आपके अन्य अनुरोधों के लिए इंतजार करना" मिलता है।
    
### &lt;LoadDatasetsMinutes&gt;{#loaddatasetsminminutes} 
* [ ** &lt;LoadDatasetsMinutes&gt; ** ] (#loaddatasetsminminutes) शायद ही कभी एक के भीतर OPTIONAL टैग का इस्तेमाल किया जाता है&lt;erddapDatasets टैग में datasets.xml न्यूनतम समय निर्दिष्ट करने के लिए (मिनट) प्रमुख भार के बीच डेटासेट (जब ERDDAP™ प्रसंस्करण datasets.xml प्रत्येक डेटासेट की जाँच करके यह देखने के लिए कि क्या इसकी आवश्यकता है उसके पुनः लोड के अनुसार पुनः लोड होना चाहिए प्रत्येकNMinutes सेटिंग, डिफ़ॉल्ट=15) । E.g.
```
    <loadDatasetsMinMinutes>15</loadDatasetsMinMinutes>  
```
यदि इस समय से लोडडेटासेट का कोई निश्चित रन कम लेता है, तो लोडर सिर्फ बार-बार फ्लैग डायरेक्टरी को देखता है और/या तब तक सोता है जब तक कि शेष समय समाप्त हो गया हो। डिफ़ॉल्ट 15 मिनट है, जो लगभग सभी के लिए ठीक होना चाहिए। इसे एक छोटी संख्या में सेट करने के लिए एकमात्र नुकसान यह है कि यह आवृत्ति को बढ़ा देगा कि ERDDAP™ उन डेटासेटों को पुनर्स्थापित करें जिनके पास त्रुटियां हैं जो उन्हें लोड होने से रोकती हैं (उदाहरण के लिए, एक दूरस्थ सर्वर नीचे है) । यदि ऐसे बहुत सारे डेटासेट होते हैं और उन्हें बार-बार परीक्षण किया जाता है, तो डेटा स्रोत इसे कीस्टरिंग / आक्रामक व्यवहार पर विचार कर सकता है। इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) । पहले ERDDAP™ v2.00, यह सेटअप.xml में निर्दिष्ट किया गया था, जो अभी भी अनुमति है लेकिन हतोत्साहित है।
     
### &lt;LoadDatasetsMaxMinutes&gt;{#loaddatasetsmaxminutes} 
* [ ** &lt;LoadDatasetMaxMinutes&gt; ** ] (#loaddatasetsmaxminutes) एक के भीतर एक OPTIONAL टैग है&lt;erddapDatasets टैग में datasets.xml अधिकतम समय निर्दिष्ट करने के लिए (मिनट) एक प्रमुख भार डेटासेट प्रयास को लेने की अनुमति है (भार से पहले डेटासेट थ्रेड को "स्टॉल" के रूप में माना जाता है और बाधित होता है)   (डिफ़ॉल्ट=60) । E.g.
```
    <loadDatasetsMaxMinutes>60</loadDatasetsMaxMinutes>  
```
सामान्य तौर पर, यह तब तक कम से कम दो बार निर्धारित किया जाना चाहिए जब तक आपको तर्कपूर्वक लगता है कि सभी डेटासेट को फिर से लोड करना (संक्षेप में) लेना (चूंकि कंप्यूटर और नेटवर्क कभी-कभी उम्मीद से धीमी होते हैं) यह हमेशा loadDatasetsMinutes की तुलना में बहुत लंबा होना चाहिए। डिफ़ॉल्ट 60 मिनट है। कुछ लोग इसे लंबे समय तक सेट करेंगे। इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) । पहले ERDDAP™ v2.00, यह सेटअप.xml में निर्दिष्ट किया गया था, जो अभी भी अनुमति है लेकिन हतोत्साहित है।
     
### &lt;LogLevel&gt;{#loglevel} 
* [ ** &lt;लॉग इन करें ** ] (#loglevel) एक के भीतर एक OPTIONAL टैग है&lt;erddapDatasets टैग में datasets.xml यह निर्दिष्ट करने के लिए कि कितने नैदानिक संदेश log.txt फ़ाइल में भेजे जाते हैं। इसे "गर्मी" के लिए सेट किया जा सकता है (सबसे कम संदेश) "इन्फो" (डिफ़ॉल्ट) , या "सभी" (अधिकांश संदेश) । E.g.
```
    <logLevel>info</logLevel>  
```
इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) । पहले ERDDAP™ v2.00, यह सेटअप.xml में निर्दिष्ट किया गया था, जो अभी भी अनुमति है लेकिन हतोत्साहित है।
     
### &lt;आंशिकRequestMaxBytes&gt; और&lt;आंशिकRequestMaxCells&gt;{#partialrequestmaxbytes-and-partialrequestmaxcells} 
* [ ** &lt;आंशिकRequestMaxBytes&gt; **] (#partialrequestmaxbytes-and-partialrequestmaxcells) [** &lt;आंशिकRequestMaxCells&gt; ** ] (#partialrequestmaxbytes-and-partialrequestmaxcells) शायद ही कभी एक के भीतर OPTIONAL टैग का उपयोग किया जाता है&lt;erddapDatasets टैग में datasets.xml । जब संभव हो (यह हमेशा संभव नहीं है) , ERDDAP™ बड़े डेटा अनुरोधों को स्मृति को संरक्षित करने के लिए टुकड़ों में तोड़ देता है।
    
32 बिट Java एक सरल भावना में, एक साथ की अधिकतम संख्या *बड़ा* अनुरोध मोटे तौर पर उपलब्ध स्मृति का 3/4 है (-Xmx मान टॉमकैट में पारित) खंड आकार (उदाहरण के लिए, 1200 MB / 100 MB =&gt; 12 request) । अन्य चीजों को स्मृति की आवश्यकता होती है, इसलिए अनुरोधों की वास्तविक संख्या कम हो जाएगी। अभ्यास में, चंकण हमेशा संभव नहीं है। इसलिए एक विशाल या कुछ बहुत बड़े एक साथ गैर-चंकनीय अनुरोध 32 बिट पर समस्याएं पैदा कर सकता है Java ।

64 बिट के साथ Java -Xmx मान बहुत बड़ा हो सकता है। इसलिए स्मृति एक बाधा होने की संभावना बहुत कम है।

आप इन टैगों को परिभाषित करके डिफ़ॉल्ट चंक आकार को ओवरराइड कर सकते हैं datasets.xml   (यहाँ से प्रदर्शित की तुलना में विभिन्न मूल्यों के साथ) :
ग्रिड के लिए:&lt;आंशिकRequestMaxBytes&gt;100000000&lt;/partialRequestMaxBytes&gt;
तालिकाओं के लिए:&lt;आंशिकRequestMaxCells&gt; 1000000&lt;/partialRequestMaxCells&gt;

आंशिकRequestMaxBytes एक आंशिक ग्रिड डेटा अनुरोध के लिए बाइट्स की पसंदीदा अधिकतम संख्या है (कुल अनुरोध का एक हिस्सा) । डिफ़ॉल्ट=100000000 (10^8) । बड़ा आकार जरूरी नहीं है (और 500 MB पर नहीं जाना क्योंकि यह THREDDS की डिफ़ॉल्ट सीमा है DAP जवाब) । लेकिन बड़े आकार में फ़ाइलों के टन के कम उपयोग की आवश्यकता हो सकती है (सोचना ERD प्रत्येक समय के साथ उपग्रह डेटा एक अलग फ़ाइल में इंगित करता है - यह प्रत्येक आंशिक अनुरोध में प्रत्येक फ़ाइल से अधिक डेटा प्राप्त करना बेहतर है) ।

आंशिकRequestMaxCells कोशिकाओं की पसंदीदा अधिकतम संख्या है (nRows \\* डेटा तालिका में nColumns) आंशिक TABLE डेटा अनुरोध के लिए (कुल अनुरोध का एक हिस्सा) । डिफ़ॉल्ट = 100000। बड़ा आकार जरूरी नहीं है। वे स्रोत से डेटा के प्रारंभिक बैच के लिए लंबे समय तक इंतजार करते हैं।

इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) । पहले ERDDAP™ v2.00, इन्हें सेटअप.xml में निर्दिष्ट किया गया था, जिसे अभी भी अनुमति दी गई है लेकिन हतोत्साहित किया गया है।
     
### &lt;अनुरोधब्लैकलिस्ट&gt;{#requestblacklist} 
* [ ** &lt;अनुरोधब्लैकलिस्ट&gt; ** ] (#requestblacklist)   [एक वैकल्पिक टैग है](/docs/server-admin/additional-information#frequent-crashes-or-freezes) भीतर&lt;erddapDatasets टैग में datasets.xml जिसमें न्यूमेरिक आईपी पते की एक कॉमा-सेपरेटेड सूची शामिल है जिसे ब्लैकलिस्ट किया जाएगा। इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) ।
    * इसका उपयोग करने के लिए किया जा सकता है [सेवा हमले का डेनियल](https://en.wikipedia.org/wiki/Denial_of_service) अत्यधिक zealous [वेब रोबोट](https://en.wikipedia.org/wiki/Internet_bot) , या किसी अन्य प्रकार के परेशानी उपयोगकर्ता।
    * समस्याग्रस्त उपयोगकर्ता अगर ERDDAP™ एक क्रॉल या फ्रीज / स्टॉप को धीमा कर देता है, कारण अक्सर एक परेशानी वाला उपयोगकर्ता होता है जो एक बार में एक से अधिक स्क्रिप्ट चला रहा है और / या बड़ी संख्या में बहुत बड़ी, अत्यंत अक्षम, या अमान्य अनुरोध, या एक साथ अनुरोध करता है। देखो [लॉग-इन](/docs/server-admin/additional-information#log) यह देखने के लिए कि क्या यह मामला है और परेशानी उपयोगकर्ता के संख्यात्मक आईपी पते को ढूंढना है। यदि यह समस्या है तो आपको शायद उस उपयोगकर्ता को ब्लैकलिस्ट करना चाहिए।
        
कब ERDDAP™ एक ब्लैकलिस्ट आईपी पते से अनुरोध प्राप्त होता है, यह HTTP त्रुटि 403: निषिद्ध वापस आ जाएगा। पाठ त्रुटि संदेश के साथ उपयोगकर्ता को ईमेल करने के लिए प्रोत्साहित करता है, जो आपको ईमेल करने के लिए प्रोत्साहित करता है। ERDDAP व्यवस्थापक, समस्याओं को दूर करने के लिए। यदि वे त्रुटि संदेश पढ़ने का समय लेते हैं (कई स्पष्ट रूप से नहीं करते) और आपसे संपर्क करें, फिर आप उन्हें एक समय में सिर्फ एक स्क्रिप्ट चलाने के लिए उन्हें पाने के लिए उनके साथ काम कर सकते हैं, अधिक कुशल अनुरोध कर सकते हैं, अपनी स्क्रिप्ट में समस्याओं को ठीक कर सकते हैं (उदाहरण के लिए, एक दूरस्थ डेटासेट से डेटा का अनुरोध करना जो टाइमिंग आउट करने से पहले जवाब नहीं दे सकता) , या जो कुछ भी परेशानी का स्रोत था।
        
उपयोगकर्ता अक्सर अनजान होते हैं कि उनके अनुरोधों में परेशानी होती है। वे अक्सर बग, सकल अक्षमता, या उनकी स्क्रिप्ट के साथ अन्य समस्याओं से अनजान होते हैं। वे अक्सर सोचते हैं कि आपके कारण ERDDAP™ मुक्त करने के लिए डेटा प्रदान करता है, कि वे जितना चाहें उतना डेटा पूछ सकते हैं, उदाहरण के लिए, एकाधिक स्क्रिप्ट चलाकर या एकाधिक धागे का उपयोग करके।
        
        * आप उन्हें बता सकते हैं कि प्रत्येक ERDDAP™ अब यह बात है कि कितना बड़ा और शक्तिशाली है, इसमें सीमित संसाधन हैं (CPU समय, हार्ड ड्राइव I/O, नेटवर्क बैंडविड्थ, आदि।) यदि कोई उपयोगकर्ता किसी तरह से डेटा का अनुरोध करता है तो यह उचित नहीं है कि अन्य उपयोगकर्ताओं को भीड़ या ओवरबर्डेंस से बाहर निकलने वाले तरीके से डेटा का अनुरोध करता है। ERDDAP ।
        * एक बार जब एक उपयोगकर्ता जानता है कि कैसे 2 एक साथ अनुरोध करने के लिए, वे अक्सर 5, 10 या 20 एक साथ अनुरोध करने का कोई कारण नहीं देखते हैं, क्योंकि अतिरिक्त अनुरोध उन्हें कुछ भी नहीं खर्च करते हैं। यह असममित युद्ध की तरह है: यहां, आक्रामक हथियारों का जबरदस्त फायदा होता है (शून्य लागत) रक्षात्मक हथियारों पर (वास्तविक लागत के साथ एक परिमित स्थापना) ।
        * उन्हें इंगित करें कि अधिक से अधिक एक साथ अनुरोध करने के लिए रिटर्न को कम करना है; अतिरिक्त अनुरोध सिर्फ अन्य उपयोगकर्ता के अनुरोधों को अवरुद्ध करते हैं; वे उनके लिए भारी सुधार नहीं करते हैं।
        * उन्हें याद रखें कि अन्य उपयोगकर्ता हैं (दोनों आकस्मिक उपयोगकर्ताओं और अन्य उपयोगकर्ताओं को चलाने स्क्रिप्ट) इसलिए यह उनमें से किसी के लिए निष्पक्ष नहीं है ERDDAP संसाधन
        * इंगित करें कि तकनीकी दिग्गजों ने उपयोगकर्ताओं को वेब सेवाओं से अनंत संसाधनों की उम्मीद करने के लिए प्रेरित किया है। जबकि स्थापित करने के तरीके हैं [ग्रिड/क्लस्टर/फेडरेशन ऑफ ERDDAP s](/docs/server-admin/scaling) बनाना ERDDAP™ अधिक संसाधनों के साथ प्रणाली, अधिकांश ERDDAP™ प्रशासकों के पास ऐसी प्रणालियों को स्थापित करने के लिए धन या श्रमशक्ति नहीं है, और ऐसी प्रणाली अभी भी परिमित होगी। पर ERD उदाहरण के लिए, एक व्यक्ति है (मुझे) लेखन ERDDAP™ , दो प्रशासन ERDDAP s (मेरी मदद से बॉस) कई डेटा स्रोतों को प्रबंधित करना और प्रबंधित करना (हम हार्डवेयर के लिए भुगतान करने के लिए कभी-कभी अनुदान पर भरोसा करते हैं) । यह गूगल, फेसबुक, अमेज़न आदि 100 के इंजीनियरों के साथ नहीं है, और लाखों डॉलर राजस्व कभी बड़े सिस्टम में रीसायकल करने के लिए है। हम अभी नहीं चल सकते ERDDAP™ उदाहरण के लिए, अमेज़ॅन एडब्ल्यूएस, क्योंकि डेटा भंडारण लागत बड़ी है और डेटा प्रवेश शुल्क बड़े और परिवर्तनीय हैं, जबकि बाहरी सेवाओं के लिए हमारा बजट एक निश्चित $ 0 है।
        * उपयोगकर्ताओं के लिए मेरा अनुरोध है: गैर-समय-संवेदनशील अनुरोधों के लिए (जो अब तक सबसे आम मामला है) उनकी प्रणाली केवल एक समय में एक अनुरोध करना चाहिए। यदि अनुरोध समय संवेदनशील है (उदाहरण के लिए, एक वेब पेज पर एकाधिक .png, एक के लिए कई टाइलें WMS ग्राहक, आदि) , तो शायद 4 एक साथ अनुरोध अधिकतम होना चाहिए (केवल थोड़े समय के लिए) ।
        * यदि आप उपयोगकर्ता को स्थिति की व्याख्या करते हैं, तो अधिकांश उपयोगकर्ता आवश्यक परिवर्तन करने के लिए समझेंगे और तैयार होंगे ताकि आप ब्लैकलिस्ट से अपने आईपी पते को हटा सकें।
             
    * एक उपयोगकर्ता को ब्लैकलिस्ट करने के लिए, आईपी पते की अल्पसंख्यक सूची में अपना संख्यात्मक आईपी पता जोड़ें&lt;अपने अनुरोध में ब्लैकलिस्ट&gt; datasets.xml फ़ाइल परेशानी उपयोगकर्ता के आईपी पते को खोजने के लिए, में देखें ERDDAP™   *बड़ाParentDirectory* /logs/log.txt फ़ाइल ( *बड़ाParentDirectory* में निर्दिष्ट है [साइटमैप](/docs/server-admin/deploy-install#setupxml) ) यह देखने के लिए कि क्या यह मामला है और उस उपयोगकर्ता के आईपी पते को ढूंढना है। प्रत्येक अनुरोध के लिए आईपी पते को "&#123;&#123;&#123;&#123;&#123;#" के साथ शुरू होने वाली रेखाओं पर सूचीबद्ध किया गया है और उदाहरण के लिए, 4 संख्याओं को अवधियों से अलग किया गया है। "ERROR" के लिए खोज करने से आपको अमान्य अनुरोध जैसे समस्याओं को खोजने में मदद मिलेगी।
    * आप आईपी पते में अंतिम संख्या को भी बदल सकते हैं\\*(उदाहरण के लिए, 202.109.200)।\\*) आईपी पते, 0-255 की एक श्रृंखला को अवरुद्ध करने के लिए।
    * आप आईपी पते में अंतिम 2 संख्याओं को भी बदल सकते हैं\\*।\\*  (उदाहरण के लिए, 121.204।\\*।\\*) आईपी पते की एक विस्तृत श्रृंखला को अवरुद्ध करने के लिए, 0-255.0-255।
    * उदाहरण के लिए,
    ```
        <requestBlacklist>98.76.54.321, 202.109.200.\\*, 121.204.\\*.\\*</requestBlacklist>
    ```
    * आपको पुनरारंभ करने की आवश्यकता नहीं है ERDDAP™ परिवर्तन के लिए&lt;ब्लैकलिस्ट&gt; का अनुरोध करने के लिए। परिवर्तन अगली बार पता लगाया जाएगा ERDDAP™ अगर किसी डेटासेट को फिर से लोड करने की आवश्यकता है, तो चेक करें। या, आप प्रक्रिया को गति दे सकते हैं [सेट ध्वज यूआरएल](/docs/server-admin/additional-information#set-dataset-flag) किसी भी डेटासेट के लिए।
    * आपका ERDDAP™ दैनिक रिपोर्ट में सबसे सक्रिय अनुमति और अवरुद्ध अनुरोधकर्ता की सूची/tally शामिल है।
    * यदि आप यह जानना चाहते हैं कि डोमेन / संस्था एक संख्यात्मक आईपी पते से संबंधित है, तो आप एक मुफ्त, रिवर्स DNS वेब सेवा जैसे कि उपयोग कर सकते हैं। [https://network-tools.com/](https://network-tools.com/) ।
    * जब कुछ उपयोगकर्ताओं को उच्च स्तर पर ब्लॉक करना पड़ता है, उदाहरण के लिए, दुर्भावनापूर्ण उपयोगकर्ता। उदाहरण के लिए, आप अपने सर्वर पर सब कुछ करने के लिए अपनी पहुँच को अवरुद्ध कर सकते हैं, न केवल ERDDAP । लिनक्स पर, एक ऐसी विधि का उपयोग करना है [आईपीटेबल](https://www.linode.com/docs/guides/control-network-traffic-with-iptables/) । उदाहरण के लिए, आप एक नियम जोड़ सकते हैं जो आदेश के साथ 198.51.100.0 से आने वाली सभी चीजों को अवरुद्ध करेगा
iptables -I INPUT -s 198.51.100.0 -j DROP
       
### &lt;धीमेडाउनट्रबलमिली एंड जीटी;{#slowdowntroublemillis} 
* [ ** &lt;धीमाडाउनट्रबलमिली&gt; ** ] (#slowdowntroublemillis) शायद ही कभी एक के भीतर OPTIONAL टैग का इस्तेमाल किया जाता है&lt;erddapDatasets टैग में datasets.xml जिसमें एक पूर्णांक शामिल है जो मिलीसेकेंड की संख्या निर्दिष्ट करता है (डिफ़ॉल्ट=1000) सभी असफल अनुरोधों का जवाब देते समय रोकें, उदाहरण के लिए, अज्ञात डेटासेट, ब्लैकलिस्ट पर बहुत बड़े, उपयोगकर्ता का अनुरोध करें। E.g.
    ```
    <slowDownTroubleMillis>2000</slowDownTroubleMillis>
    ```
यदि एक स्क्रिप्ट तुरंत दूसरे के बाद एक अनुरोध कर रही है, तो यह तेजी से दूसरे के बाद एक बुरा अनुरोध कर सकता है। इस सेटिंग के साथ, आप एक असफल स्क्रिप्ट को धीमा कर सकते हैं ताकि ERDDAP™ बुरा अनुरोध के साथ बाढ़ नहीं है। यदि कोई व्यक्ति बुरा अनुरोध करता है, तो वे इस देरी को भी नोटिस नहीं करेंगे। सिफारिश:
    
    * यदि परेशानी सेवा का एक वितरित डेनियल है (डीडीओएस) 100+ हमलावरों से हमला, इसे एक छोटी संख्या में सेट करें (100?) । उन्हें बहुत लंबे समय तक चलने के लिए बहुत सारे सक्रिय धागे की ओर जाता है।
    * यदि समस्या 1-10 स्रोतों से है, तो इसे 1000 ms तक सेट करें। (डिफ़ॉल्ट) लेकिन एक बड़ी संख्या (10000) भी उचित है। यह उन्हें धीमा कर देता है ताकि वे कम नेटवर्क संसाधनों को बर्बाद कर सकें। इसके अलावा, 1000 एमएस या तो मानव उपयोगकर्ताओं को परेशान नहीं करेगा जो खराब अनुरोध करते हैं।
    
इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) ।
     
### &lt;सदस्यताईमेलब्लैकलिस्ट&gt;{#subscriptionemailblacklist} 
* [ ** &lt;सदस्यता ईमेल ** ] (#subscriptionemailblacklist) शायद ही कभी एक के भीतर OPTIONAL टैग का इस्तेमाल किया जाता है&lt;erddapDatasets टैग में datasets.xml जिसमें ईमेल पते की अल्पसंख्यक सूची होती है जो तुरंत ब्लैकलिस्ट होती है [सदस्यता प्रणाली](https://coastwatch.pfeg.noaa.gov/erddap/subscriptions) उदाहरण के लिए
    ```
    <subscriptionEmailBlacklist>bob@badguy.com, john@badguy.com</subscriptionEmailBlacklist>  
    ```
यह एक असंवेदनशील प्रणाली है। यदि इस सूची में एक ईमेल पता जोड़ा जाता है, तो यदि उस ईमेल पते की सदस्यता है, तो सदस्यता रद्द कर दी जाएगी। यदि सूची में एक ईमेल पता सदस्यता लेने की कोशिश करता है, तो अनुरोध को मना कर दिया जाएगा। इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) ।
     
### मानक पाठ{#standard-text} 
*    [ **मानक पाठ** ](#standard-text) -- कई वैकल्पिक टैग हैं (शायद ही कभी इस्तेमाल किया जाता है) भीतर&lt;erddapDatasets टैग में datasets.xml पाठ निर्दिष्ट करने के लिए जो विभिन्न स्थानों में दिखाई देता है ERDDAP । यदि आप डिफ़ॉल्ट टेक्स्ट को बदलना चाहते हैं, तो उसी नाम के टैग से मौजूदा मान को कॉपी करें।
     *tomcat* Webapps/erddap/WEB-INF/classs/gov/noaa/pfel/erddap/util.mesage.xml में datasets.xml फिर सामग्री को संशोधित करें। इनका लाभ datasets.xml यह है कि आप किसी भी समय नए मूल्यों को निर्दिष्ट कर सकते हैं, यहां तक कि जब भी ERDDAP™ चल रहा है। इन टैगों के मूल्यों में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) । टैग नाम उनके उद्देश्य का वर्णन करते हैं, लेकिन संदेशों में डिफ़ॉल्ट सामग्री देखते हैं।
    
    *   &lt;मानक लाइसेंस&gt;
    *   &lt;मानकसंपर्क&gt;
    *   &lt;StandardDataLicenses
    *   &lt;मानक अस्वीकरण
    *   &lt;StandardDisclaimerOfExternalLinks&gt;
    *   &lt;Standard GeneralDisclaimer
    *   &lt;मानक गोपनीयता नीति&gt;
    *   &lt;startHeadHtml5&gt;
    *   &lt;startBodyHtml5&gt; अपने वेब पेज में हर वेब पेज के शीर्ष की उपस्थिति को अनुकूलित करने के लिए बदलने के लिए एक अच्छा टैग है। ERDDAP । विशेष रूप से, आप इसका उपयोग आसानी से अस्थायी संदेश जोड़ने के लिए कर सकते हैं ERDDAP™ होम पेज (उदाहरण के लिए, "नए JPL MUR SST v4.1 डेटासेट की जाँच करें ..." या "इस" ERDDAP™ रखरखाव 2019-05-08T17:00:00 PDT के माध्यम से 2019-05-08T20:00:00 PDT के लिए ऑफ़लाइन होगा।) । इस टैग को डालने का एक quirk datasets.xml जब आप पुनरारंभ करते हैं ERDDAP सबसे पहले अनुरोध ERDDAP™ डिफ़ॉल्ट प्रारंभ वापस आ जाएगा BodyHtml5 HTML, लेकिन बाद में प्रत्येक अनुरोध में निर्दिष्ट startBodyHtml5 HTML का उपयोग करेगा। datasets.xml ।
    *   &lt;दशमलव Html&gt; आपके विवरण को अनुकूलित करने के लिए बदलने के लिए एक अच्छा टैग है ERDDAP । ध्यान दें कि आप आसानी से इसे घर पृष्ठ पर अस्थायी संदेश जोड़ने के लिए बदल सकते हैं (उदाहरण के लिए, "यह ERDDAP™ रखरखाव 2019-05-08T17:00:00 PDT के माध्यम से 2019-05-08T20:00:00 PDT के लिए ऑफ़लाइन होगा।) ।
    *   &lt;endBodyHtml5&gt;
    
      
पहले ERDDAP™ v2.00, इन्हें सेटअप.xml में निर्दिष्ट किया गया था, जिसे अभी भी अनुमति दी गई है लेकिन हतोत्साहित किया गया है।
     
### &lt;असामान्य गतिविधि&gt;{#unusualactivity} 
* [ ** &lt;असामान्यसक्रियता&gt; ** ] (#unusualactive) शायद ही कभी एक के भीतर OPTIONAL टैग का इस्तेमाल किया जाता है&lt;erddapDatasets टैग में datasets.xml लोडडाटासेट के दो रनों के बीच अधिकतम अनुरोधों को निर्दिष्ट करने के लिए जिसे सामान्य माना जाता है (डिफ़ॉल्ट=10000) । यदि उस संख्या से अधिक है, तो ईमेल को ईमेल करने के लिए भेजा जाता है (सेटअप.xml में निर्दिष्ट के रूप में) । E.g.
    ```
    <unusualActivity>10000</unusualActivity>  
    ```
इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) । पहले ERDDAP™ v2.00, यह सेटअप.xml में निर्दिष्ट किया गया था, जो अभी भी अनुमति है लेकिन हतोत्साहित है।
     
### &lt;अद्यतनMaxEvents&gt;{#updatemaxevents} 
* [ ** &lt;अद्यतनMaxEvents&gt; ** ] (#updatemaxevents) शायद ही कभी एक के भीतर OPTIONAL टैग का इस्तेमाल किया जाता है&lt;erddapDatasets टैग में datasets.xml फ़ाइल परिवर्तन घटनाओं की अधिकतम संख्या निर्दिष्ट करने के लिए (डिफ़ॉल्ट=10) that will be handled by the [[]&lt;EveryNMillis (#updateeverynmillis) इसके बजाय डेटासेट को पुनः लोड करने के लिए स्विच करने से पहले सिस्टम। उदाहरण के लिए,
    ```
    <updateMaxEvents>10</updateMaxEvents>  
    ```
अद्यतनEveryNMillis प्रणाली उपयोगकर्ता के अनुरोध को संसाधित करने से पहले बहुत जल्दी चलाने का इरादा है। यदि फ़ाइल परिवर्तन की कई घटनाएं हैं, तो संभवतः यह जल्दी से नहीं चल सकता है, इसलिए इसके बजाय डेटासेट को पुनः लोड करने के लिए कॉल करता है। अगर आपका ERDDAP™ जब बड़ी संख्या में डेटा फ़ाइलों में परिवर्तन होता है, तब भी डेटासेट के साथ सौदों को रखा जाना चाहिए। (100?) ।

### &lt;उपयोगकर्ता&gt;{#user} 
* [ ** &lt;उपयोगकर्ता ** ] (#user) एक के भीतर एक OPTIONAL टैग है&lt;erddapDatasets टैग में datasets.xml जो उपयोगकर्ता के उपयोगकर्ता नाम, पासवर्ड की पहचान करता है (यदि प्रमाणीकरण = कस्टम) , और भूमिकाएं (अल्पसंख्यक सूची) । उपयोगकर्ता नाम और पासवर्ड के उपयोग के मूल्य के आधार पर थोड़ा भिन्न होता है [&lt;प्रमाणीकरण&gt; (/docs/server-admin/additional-information#authentication) अपने ERDDAP 's सेटअप.xml फ़ाइल.
    * यह हिस्सा है ERDDAP ' [सुरक्षा प्रणाली](/docs/server-admin/additional-information#security) कुछ उपयोगकर्ताओं को कुछ डेटासेट तक पहुंच को प्रतिबंधित करने के लिए।
    * एक अलग बनाएं&lt;प्रत्येक उपयोगकर्ता के लिए उपयोगकर्ता&gt; टैग। वैकल्पिक रूप से, यदि प्रमाणीकरण = oauth2, तो आप दो सेट अप कर सकते हैं&lt;उपयोगकर्ता प्रत्येक उपयोगकर्ता के लिए टैग: एक के लिए जब उपयोगकर्ता लॉग इन करता है गूगल, एक के लिए जब उपयोगकर्ता Orcid के माध्यम से प्रवेश करता है, संभवतः उसी भूमिकाओं के साथ।
    * यदि नहीं है&lt;एक ग्राहक के लिए उपयोगकर्ता&gt; टैग, s / वह केवल सार्वजनिक डेटासेट तक पहुंचने में सक्षम होगा, अर्थात, डेटासेट जिसमें कोई नहीं है [&lt;सुलभ (#accessibleto) टैग
    * उपयोगकर्ता नाम
प्रमाणीकरण = कस्टम के लिए, उपयोगकर्ता नाम आमतौर पर अक्षर, अंक, अंडरस्कोर और अवधि का संयोजन होता है।
प्रमाणीकरण के लिए = Email, उपयोगकर्ता नाम उपयोगकर्ता का ईमेल पता है। यह कोई ईमेल पता हो सकता है।
प्रमाणीकरण = Google के लिए, उपयोगकर्ता नाम उपयोगकर्ता का पूरा Google ईमेल पता है। इसमें Google प्रबंधित खाते जैसे शामिल हैं @noaa.gov खाता
प्रमाणीकरण = Orcid के लिए, उपयोगकर्ता नाम उपयोगकर्ता का Orcid खाता संख्या है (डैश के साथ) ।
प्रमाणीकरण = oauth2 के लिए, उपयोगकर्ता का नाम उपयोगकर्ता का पूरा Google ईमेल पता या उपयोगकर्ता का Orcid खाता संख्या है। (डैश के साथ) ।
    * पासवर्ड
प्रमाणीकरण के लिए = Email, Google, orcid, या oauth2, एक पासवर्ड विशेषता निर्दिष्ट नहीं है।
प्रमाणीकरण = कस्टम के लिए, आपको प्रत्येक उपयोगकर्ता के लिए एक पासवर्ड विशेषता निर्दिष्ट करनी होगी।
        * उपयोगकर्ता प्रवेश करने वाले पासवर्ड केस संवेदनशील होते हैं और उनके पास 8 या अधिक अक्षर होते हैं ताकि वे क्रैक करना कठिन हो। आजकल, यहां तक कि 8 अक्षरों को एडब्ल्यूएस पर कंप्यूटर के क्लस्टर का उपयोग करके ब्रूट फोर्स द्वारा जल्दी और सस्ते में क्रैक किया जा सकता है। ERDDAP™ जब उपयोगकर्ता लॉग इन करने की कोशिश करता है तो केवल 8-character को न्यूनतम रूप से लागू करता है (नहीं जब उपयोगकर्ता लॉग इन करने की कोशिश करता है)&lt;उपयोगकर्ता&gt; टैग संसाधित किया जा रहा है, क्योंकि यह कोड केवल पासवर्ड के हैश पाचन को देखता है, न कि सादे पाठ पासवर्ड।
        * सेटअप.xml&lt;पासवर्ड एन्कोडिंग&gt; यह निर्धारित करता है कि पासवर्ड कैसे संग्रहीत किए जाते हैं&lt;उपयोगकर्ता टैग में datasets.xml । बढ़ती सुरक्षा के लिए विकल्प हैं:
            *    [MD5](https://en.wikipedia.org/wiki/MD5)   (इसका उपयोग न करें&#33;) - पासवर्ड विशेषता के लिए, उपयोगकर्ता के पासवर्ड के MD5 हैश को निर्दिष्ट करें।
            * UEPMD5 (इसका उपयोग न करें&#33;) - पासवर्ड विशेषता के लिए, MD5 हैश पाचन निर्दिष्ट करें *उपयोगकर्ता नाम* : ERDDAP : *पासवर्ड* । उपयोगकर्ता नाम और " ERDDAP " [नमक](https://en.wikipedia.org/wiki/Salt_(cryptography) ) हैश वैल्यू, इसे डीकोड करने के लिए और अधिक कठिन बनाती है।
            *    [SHA256](https://en.wikipedia.org/wiki/SHA-2)   (अनुशंसित नहीं) - पासवर्ड विशेषता के लिए, उपयोगकर्ता के पासवर्ड के SHA-256 हैश पाचन निर्दिष्ट करें।
            * UEPSHA256 (डिफ़ॉल्ट, अनुशंसित पासवर्ड एन्कोडिंग। लेकिन बेहतर: गूगल, ऑर्किड या oauth2 प्रमाणीकरण विकल्पों का उपयोग करें।) - पासवर्ड विशेषता के लिए, SHA-256 हैश पाचन निर्दिष्ट करें *उपयोगकर्ता नाम* : ERDDAP : *पासवर्ड* । उपयोगकर्ता नाम और " ERDDAP " हैश मान को नमक देने के लिए उपयोग किया जाता है, जिससे इसे डीकोड करना मुश्किल हो जाता है।
        * विंडोज पर, आप MD5 प्रोग्राम को डाउनलोड करके MD5 पासवर्ड पाचन मान उत्पन्न कर सकते हैं (जैसे [MD5](https://www.fourmilab.ch/md5/) ) उपयोग (उदाहरण के लिए) :
md5 -djsmith: ERDDAP : *वास्तविक पासवर्ड* 
        * लिनक्स/यूनिक्स पर, आप अंतर्निहित md5sum प्रोग्राम का उपयोग करके MD5 पाचन मान उत्पन्न कर सकते हैं (उदाहरण के लिए) :
Echo -n "jsmith: ERDDAP : *वास्तविक पासवर्ड* " | md5sum
        * संग्रहीत सादे पाठ पासवर्ड मामले संवेदनशील हैं। MD5 और UEPMD5 पासवर्ड के संग्रहीत रूप संवेदनशील नहीं हैं।
        * उदाहरण के लिए (UEPMD5) , अगर उपयोगकर्ता का नाम = "jsmith" और पासवर्ड = "mypassword", तो पासवर्ड&lt;उपयोगकर्ता&gt; टैग है:
```
            <user username="jsmith"  
            password="57AB7ACCEB545E0BEB46C4C75CEC3C30"  
            roles="JASmith, JASmithGroup" />  
```
जहां संग्रहीत पासवर्ड के साथ उत्पन्न किया गया था
md5 -djsmith: ERDDAP :mypassword
        * भूमिकाओं की एक तुलनात्मक सूची है जिसके लिए उपयोगकर्ता अधिकृत है। कोई&lt;Dataset&gt; एक हो सकता है [&lt;सुलभ (#accessibleto) टैग जो भूमिकाओं को सूचीबद्ध करता है जिन्हें उस डेटासेट तक पहुंचने की अनुमति है। किसी दिए गए उपयोगकर्ता और दिए गए डेटासेट के लिए, यदि उपयोगकर्ता की भूमिकाओं की सूची में भूमिकाओं में से एक डेटासेट की सूची में भूमिकाओं में से एक से मेल खाता है।&lt;सुलभ To&gt; भूमिकाओं, फिर उपयोगकर्ता उस डेटासेट तक पहुंचने के लिए अधिकृत है।
            
प्रत्येक उपयोगकर्ता जो लॉग इन करता है उसे स्वचालित रूप से भूमिका दी जाती है \\[ लॉग इन में \\] क्या है?&lt;उपयोगकर्ता&gt; उनके लिए टैग datasets.xml नहीं तो अगर कोई डेटासेट दिया गया है
```
            <accessibleTo>\\[anyoneLoggedIn\\]</accessibleTo>  
```
तब कोई भी उपयोगकर्ता जो लॉग इन होता है उसे उस डेटासेट तक पहुंचने के लिए अधिकृत किया जाएगा, भले ही कोई डेटासेट न हो&lt;उपयोगकर्ता&gt; उनके लिए टैग datasets.xml ।
            
    * इस टैग के मूल्य में कोई बदलाव अगली बार प्रभावी होगा ERDDAP™ पढ़ना datasets.xml डेटासेट के जवाब में, [झंडा](/docs/server-admin/additional-information#flag) ।
         
### &lt;पथRegex&gt;{#pathregex} 
* [ ** &lt;पथRegex&gt; ** ] (#pathregex) आपको एक नियमित अभिव्यक्ति निर्दिष्ट करने देता है जो पथ को सीमित करता है (जो उपनिर्देशिका) डेटासेट में शामिल किया जाएगा। डिफ़ॉल्ट है। यह शायद ही कभी इस्तेमाल किया जाता है, शायद ही कभी जरूरत है, OPTIONAL टैग के लिए EDDGrid fromFiles datasets, EDDTableFromFiles datasets, और कुछ अन्य डेटासेट प्रकार। हालांकि, जब आपको इसकी आवश्यकता है, तो आपको वास्तव में इसकी आवश्यकता है।
    
इस काम को बनाने के लिए, आपको नियमित अभिव्यक्तियों के साथ वास्तव में अच्छा होना चाहिए। इसे देखें [रेगेक्स प्रलेखन](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html) और [Regex ट्यूटोरियल](https://www.vogella.com/tutorials/JavaRegularExpressions/article.html) । विशेष रूप से, आपको कैप्चर समूह के बारे में जानने की आवश्यकता है (Parentheses) , और "or" प्रतीक " | "।
साथ में, ये आपको कई विकल्प निर्दिष्ट करते हैं, उदाहरण के लिए, (विकल्प1 | विकल्प2 | विकल्प3) ।
इसके अलावा, कोई भी विकल्प कुछ भी नहीं हो सकता है, उदाहरण के लिए, ( | विकल्प2 | विकल्प3) ।
इसके अलावा, आपको यह जानने की आवश्यकता है कि समूह को घोंसला किया जा सकता है, अर्थात्, किसी कैप्चर समूह में कोई विकल्प किसी अन्य कैप्चर समूह को शामिल कर सकता है, उदाहरण के लिए, ( | विकल्प2 ( | विकल्प2 b | विकल्प2c)  | विकल्प3) जो कहता है कि Option2 को कुछ भी नहीं, या Option2b, या Option2c द्वारा पालन किया जा सकता है।
PathRegexes के लिए, प्रत्येक विकल्प एक फ़ोल्डर नाम होगा जिसके बाद एक /, उदाहरण के लिए, बार / होगा।
    
पथ का मुश्किल हिस्सा है: जब ERDDAP™ Recursively निर्देशिका के पेड़ में उतरता है, पथRegex को डेटा के साथ निर्देशिकाओं के रास्ते में आने वाले सभी मार्गों को स्वीकार करना होगा। Regex के साथ घोंसले पर कब्जा समूह इस से निपटने का एक अच्छा तरीका है।
    
उदाहरण:
मान लीजिए कि हमारे पास निम्नलिखित निर्देशिका संरचना है:
    ```
    /foo/bar/D0001/a/\\*.nc  
    /foo/bar/D0001/b/\\*.nc  
    /foo/bar/D0002/a/\\*.nc  
    /foo/bar/D0002/b/\\*.nc  
    ...  
    /foo/bar/E0001/a/\\*.nc  
    ...  
    ```
और निर्दिष्ट फ़ाइलDirectory /foo/bar/ है, और हम सिर्फ चाहते हैं .nc D में फ़ाइलें \\[ 0-9 \\] &#123;4&#125;/a/ subdirectories.
समाधान करने के लिए /foo/bar/ ( | D \\[ 0-9 \\] &#123;4&#125;/ ( | A) )   
कहते हैं:
पथ / foo/bar/ के साथ शुरू होना चाहिए
इसके बाद कुछ भी नहीं हो सकता \\[ 0-9 \\] &#123;4&#125;/
इसके बाद कुछ भी नहीं हो सकता
    
हाँ, PathRegex का निर्माण करने के लिए अविश्वसनीय रूप से मुश्किल हो सकता है। यदि आप अटक जाते हैं, तो कंप्यूटर प्रोग्रामर से पूछें (वास्तविक दुनिया में सबसे करीबी चीज एक विज़ार्ड स्पॉटिंग incantations के लिए?) या क्रिस को एक ईमेल भेजें। जॉन at noaa.gov.
    
### &lt;Dataset&gt;{#dataset} 
* [ ** &lt;डेटासेट&gt; ** ] (#dataset) एक वैकल्पिक है (लेकिन हमेशा इस्तेमाल किया) एक के भीतर टैग&lt;erddapDatasets टैग में datasets.xml (यदि आप सभी जानकारी को शामिल करते हैं)&lt;डेटासेट&gt; और&lt;/dataset&gt;) पूरी तरह से एक डेटासेट का वर्णन करता है। उदाहरण के लिए,
    ```
    <dataset type="EDDGridFromDap" datasetID="erdPHssta8day" active="true"> ... </dataset>  
    ```
वहाँ अपने डेटासेट टैग के किसी भी नंबर हो सकता है datasets.xml फ़ाइल
तीन विशेषताएँ MAY एक के भीतर दिखाई देते हैं&lt;डेटासेट&gt; टैग:
     
    *    **टाइप *a प्रकार* "** एक के भीतर एक REQUIRED विशेषता है&lt;Dataset&gt; में टैग datasets.xml जो डेटासेट प्रकार की पहचान करता है (उदाहरण के लिए, क्या यह एक है EDDGrid /gridded या EDDTable/tabular डेटासेट) और डेटा का स्रोत (उदाहरण के लिए, एक डेटाबेस, फाइलें, या रिमोट OPeNDAP सर्वर) । देखें [ **डेटासेट प्रकार की सूची** ](#list-of-types-datasets) ।
         
#### डेटासेट आईडी{#datasetid} 
*    [ ** datasetID (a) *ADatasetID* "** ](#datasetid) एक के भीतर एक REQUIRED विशेषता है&lt;डेटासेट&gt; टैग जो एक छोटा (आमतौर पर) असाइन करता है&lt;15 वर्ण), अद्वितीय, एक डेटासेट के नाम की पहचान।
    * The The most of the datasetID MUST एक अक्षर है (A-Z, a-z) इसके बाद किसी भी संख्या में A-Z, A-Z, 0-9 और \\_ (लेकिन अगर सबसे अच्छा है)&lt;32 वर्ण कुल)।
    * डेटासेट आईडी केस सेंसिटिव हैं, लेकिन दो नहीं बनाते हैं datasetID केवल ऊपरी / निचले अक्षरों में भिन्न होता है। यह विंडोज कंप्यूटर पर समस्या पैदा करेगा (आपका और/या एक उपयोगकर्ता का कंप्यूटर) ।
    * सर्वश्रेष्ठ अभ्यास: हम अनुशंसा करते हैं [कैमल केस](https://en.wikipedia.org/wiki/CamelCase) ।
    * सर्वश्रेष्ठ अभ्यास: हम अनुशंसा करते हैं कि पहला भाग स्रोत संस्थान के नाम का संक्षिप्त या संक्षिप्तीकरण हो और दूसरा हिस्सा डेटासेट के नाम का संक्षिप्त नाम या संक्षिप्त नाम हो। जब संभव हो, तो हम एक ऐसा नाम बनाते हैं जो डेटासेट के लिए स्रोत के नाम को दर्शाता है। उदाहरण के लिए, हम इस्तेमाल किया datasetID ="erdph" sst a8day NOAA   NMFS   SWFSC पर्यावरण अनुसंधान प्रभाग ( ERD ) जिसे उपग्रह / पीएच / के स्रोत द्वारा नामित किया गया है sst 8 दिन।
    * यदि आप डेटासेट का नाम बदल रहे हैं, तो पुराने डेटासेट (पुराने नाम के साथ) अभी भी जीना होगा ERDDAP । यह एक "orphan" डेटासेट है, क्योंकि इसमें इसके लिए विनिर्देश datasets.xml अब चला गया है। इससे निपटना चाहिए:
        1. के लिए ERDDAP™ v2.19 और बाद में, आपको कुछ भी करने की आवश्यकता नहीं है। ERDDAP™ स्वचालित रूप से इन अनाथ डेटासेट को हटा देगा।
        2. के लिए ERDDAP™ v2.18 और इससे पहले, आपको अनाथ डेटासेट को हटाने के लिए कुछ करना होगा: एक सक्रिय बनाएं
```
                <dataset type="EDDTableFromNcFiles" datasetID="*theOldName*" active="false" />  
```
अगले प्रमुख भार के बाद डेटासेट पुराने डेटासेट निष्क्रिय होने के बाद आप उस टैग को हटा सकते हैं।
                 
#### सक्रिय{#active} 
*    [ **सक्रिय *बोरान* "** ](#active) एक के भीतर एक वैकल्पिक विशेषता है&lt;Dataset&gt; में टैग datasets.xml जो इंगित करता है कि डेटासेट सक्रिय है (में उपयोग के लिए पात्र ERDDAP ) नहीं
    * मान्य मान सही हैं (डिफ़ॉल्ट) और झूठी।
    * चूंकि डिफ़ॉल्ट सही है, इसलिए आपको इस विशेषता का उपयोग करने की आवश्यकता नहीं है जब तक आप अस्थायी रूप से या स्थायी रूप से इस डेटासेट को हटा नहीं सकते ERDDAP ।
    * यदि आप एक सक्रिय \true" डेटासेट को हटाते हैं datasets.xml डेटासेट अभी भी सक्रिय हो जाएगा ERDDAP™ लेकिन अपडेट नहीं किया जाएगा। ऐसा डेटासेट एक "अनाथ" होगा और इसे स्थिति के रूप में सूचीबद्ध किया जाएगा। एचटीएमएल वेब पेज डेटासेट की सूची के ठीक नीचे जो लोड करने में विफल रहा।
    * यदि आप सक्रिय स्थापित करते हैं ERDDAP™ अगली बार डेटासेट को निष्क्रिय करने के लिए यह डेटासेट अद्यतन करने की कोशिश करता है। जब आप ऐसा करते हैं, ERDDAP™ यह डाटासेट के बारे में संग्रहीत किसी भी जानकारी को नहीं फेंक सकता है और निश्चित रूप से वास्तविक डेटा के लिए कुछ भी नहीं करता है।
    * डेटासेट को दूर करने के लिए ERDDAP™ , देखें [फोर्स डेटासेट हटाने](/docs/server-admin/additional-information#removing-datasets) ।
         

 ** कई टैग बीच दिखाई दे सकते हैं&lt;डेटासेट&gt; और&lt;/dataset&gt; टैग। **   
इसमें कुछ बदलाव होते हैं जिनमें टैग किस प्रकार के डेटासेट द्वारा अनुमति दी जाती है। किसी विशिष्ट के लिए प्रलेखन देखें [डेटासेट का प्रकार](#list-of-types-datasets) विवरण के लिए।

#### &lt;सुलभ To&gt;{#accessibleto} 
* [ ** &lt;सुलभ To&gt; ** ] (#accessibleto) एक के भीतर एक वैकल्पिक टैग है&lt;डेटासेट&gt; टैग जो एक अल्पविराम-अलग सूची को निर्दिष्ट करता है [भूमिका](#user) जो इस डेटासेट तक पहुंच की अनुमति है। उदाहरण के लिए,
    ```
    <accessibleTo>RASmith, NEJones</accessibleTo>  
    ```
    * यह हिस्सा है ERDDAP ' [सुरक्षा प्रणाली](/docs/server-admin/additional-information#security) कुछ उपयोगकर्ताओं को कुछ डेटासेट तक पहुंच को प्रतिबंधित करने के लिए।
    * यदि यह टैग मौजूद नहीं है, तो सभी उपयोगकर्ता (भले ही वे लॉग इन न हों) इस डेटासेट तक पहुंच होगी।
    * यदि यह टैग मौजूद है, तो यह डेटासेट केवल लॉग-इन उपयोगकर्ताओं के लिए दिखाई देगा, जिनके पास निर्दिष्ट भूमिकाओं में से एक है। यह डेटासेट उन उपयोगकर्ताओं के लिए दिखाई नहीं देगा जो लॉग इन नहीं हैं।
    * प्रत्येक उपयोगकर्ता जो लॉग इन करता है उसे स्वचालित रूप से भूमिका दी जाती है \\[ लॉग इन में \\] क्या है?&lt;उपयोगकर्ता&gt; उनके लिए टैग datasets.xml नहीं तो अगर कोई डेटासेट दिया गया है
    ```
        <accessibleTo>\\[anyoneLoggedIn\\]</accessibleTo>  
    ```
तब कोई भी उपयोगकर्ता जो लॉग इन होता है उसे उस डेटासेट तक पहुंचने के लिए अधिकृत किया जाएगा, भले ही कोई डेटासेट न हो&lt;उपयोगकर्ता&gt; उनके लिए टैग datasets.xml ।
         
#### &lt;graphsAccessibleTo&gt;{#graphsaccessibleto} 
* [ ** &lt;graphsAccessibleTo ** ] (#graphsaccessibleto) एक के भीतर एक वैकल्पिक टैग है&lt;Dataset&gt; में टैग datasets.xml जो यह निर्धारित करता है कि डेटासेट के लिए ग्राफिक्स और मेटाडाटा जनता के लिए उपलब्ध हैं। यह डाटासेट के आंशिक रूप से ओवरराइड करने का एक तरीका प्रदान करता है [&lt;सुलभ (#accessibleto) सेटिंग अनुमत मान हैं:
    * ऑटो यह मान (या किसी की अनुपस्थिति)&lt;graphsAccessibleTo&gt; डेटासेट के लिए टैग) डेटासेट से ग्राफ़ और मेटाडाटा तक पहुंच बनाता है डेटासेट की नकल करता है&lt;सुलभ to&gt; सेटिंग
इसलिए यदि डेटासेट निजी है, तो इसका ग्राफ और मेटाडाटा निजी होगा।
और अगर डेटासेट सार्वजनिक है, तो इसका ग्राफ और मेटाडाटा सार्वजनिक होगा।
    * सार्वजनिक -- यह सेटिंग किसी के लिए डेटासेट के ग्राफ़ और मेटाडाटा को सुलभ बनाती है, यहां तक कि उन उपयोगकर्ताओं को जो लॉग इन नहीं हैं, भले ही डेटासेट अन्यथा निजी हो क्योंकि इसमें कोई डेटासेट हो।&lt;सुलभ To&gt; टैग।
         
#### &lt;सुलभ ViaFiles&gt;{#accessibleviafiles} 
* [ ** &lt;सुलभ ViaFiles&gt; ** ] (#accessibleviafiles) एक के भीतर एक वैकल्पिक टैग है&lt;Dataset&gt; में टैग datasets.xml के लिए [ EDDGrid समग्र आयाम](#eddgridaggregateexistingdimension) , [ EDDGrid कॉपी](#eddgridcopy) , [ EDDGrid FromEDDTable](#eddgridfromeddtable) , [ EDDGrid सेंध](#eddfromerddap) , [ EDDGrid Etopo](#eddgridfrometopo) , [ EDDGrid सेफिल](#eddgridfromfiles)   (सभी वर्गों सहित) , [ EDDGrid साइडबायसाइड](#eddgridsidebyside) , [EDDTableCopy](#eddtablecopy)   [EDDTableFromErddap](#eddfromerddap) , [EDDTableFrom EDDGrid ](#eddtablefromeddgrid) , और [EDDTableFromFiles](#eddtablefromfiles)   (सभी वर्गों सहित) डेटासेट यह सच या झूठ का मान हो सकता है। उदाहरण के लिए,
    ```
    <accessibleViaFiles>true</accessibleViaFiles>  
    ```
यदि मूल्य सही है, ERDDAP™ ऐसा करने से उपयोगकर्ता डेटासेट के स्रोत डेटा फ़ाइलों को ब्राउज़ और डाउनलोड कर सकते हैं ERDDAP ' [ "files" प्रणाली](https://coastwatch.pfeg.noaa.gov/erddap/files/) । देखें "files" प्रणाली [दस्तावेज़ीकरण](https://coastwatch.pfeg.noaa.gov/erddap/files/documentation.html) अधिक जानकारी के लिए।
    
डिफ़ॉल्ट मान&lt;सुलभ ViaFiles&gt; से आता है&lt;डिफ़ॉल्टAccessibleViaFiles&gt; में [साइटमैप](/docs/server-admin/deploy-install#setupxml) । यह झूठी का एक डिफ़ॉल्ट मान है, लेकिन हम अनुशंसा करते हैं कि आप उस टैग को अपने सेटअप.xml में सही मूल्य के साथ जोड़ दें।
    
सिफारिश -- हम अनुशंसा करते हैं कि सभी प्रासंगिक डेटासेट को सेटिंग द्वारा फ़ाइलों सिस्टम के माध्यम से सुलभ बनाया जा सके।&lt;डिफ़ॉल्टAccessibleViaFiles&gt; सेटअप.xml में सच करने के लिए क्योंकि उपयोगकर्ताओं का एक समूह है जिसके लिए यह डेटा प्राप्त करने का पसंदीदा तरीका है। अन्य कारणों में, "files" सिस्टम उपयोगकर्ताओं को यह देखने के लिए आसान बनाता है कि कौन से फाइलें उपलब्ध हैं और जब वे बदल जाते हैं, तो इस प्रकार उपयोगकर्ता को संपूर्ण डेटासेट की अपनी खुद की प्रति बनाए रखने के लिए यह आसान बना देता है। यदि आप आम तौर पर डेटासेट को फ़ाइलों के माध्यम से सुलभ बनाना चाहते हैं, तो सेट करें&lt;डिफ़ॉल्टAccessibleViaFiles&gt; झूठी करने के लिए। किसी भी मामले में, बस उपयोग करें&lt;सुलभ ViaFiles&gt; कुछ डेटासेट के लिए जो सामान्य नीति के अपवाद हैं, द्वारा निर्धारित&lt;डिफ़ॉल्टAccessibleViaFiles&gt; (उदाहरण के लिए, जब डेटासेट का उपयोग करता है [ .nc एमएल](#ncml-files) जो वास्तव में उपयोगकर्ताओं के लिए उपयोगी नहीं हैं) ।
     
#### &lt;सुलभ वाया WMS & gt;{#accessibleviawms} 
* [ ** &lt;सुलभ वाया WMS &gt; ** ] (#accessibleviawms) एक के भीतर एक वैकल्पिक टैग है&lt;Dataset&gt; में टैग datasets.xml सभी के लिए [ EDDGrid ](#eddgrid) उपवर्ग यह सच का मान हो सकता है (डिफ़ॉल्ट) या झूठा। उदाहरण के लिए,
    ```
    <accessibleViaWMS>true</accessibleViaWMS>  
    ```
यदि मान गलत है, ERDDAP ' WMS सर्वर इस डेटासेट के लिए उपलब्ध नहीं होगा। यह आमतौर पर उन डेटासेटों के लिए उपयोग किया जाता है जिनमें 180 से अधिक लंबे समय तक मान होते हैं। (जो तकनीकी रूप से अमान्य है WMS सेवाएं) , और जिसके लिए आप पूरी तरह से रेंज -180 से 180 तक की दूरी पर डेटासेट के एक संस्करण की पेशकश कर रहे हैं [ EDDGrid LonPM180](#eddgridlonpm180) ।
यदि मूल्य सही है, ERDDAP™ के माध्यम से उपलब्ध डेटासेट बनाने की कोशिश करेंगे ERDDAP ' WMS सर्वर लेकिन अगर डेटासेट के लिए पूरी तरह से अनुपयुक्त है WMS   (उदाहरण के लिए, कोई लम्बाई या अक्षांश डेटा नहीं है) तब डेटासेट के माध्यम से उपलब्ध नहीं होगा ERDDAP ' WMS सर्वर, इस सेटिंग की परवाह किए बिना।
     
#### &lt;जोड़ें चर कहाँ&gt;{#addvariableswhere} 
* [&lt;AddVariablesWhere&gt; (#addvariableswhere) भीतर एक वैकल्पिक टैग है&lt;सभी EDDTable डेटासेट के लिए डेटासेट&gt; टैग।
    
किसी भी EDDTable Dataset के लिए अनुरोधों को शामिल किया जा सकता है &add चर कहाँ (" *विशेषता नाम* "," *विशेषता मूल्य* ") कौन कहता है ERDDAP™ डेटासेट में सभी चर जोड़ने के लिए जहां *विशेषताName=attributeValue* अनुरोधित चर की सूची के लिए। उदाहरण के लिए, यदि कोई उपयोगकर्ता जोड़ता है और खाता है चर कहाँ (" ioos\\_category "Wind") एक क्वेरी के लिए, ERDDAP डेटासेट में सभी चर जोड़े जाएंगे जिनके पास एक है ioos\\_category =Wind विशेषता अनुरोध चर की सूची के लिए (उदाहरण के लिए, विंडस्पीड, विंडडायरेक्शन, विंडगस्टस्पीड) । *विशेषता नाम* और *विशेषता मूल्य* मामले-संवेदनशील होते हैं।
    
में datasets.xml यदि किसी डेटासेट के लिए dataset.xml का हिस्सा है, तो डेटासेट का हिस्सा है।
    ```
    <addVariablesWhere>*attributeNamesCSV*<addVariablesWhere>  
    ```
उदाहरण के लिए,
    ```
    <addVariablesWhere>ioos\\_category,units<addVariablesWhere>  
    ```
डाटा एक्सेस फॉर्म (Web page) डेटासेट के लिए एक विजेट शामिल होगा (प्रत्येक विशेषता के लिएName अल्पविराम-अलग सूची में) वेरिएबल्स की सूची के ठीक नीचे जो उपयोगकर्ताओं को एक विशेषता मान निर्दिष्ट करने देता है। यदि उपयोगकर्ता एक या एक से अधिक विशेषता नामों के लिए एक विशेषता मान का चयन करता है, तो उन्हें &add के माध्यम से अनुरोध पर जोड़ा जाएगा चर कहाँ (" *विशेषता नाम* "," *विशेषता मूल्य* ") । इस प्रकार, इस टैग में datasets.xml आपको विशेषता नामों की सूची निर्दिष्ट करने देता है जो उस डेटासेट के लिए डेटा एक्सेस फॉर्म पर दिखाई देगा और उपयोगकर्ताओं को जोड़ने के लिए आसान बनाता है जहां अनुरोध के लिए कार्य करता है। The The most of the *विशेषताNamesCSV* सूची केस-संवेदनशील है।
    
#### &lt;ऊंचाई मीटरPerSourceUnit&gt;{#altitudemeterspersourceunit} 
* [ ** &lt;ऊंचाई मीटरPerSourceUnit&gt; ** ] (#altitudemeterspersourceunit) भीतर एक वैकल्पिक टैग है&lt;डेटासेट में डेटासेट&gt; टैग। EDDTableFrom के लिए xxml SOS डेटासेट (केवल&#33;) यह एक संख्या को निर्दिष्ट करता है जो स्रोत ऊंचाई या गहराई मूल्यों द्वारा उन्हें ऊंचाई मूल्यों में परिवर्तित करने के लिए गुणा किया जाता है (समुद्र तल से ऊपर मीटर) । उदाहरण के लिए,
    ```
    <altitudeMetersPerSourceUnit>-1</altitudeMetersPerSourceUnit>  
    ```
यह टैग MUST का इस्तेमाल किया जा सकता है यदि डेटासेट का ऊर्ध्वाधर अक्ष मान मीटर, सकारात्मक = अप नहीं हैं। अन्यथा, यह वैकल्पिक है, क्योंकि डिफ़ॉल्ट मान 1 है। उदाहरण के लिए,
    * यदि स्रोत पहले से ही समुद्र तल के ऊपर मीटर में मापा जाता है, तो 1 का उपयोग करें (या इस टैग का उपयोग नहीं करते, क्योंकि 1 डिफ़ॉल्ट मान है) ।
    * यदि स्रोत समुद्र तल से नीचे मीटर में मापा जाता है, तो -1 का उपयोग करें।
    ```
        <altitudeMetersPerSourceUnit>-1</altitudeMetersPerSourceUnit>
    ```
    * यदि स्रोत समुद्र तल से ऊपर किमी में मापा जाता है, तो 0.001 का उपयोग करें।
         
#### &lt;डिफ़ॉल्टDataQuery&gt;{#defaultdataquery} 
* [ ** &lt;डिफ़ॉल्टDataQuery&gt; ** ] (#defaultdataquery) एक के भीतर एक वैकल्पिक टैग है&lt;Dataset&gt; में टैग datasets.xml वह कहता है ERDDAP™ निर्दिष्ट क्वेरी का उपयोग करने के लिए (" के बाद यूआरएल का हिस्सा?) अगर .html फ़ाइल प्रकार (डाटा एक्सेस फॉर्म) बिना किसी प्रश्न के अनुरोध किया जाता है।
    * आपको शायद ही कभी इसका उपयोग करने की आवश्यकता होगी।
    * आपको XML-encode की आवश्यकता है (नहीं) चूंकि वे XML दस्तावेज़ में हैं, डिफ़ॉल्ट क्वेरीज़। उदाहरण के लिए, और हो जाता है &amp;&lt;होना&lt;, &gt; हो जाता है & gt;
    * कृपया अपना काम चेक करें। यह एक गलती करने के लिए आसान है और आप क्या चाहते हैं नहीं मिलता है। ERDDAP™ अपनी त्रुटियों को साफ करने की कोशिश करेंगे - लेकिन उस पर भरोसा न करें, क्योंकि\\*कैसे\\*यह साफ हो सकता है।
    * ग्रिडडैप डेटासेट के लिए, इसका एक सामान्य उपयोग एक अलग डिफ़ॉल्ट गहराई या ऊंचाई आयाम मान निर्दिष्ट करना है (उदाहरण के लिए, \\[ 0 \\] इसके बजाय \\[ अंतिम \\] ) ।
किसी भी मामले में, आपको हमेशा सभी चरों को सूचीबद्ध करना चाहिए, हमेशा सभी चरों के लिए समान आयाम मानों का उपयोग करें, और लगभग हमेशा उपयोग करें। \\[ 0 \\] , \\[ अंतिम \\] या \\[ 0: \\] आयाम मान के लिए।
उदाहरण के लिए:
    ```
        <defaultDataQuery>u\\[last\\]\\[0\\]\\[0:last\\]\\[0:last\\],v\\[last\\]\\[0\\]\\[0:last\\]\\[0:last\\]</defaultDataQuery>
    ```
    * के लिए tabledap डेटासेट, यदि आप किसी भी बाधा को निर्दिष्ट नहीं करते हैं, तो अनुरोध डेटासेट के आधार पर पूरे डेटासेट को वापस कर देगा। यदि आप किसी भी बाधा को निर्दिष्ट नहीं करना चाहते हैं, बजाय खाली है&lt;डिफ़ॉल्टDataQuery&gt; (जो डिफ़ॉल्ट रूप से निर्दिष्ट नहीं है DataQuery) , आपको उन सभी चरों को स्पष्ट रूप से सूचीबद्ध करने की आवश्यकता है जिन्हें आप डिफ़ॉल्टDataQuery में शामिल करना चाहते हैं।
    * के लिए tabledap डेटासेट, इसका सबसे आम उपयोग एक अलग डिफ़ॉल्ट समय सीमा निर्दिष्ट करना है (अधिकतम (समय) उदाहरण के लिए, & समय&gt; = अधिकतम (समय) 1 दिन, या अब के सापेक्ष, उदाहरण के लिए, & समय&gt;= now- 1 दिन) ।
याद रखें कि कोई डेटा चर का अनुरोध करना सभी डेटा चर को निर्दिष्ट करने के समान है, इसलिए आमतौर पर आप नए समय की बाधा को निर्दिष्ट कर सकते हैं।
उदाहरण के लिए:
    ```
        <defaultDataQuery>&amp;time&gt;=max(time)-1day</defaultDataQuery>  
    ```
या
    ```
        <defaultDataQuery>&amp;time&gt;=now-1day</defaultDataQuery>  
    ```
#### &lt;डिफ़ॉल्टग्राफ क्वेरी&gt;{#defaultgraphquery} 
* [ ** &lt;डिफ़ॉल्टग्राफ क्वेरी&gt; ** ] (#defaultgraphquery) एक के भीतर एक वैकल्पिक टैग है&lt;Dataset&gt; में टैग datasets.xml वह कहता है ERDDAP™ निर्दिष्ट क्वेरी का उपयोग करने के लिए (" के बाद यूआरएल का हिस्सा?) यदि फ़ाइल .graph प्रकार (मेक A Graph Form) बिना किसी प्रश्न के अनुरोध किया जाता है।
    * आपको शायद ही कभी इसका उपयोग करने की आवश्यकता होगी।
    * आपको XML-encode की आवश्यकता है (नहीं) चूंकि वे XML दस्तावेज़ में हैं, डिफ़ॉल्ट क्वेरीज़। उदाहरण के लिए, और हो जाता है &amp;&lt;होना&lt;, &gt; हो जाता है & gt;
    * कृपया अपना काम चेक करें। यह एक गलती करने के लिए आसान है और आप क्या चाहते हैं नहीं मिलता है। ERDDAP™ अपनी त्रुटियों को साफ करने की कोशिश करेंगे - लेकिन उस पर भरोसा न करें, क्योंकि\\*कैसे\\*यह साफ हो सकता है।
    * ग्रिडडैप डेटासेट के लिए, इसका सबसे आम उपयोग एक अलग डिफ़ॉल्ट गहराई या ऊंचाई आयाम मान निर्दिष्ट करना है (उदाहरण के लिए, \\[ 0 \\] इसके बजाय \\[ अंतिम \\] ) और/या निर्दिष्ट करने के लिए कि एक विशिष्ट चर ग्राफ किया जा सकता है।
किसी भी मामले में, आप लगभग हमेशा उपयोग करेंगे \\[ 0 \\] , \\[ अंतिम \\] या \\[ 0: \\] आयाम मान के लिए।
उदाहरण के लिए:
    ```
        <defaultGraphQuery>temp\\[last\\]\\[0\\]\\[0:last\\]\\[0:last\\]&amp;.draw=surface&amp;.vars=longitude|latitude|temp</defaultGraphQuery>  
    ```
         (लेकिन यह सब एक पंक्ति में डाल दिया) 
    * के लिए tabledap डेटासेट, यदि आप किसी भी बाधा को निर्दिष्ट नहीं करते हैं, तो अनुरोध पूरे डेटासेट को ग्राफ़ करेगा, जो डेटासेट के आधार पर लंबे समय तक ले सकता है।
    * के लिए tabledap डेटासेट, इसका सबसे आम उपयोग एक अलग डिफ़ॉल्ट समय सीमा निर्दिष्ट करना है (अधिकतम (समय) उदाहरण के लिए, & समय&gt; = अधिकतम (समय) 1 दिन, या अब के सापेक्ष, उदाहरण के लिए, & समय&gt;= now- 1 दिन) ।
याद रखें कि कोई डेटा चर का अनुरोध करना सभी डेटा चर को निर्दिष्ट करने के समान है, इसलिए आमतौर पर आप नए समय की बाधा को निर्दिष्ट कर सकते हैं।
उदाहरण के लिए:
    ```
        <defaultGraphQuery>&amp;time&gt;=max(time)-1day</defaultGraphQuery>  
    ```
या
    ```
        <defaultGraphQuery>&amp;time&gt;=now-1day</defaultGraphQuery>  
    ```
#### &lt;आयामValuesInMemory&gt;{#dimensionvaluesinmemory} 
* [ ** &lt;आयाम मानसून&gt; ** ] (#dimensionvaluesinmemory)   (सच (डिफ़ॉल्ट) या झूठ) एक वैकल्पिक और शायद ही कभी इस्तेमाल किया जाने वाला टैग भीतर है&lt;किसी के लिए डेटासेट&gt; टैग EDDGrid डेटासेट जो बताता है ERDDAP™ जहां आयाम के स्रोत मूल्यों को बनाए रखने के लिए (इसे भी जाना जाता है axisVariable s) :
    
    * True = in मेमोरी (जो तेज़ है लेकिन अधिक मेमोरी का उपयोग करता है) 
    * डिस्क पर झूठा = (जो धीमी है लेकिन कोई स्मृति का उपयोग नहीं करता है) 
    
उदाहरण के लिए,
    ```
    <dimensionValuesInMemory>false</dimensionValuesInMemory>  
    ```
आपको केवल झूठे के गैर-डिफ़ॉल्ट मूल्य के साथ इसका उपयोग करना चाहिए यदि आपका ERDDAP™ बहुत बड़े आयामों के साथ बहुत सारे डेटासेट हैं (उदाहरण के लिए, लाखों मूल्य, उदाहरण के लिए, में EDDGrid AudioFiles डेटासेट) और ERDDAP 'In use स्मृति उपयोग हमेशा बहुत अधिक है। वर्तमान में मेमोरी देखें: वर्तमान में लाइन का उपयोग करना \\[ आपका डोमेन \\]  /erddap/status.html निगरानी करने के लिए ERDDAP™ स्मृति उपयोग।
     
#### &lt;फ़ाइलTableInMemory&gt;{#filetableinmemory} 
* [ ** &lt;फ़ाइलTableInMemory&gt; ** ] (#फ़ाइलटेबलइंमेमोरी)   (सच या झूठ (डिफ़ॉल्ट) ) भीतर एक वैकल्पिक टैग है&lt;किसी के लिए डेटासेट&gt; टैग EDDGrid FromFiles and EDDTable सेफाइल्स डेटासेट जो बताता है ERDDAP™ कहाँ फ़ाइल रखने के लिए (जिसमें प्रत्येक स्रोत डेटा फ़ाइल के बारे में जानकारी है) :
    
    * True = in मेमोरी (जो तेज़ है लेकिन अधिक मेमोरी का उपयोग करता है) 
    * डिस्क पर झूठा = (जो धीमी है लेकिन कोई स्मृति का उपयोग नहीं करता है) 
    
उदाहरण के लिए,
    ```
    <fileTableInMemory>true</fileTableInMemory>  
    ```
यदि आप इसे किसी भी डेटासेट के लिए सच करने के लिए सेट करते हैं, तो मेमोरी पर नजर रखें: वर्तमान में वर्तमान में लाइन का उपयोग करना \\[ आपका डोमेन \\]  /erddap/status.html यह सुनिश्चित करना ERDDAP™ अभी भी बहुत सारी मुफ्त मेमोरी है।
     
#### &lt;fgdcFile&gt;{#fgdcfile} 
* [ ** &lt;fgdcFile&gt; ** ] (#Fgdcfile) एक के भीतर एक वैकल्पिक टैग है&lt;Dataset&gt; में टैग datasets.xml वह कहता है ERDDAP™ इसके बजाय पूर्व निर्मित FGDC फाइल का उपयोग करना ERDDAP™ फ़ाइल बनाने की कोशिश करें। उपयोग:
```
    <fgdcFile>*fullFileName*</fgdcFile>  
```
     *पूर्ण फ़ाइल नाम* एक स्थानीय फ़ाइल को संदर्भित कर सकते हैं (कहीं सर्वर की फ़ाइल प्रणाली पर) या किसी दूरस्थ फ़ाइल का यूआरएल।
अगर *पूर्ण फ़ाइल नाम* \\="" या फ़ाइल नहीं मिली है, डेटासेट में FGDC मेटाडाटा नहीं होगा। इसलिए यदि आप एक विशिष्ट डेटासेट के लिए FGDC मेटाडाटा को दबाना चाहते हैं तो यह भी उपयोगी है।
या, आप डाल सकते हैं&lt;FgdcActive&gt;false&lt;/fgdcActive&gt; सेटअप.xml में बताने के लिए ERDDAP™ किसी भी डेटासेट के लिए FGDC मेटाडाटा प्रदान नहीं करना चाहिए।
     
#### &lt;iso19115 फ़ाइल & gt;{#iso19115file} 
* [ ** &lt;iso19115File&gt; ** ] (#iso19115file) एक के भीतर एक वैकल्पिक टैग है&lt;Dataset&gt; में टैग datasets.xml वह कहता है ERDDAP™ इसके बजाय एक पूर्व निर्मित ISO 19115 फाइल का उपयोग करना ERDDAP™ फ़ाइल बनाने की कोशिश करें। उपयोग:
    ```
    <iso19115File>*fullFileName*</iso19115File>  
    ```
     *पूर्ण फ़ाइल नाम* एक स्थानीय फ़ाइल को संदर्भित कर सकते हैं (कहीं सर्वर की फ़ाइल प्रणाली पर) या किसी दूरस्थ फ़ाइल का यूआरएल।
अगर *पूर्ण फ़ाइल नाम* \\="" या फ़ाइल नहीं मिली है, डेटासेट में ISO 19115 मेटाडाटा नहीं होगा। तो यह भी उपयोगी है यदि आप एक विशिष्ट डेटासेट के लिए ISO 19115 मेटाडाटा को दबाना चाहते हैं।
या, आप डाल सकते हैं&lt;iso19115Active&gt;false&lt;/iso19115Active&gt; सेटअप.xml में बताने के लिए ERDDAP™ किसी भी डेटासेट के लिए आईएसओ 19115 मेटाडाटा प्रदान करने के लिए नहीं।
     
#### &lt;मैच NDigits&gt;{#matchaxisndigits} 
* [ ** &lt;मैच AxisNDigits&gt; ** ] (#Matchaxisndigits) एक के भीतर एक OPTIONAL टैग है EDDGrid  &lt;Dataset&gt; टैग के लिए EDDGrid डेटासेट जो एकत्रीकरण हैं, उदाहरण के लिए, फ़ाइलों की एकत्रीकरण। प्रत्येक बार डेटासेट को पुनः लोड किया जाता है, ERDDAP™ जाँच करता है कि एकत्रीकरण के प्रत्येक घटक के अक्ष मान समान हैं। परीक्षण की परिशुद्धता द्वारा निर्धारित की जाती है [मैच AxisNDigits](#matchaxisndigits) , जो अंकों की कुल संख्या को निर्दिष्ट करता है जिसे डबल परिशुद्धता अक्ष मानों का परीक्षण करते समय मिलान करना चाहिए, 0 - 18 (डिफ़ॉल्ट) । जब फ्लोट अक्ष मूल्यों का परीक्षण किया जाता है, तो परीक्षण मैच के साथ किया जाता हैAxisNDigits/2 अंक। 18 या उससे अधिक का मान बताता है EDDGrid सटीक परीक्षण करना। 0 का मान EDDGrid किसी भी परीक्षण करने के लिए, जिसे नीचे वर्णित किए गए अनुसार अनुशंसित नहीं है।
    
हालांकि EDDGrid एकत्रीकरण के घटकों को थोड़ा अलग अक्ष मान होने की अनुमति देता है, केवल अक्ष मूल्यों का एक सेट उपयोगकर्ता को दिखाया जाता है। सेट उसी घटक से है जो डेटासेट के स्रोत मेटाडाटा प्रदान करता है। उदाहरण के लिए, EDDGrid FromFiles datasets, कि द्वारा निर्दिष्ट है&lt;MetadataFrom&gt; सेटिंग (डिफ़ॉल्ट=last) ।
    
मैच का उपयोगAxisNDigits=0 ज्यादातर मामलों में दृढ़ता से हतोत्साहित है, क्योंकि यह सभी जाँच बंद हो जाता है। यहां तक कि न्यूनतम जाँच उपयोगी है क्योंकि यह सुनिश्चित करता है कि घटक एकत्र करने के लिए उपयुक्त हैं। हम सभी मानते हैं कि सभी घटक उपयुक्त हैं, लेकिन यह हमेशा ऐसा नहीं है। इस प्रकार यह एक महत्वपूर्ण पवित्रता परीक्षण है। मैच के मान भी AxisNDigits1, 2, 3 या 4 को हतोत्साहित किया जाता है क्योंकि विभिन्न अक्ष मान अक्सर संकेत देते हैं कि घटक बनाए गए थे। (क्या?) एक अलग तरीका है और इस प्रकार एकत्रीकरण के लिए उपयुक्त नहीं है।
    
एक ऐसा मामला है जहां मैच का उपयोग करनाAxisNDigits\\=0 उपयोगी और अनुशंसित है: दूरस्थ फ़ाइलों के एकत्रीकरण के साथ, उदाहरण के लिए, S3 बाल्टी में डेटा। इस मामले में, यदि डेटासेट कैशफ्रॉमयूरल, कैशSizeGB, मैचAxisNDigits\\=0, और अगर डेटासेट कैशफ्रॉमयूरल, कैशSizeGB, मैच का उपयोग करता है, तो AxisNDigits\\=0, और EDDGrid सेफाइल्स सिस्टम के लिए [द्वारा एकत्रीकरण फ़ाइल का नाम](#aggregation-via-file-names-or-global-metadata) फिर EDDGrid एकत्रीकरण करने के लिए सभी दूरस्थ फ़ाइलों को पढ़ने की जरूरत नहीं है। यह S3 बाल्टी में डेटासेट से बहुत जल्दी लोड करने की अनुमति देता है (धीरे-धीरे अगर EDDGrid सभी फ़ाइलों को डाउनलोड और पढ़ने के लिए है) ।
    
#### &lt;nThreads&gt;{#nthreads} 
* शुरू ERDDAP™ संस्करण 2.00, जब EDDTableFromFiles के किसी भी उपवर्ग या EDDGrid इसके स्रोत से डेटा पढ़ता है, यह डेटा का एक हिस्सा पढ़ सकता है (उदाहरण के लिए, एक स्रोत फ़ाइल) समय (एक धागे में)   (यह डिफ़ॉल्ट है) डेटा का एक से अधिक हिस्सा (उदाहरण के लिए 2+ स्रोत फ़ाइलें) समय (2 या अधिक धागे में) प्रत्येक अनुरोध को संसाधित करते समय।
     
    * अंगूठे का नियम:
अधिकांश प्रणालियों पर अधिकांश डेटासेट के लिए, nThreads=1, डिफ़ॉल्ट का उपयोग करें। यदि आपके पास एक शक्तिशाली कंप्यूटर है (सीपीयू कोर के बहुत सारे, स्मृति के बहुत सारे) , फिर nThreads को 2, 3, 4, या उच्च पर सेट करने पर विचार करें (लेकिन कंप्यूटर में सीपीयू कोर की संख्या से अधिक नहीं) डेटासेट के लिए जो लाभ उठा सकते हैं:
        
        * अधिकांश EDDTableFromFiles डेटासेट को लाभ होगा।
        * डेटासेट जहां कुछ डेटा के एक हिस्से से पहले अंतराल का कारण बनता है, वास्तव में संसाधित किया जा सकता है, उदाहरण के लिए:
            * डेटासेट के साथ [बाह्य रूप से संपीड़ित (उदाहरण के लिए .gz ) ](#externally-compressed-files) द्विआधारी (उदाहरण के लिए .nc ) फ़ाइलें, क्योंकि ERDDAP™ फाइल को पढ़ने से पहले पूरी फाइल को डिकंप्रेस करना होगा।
            * डेटासेट जो उपयोग करते हैं [कैशSizeGB](#cachefromurl) क्योंकि ERDDAP™ इसे पढ़ने से पहले अक्सर फाइल को डाउनलोड करना पड़ता है।
            * डेटासेट एक उच्च बैंडविड्थ समानांतर फ़ाइल प्रणाली पर संग्रहीत डेटा फ़ाइलों के साथ, क्योंकि यह अनुरोध करते समय अधिक डेटा, तेज़ी से वितरित कर सकता है। समानांतर फ़ाइल प्रणालियों के उदाहरणों में शामिल हैं [JBOD](https://en.wikipedia.org/wiki/Non-RAID_drive_architectures) , [पीएफ](http://www.pnfs.com/) , [GlusterFS](https://en.wikipedia.org/wiki/Gluster) अमेज़न S3, और गूगल क्लाउड स्टोरेज।
                 
        
चेतावनी: जब nThreads&gt;1 का उपयोग करते हैं, तो ध्यान रखें ERDDAP मेमोरी उपयोग, थ्रेड उपयोग और समग्र जिम्मेदारी (देखें [ ERDDAP 'स्थिति पृष्ठ'](/docs/server-admin/additional-information#status-page) ) । नीचे इन मुद्दों के बारे में टिप्पणियां देखें।
         
    * किसी दिए गए डेटासेट के लिए, यह nThread सेटिंग विभिन्न स्थानों से आ सकती है:
        
        * यदि datasets.xml एक डेटासेट के लिए एक हिस्सा है&lt;nThreads&gt; टैग (साथ में)&lt;डेटासेट&gt; टैग, वैश्विक विशेषता के रूप में नहीं) एक मूल्य के साथ&gt; = 1, nThreads का वह मान प्रयोग किया जाता है। इसलिए, आप प्रत्येक डेटासेट के लिए एक अलग नंबर निर्दिष्ट कर सकते हैं।
        * अन्यथा, अगर datasets.xml है&lt;nTableThreads&gt; टैग (EDDTable सेफ़िल्स डेटासेट) या&lt;nGridThreads&gt; टैग (के लिए EDDGrid डेटासेट) मूल्य के साथ 1, बाहर&lt;डेटासेट&gt; टैग, nThreads का वह मान प्रयोग किया जाता है।
        * अन्यथा, 1 धागे का उपयोग किया जाता है, जो एक सुरक्षित विकल्प है क्योंकि यह स्मृति की सबसे छोटी राशि का उपयोग करता है।
             
        
के लिए [मूल ERDDAP™ स्थापना](https://coastwatch.pfeg.noaa.gov/erddap/index.html) , हम उपयोग करते हैं
        &lt;nTableThreads&gt; 6&lt;/nTableThreads&gt; (यह शक्तिशाली सर्वर है।) अब कठिन अनुरोध पिछले समय का 30% लेते हैं।
         
##### मॉनिटर संसाधन उपयोग{#monitor-resource-usage} 
जब आप विभिन्न nThread सेटिंग्स के साथ प्रयोग कर रहे हैं (शायद आपके लिए मुश्किल नमूना अनुरोध करना ERDDAP ) , आप अपने कंप्यूटर के संसाधन उपयोग की निगरानी कर सकते हैं:
* मैक पर, खोजकर्ता का उपयोग करें: अनुप्रयोग: उपयोगिताएँ: गतिविधि मॉनिटर
* लिनक्स पर, शीर्ष का उपयोग करें
* Windows 10 पर उपयोग करें *Ctrl + Shift + Esc* कार्य प्रबंधक खोलने के लिए
             
##### चेतावनी: बढ़ी हुई प्रतिक्रिया{#warning-decreased-responsiveness} 
अलगाव में, ERDDAP™ यदि nThreads=1 की तुलना में अधिक nThreads सेटिंग के साथ डेटासेट के अनुरोध को पूरा करेगा। लेकिन जबकि उस अनुरोध को संसाधित किया जा रहा है, अन्य उपयोगकर्ताओं के अन्य अनुरोधों को कुछ हद तक भीड़भाड़ दिया जाएगा और धीमी प्रतिक्रिया प्राप्त होगी। इसके अलावा, कब ERDDAP™ किसी दिए गए अनुरोध, अन्य कंप्यूटिंग संसाधनों का जवाब देता है (उदाहरण के लिए, डिस्क ड्राइव एक्सेस, नेटवर्क बैंडविड्थ) विशेष रूप से उच्च nThread सेटिंग्स के साथ सीमित हो सकता है। इस प्रकार उच्च nThread सेटिंग्स के साथ, एकाधिक अनुरोधों को संसाधित करने के दौरान समग्र प्रणाली उत्तरदायीता खराब हो जाएगी - यह उपयोगकर्ताओं के लिए बहुत परेशान हो सकता है&#33; इस वजह से: कंप्यूटर में सीपीयू कोर की संख्या से कहीं अधिक nThread सेट नहीं किया गया। nThreads=1 प्रत्येक अनुरोध के बाद से सबसे उचित सेटिंग है (कई एक साथ अनुरोधों के बीच) कंप्यूटिंग संसाधनों का समान हिस्सा प्राप्त होगा। लेकिन अधिक शक्तिशाली कंप्यूटर, कम यह एक समस्या होगी।
         
##### चेतावनी: उच्च मेमोरी उपयोग EDDGrid डेटासेट{#warning-higher-memory-use-for-eddgrid-datasets} 
जबकि प्रसंस्करण अनुरोध सीधे nThreads सेटिंग के समान है। अंगूठे का एक यथोचित सुरक्षित नियम है: आपको सेट करने की आवश्यकता है [ ERDDAP मेमोरी सेटिंग्स](/docs/server-admin/deploy-install#memory) कम से कम 2GB + (2GB) । कुछ डेटासेट के लिए कुछ अनुरोधों की तुलना में अधिक स्मृति की आवश्यकता होगी। उदाहरण के लिए, किसी के लिए nThreads=3 सेट करना EDDGrid डेटासेट का मतलब है कि -Xmx सेटिंग कम से कम -Xmx8000M होना चाहिए। यदि वह मेमोरी सेटिंग 3/4 से अधिक है तो कंप्यूटर की भौतिक मेमोरी, nThreads सेटिंग को कम करती है ताकि आप मेमोरी सेटिंग को कम कर सकें।

EDDTable डेटासेट के लिए थ्रेड प्रोसेसिंग अनुरोधों का मेमोरी उपयोग लगभग हमेशा कम होता है क्योंकि फाइलें आमतौर पर बहुत छोटी होती हैं। हालांकि, अगर किसी दिए गए EDDTable डेटासेट में बहुत बड़ा है (उदाहरण के लिए, &gt; = 1 जीबी) डेटा फाइलें, फिर ऊपर की टिप्पणियां उन डेटासेट पर भी लागू होगी।

जो भी nThreads सेटिंग, अपने पर स्मृति उपयोग आँकड़ों पर करीबी नजर रखते हैं [ ERDDAP 'स्थिति पृष्ठ'](/docs/server-admin/additional-information#status-page) । आपको कभी स्मृति उपयोग को अधिकतम करने के करीब नहीं आना चाहिए ERDDAP अन्यथा गंभीर त्रुटियां और विफलताएं होंगी।
        
##### अस्थायी रूप से 1 में सेट करें{#temporarily-set-to-1} 
यदि वर्तमान मेमोरी का उपयोग थोड़ा अधिक होता है, तो इसका उपयोग थोड़ा अधिक होता है। ERDDAP™ इस अनुरोध के लिए nThread सेट करेगा 1. इस प्रकार, ERDDAP™ जब स्मृति दुर्लभ होती है तो स्मृति को संरक्षित करता है।
         
##### Diminishing रिटर्न{#diminishing-returns} 
nThreads सेटिंग को बढ़ाने के लिए रिटर्न कम कर रहे हैं: 2 धागे 1 से बेहतर तरीके से होंगे (यदि हम गतिशील ओवरक्लॉकिंग को अनदेखा करते हैं) । लेकिन 3 केवल 2 से बेहतर होगा। 4 केवल 3 से अधिक बेहतर होगा।

एक बड़ी EDDTable Dataset के लिए एक कठिन क्वेरी के एक परीक्षण में, 1, 2, 3, 4, 5, 6 धागे का उपयोग करते हुए प्रतिक्रिया समय 38, 36, 20, 18, 13, 11 सेकंड था। (अब हम उस सर्वर पर nTableThreads=6 का उपयोग करते हैं।) 

nThreads=2: हालांकि, अक्सर nThreads=1 के बजाय nThreads=2 को निर्दिष्ट करने के लिए एक महत्वपूर्ण लाभ होता है, यह अक्सर किसी दिए गए उपयोगकर्ता के अनुरोध का जवाब देने के लिए आवश्यक घड़ी के समय में बहुत अंतर नहीं करेगा। कारण यह है: nThreads=1 के साथ, अधिकांश आधुनिक सीपीयू अक्सर होगा [गतिशील रूप से overclock](https://en.wikipedia.org/wiki/Intel_Turbo_Boost)   (टर्बो बढ़ावा) सीपीयू की घड़ी की गति को अस्थायी रूप से बढ़ाने के लिए। इस प्रकार nThreads=1 के साथ, यदि आप nThreads=2 का उपयोग करते हैं तो एक कोर अक्सर दो कोर की तुलना में एक उच्च घड़ी की गति पर काम करेगा। भले ही, हम अभी भी सोचते हैं कि nThreads=1 के बजाय nThreads=2 का उपयोग करना बेहतर है, क्योंकि यह सेटिंग स्थितियों की एक विस्तृत विविधता में बेहतर परिणाम देगी। बेशक, यदि आपके कंप्यूटर में पर्याप्त सीपीयू कोर है, तो एक भी उच्च nThread सेटिंग बेहतर परिणाम प्राप्त करना चाहिए।

जैसा कि ऊपर बताया गया है, बहुत अधिक nThread सेटिंग्स कुछ अनुरोधों के लिए तेजी से प्रतिक्रियाएं उत्पन्न कर सकते हैं, लेकिन समग्र रूप से कम होने का जोखिम ERDDAP™ प्रतिक्रियात्मकता और उच्च स्मृति उपयोग (जैसा कि ऊपर बताया गया है) जबकि उन अनुरोधों को संसाधित किया जा रहा है इसका मतलब है कि यह आम तौर पर एक अच्छा विचार नहीं है।
        
##### सीपीयू कोर{#cpu-cores} 
आपको कभी भी कंप्यूटर के सीपीयू में सीपीयू कोर की संख्या से बड़ी संख्या में nThread सेट नहीं करना चाहिए। अनिवार्य रूप से सभी आधुनिक सीपीयू में एकाधिक कोर होते हैं (उदाहरण के लिए, 2, 4, या 8) । कुछ कंप्यूटरों में एकाधिक सीपीयू भी हैं (उदाहरण के लिए, 2 सीपीयू \\* 4 कोर / सीपीयू = 8 सीपीयू कोर) । यह पता लगाने के लिए कि कंप्यूटर में कितने सीपीयू और कोर हैं:

* मैक पर उपयोग करें *विकल्प कुंजी* : सेब मेनू: सिस्टम जानकारी
* लिनक्स पर, बिल्ली /proc / cpuinfo का उपयोग करें
* Windows 10 पर उपयोग करें *Ctrl + Shift + Esc* खोलने के लिए कार्य प्रबंधक: निष्पादन (लॉजिकल प्रोसेसर सीपीयू कोर की कुल संख्या को दर्शाता है) 

हाँ, अधिकांश प्रोसेसर इन दिनों कहते हैं कि वे प्रति कोर 2 धागे का समर्थन करते हैं (माध्यम [हाइपर-थ्रेडिंग](https://en.wikipedia.org/wiki/Hyper-threading) ) , लेकिन 2 धागे कंप्यूटिंग संसाधनों को साझा करते हैं, इसलिए आप भारी भार के तहत सीपीयू पर दो बार थ्रूपुट नहीं देखेंगे। उदाहरण के लिए, 4 कोर वाले एक सीपीयू वाला एक कंप्यूटर 8 धागे तक समर्थन देने का दावा कर सकता है, लेकिन आपको उस में nThreads=4 से अधिक कभी नहीं होना चाहिए। ERDDAP । याद रखें कि:

* nThreads सेटिंग में ERDDAP™ प्रति अनुरोध है। ERDDAP™ अक्सर एकाधिक अनुरोधों को एक साथ संभालती है।
*    ERDDAP™ प्रक्रिया अनुरोध के अलावा अन्य चीजें करता है, उदाहरण के लिए, डेटासेट को फिर से लोड करें।
* कब ERDDAP™ किसी दिए गए अनुरोध, अन्य कंप्यूटिंग संसाधनों का जवाब देता है (उदाहरण के लिए, डिस्क ड्राइव एक्सेस, नेटवर्क बैंडविड्थ) सीमित हो सकता है। जितना अधिक आप nThread सेट करते हैं, उतना अधिक संभावना है कि इन अन्य संसाधनों को अधिकतम किया जाएगा और धीमा हो जाएगा ERDDAP सामान्य प्रतिक्रिया।
* ऑपरेटिंग सिस्टम रन के अलावा अन्य चीजें करता है ERDDAP ।

इसलिए कंप्यूटर के सीपीयू में कोर की संख्या से अधिक करने के लिए nThreads सेटिंग निर्धारित करने के लिए सबसे अच्छा नहीं है।
         
##### आपका माइलेज मई वेरी (YMMV)  {#your-mileage-may-vary-ymmv} 
विभिन्न nThreads सेटिंग्स के परिणाम विभिन्न प्रणालियों पर विभिन्न डेटासेट के लिए विभिन्न अनुरोधों के लिए बहुत भिन्न होंगे। यदि आप वास्तव में विभिन्न nThreads सेटिंग्स के प्रभाव को जानना चाहते हैं, तो यथार्थवादी परीक्षण चलाएं।
         
##### क्यों nThreads प्रति अनुरोध?{#why-nthreads-per-request} 
मैं आपसे कुछ सोच सकता हूं कि "क्या प्रति अनुरोध nThread है? यदि मैं इसे कोडित कर रहा हूं, तो मैं बेहतर प्रदर्शन के लिए एक स्थायी कार्यकर्ता थ्रेड पूल और मैसेजिंग कतार का उपयोग करूंगा। एक कार्यकर्ता थ्रेड पूल का उपयोग करने के साथ समस्या और एक मैसेजिंग कतार यह है कि एक कठिन अनुरोध कई धीमी कार्यों के साथ कतार को बाढ़ कर देगा। यह प्रभावी रूप से अवरुद्ध होगा ERDDAP™ आरंभिक अनुरोध होने तक अन्य अनुरोधों से संबंधित कार्यों पर भी काम शुरू करना (अनिवार्य रूप से) समाप्त हुआ। इस प्रकार, इसके बाद भी सरल अनुरोध धीरे-धीरे सुपर जवाब देंगे। ERDDAP अनुरोध के अनुसार nThreads के उपयोग से कंप्यूटिंग संसाधनों का बहुत उचित उपयोग होता है।
         
##### nThreads बनाम एकाधिक कार्यकर्ता कंप्यूटर{#nthreads-vs-multiple-worker-computers} 
दुर्भाग्यवश, ERDDAP 'nThreads प्रणाली कभी भी कई श्रमिक कंप्यूटरों के माध्यम से सच समानांतर रूप में प्रभावी नहीं होगी, जिसमें प्रत्येक डेटा के एक हिस्से पर काम करता है, जिस तरह से Hadoop या अपाचे स्पार्क का उपयोग आमतौर पर किया जाता है। जब कार्य वास्तव में एकाधिक कंप्यूटरों के लिए समानांतर / वितरित होता है, तो प्रत्येक कंप्यूटर अपने कार्य के हिस्से पर अपने सभी संसाधनों का उपयोग कर सकता है। साथ ERDDAP 'nThreads प्रणाली, प्रत्येक धागे समान कंप्यूटर की बैंडविड्थ, डिस्क ड्राइव, मेमोरी आदि के लिए प्रतिस्पर्धा कर रहा है। दुर्भाग्य से, हममें से अधिकांश के पास सेट अप करने या किराए पर लेने के लिए संसाधन या धन नहीं है (अमेज़न वेब सर्विसेज (एडब्ल्यूएस) Google क्लाउड प्लेटफ़ॉर्म (जीसीपी) ) कंप्यूटर के विशाल ग्रिड। इसके अलावा, एक रिलेशनल डेटाबेस के विपरीत जो किसी भी क्रम में परिणाम पंक्तियों को वापस करने की अनुमति देता है, ERDDAP™ परिणामस्वरूप पंक्तियों को एक सुसंगत क्रम में वापस करने का वादा करता है। यह बाधा बनाता है ERDDAP 'nThreads कार्यान्वयन कम कुशल. लेकिन ERDDAP 'nThread' कई मामलों में उपयोगी है।

हालांकि, बनाने के तरीके हैं ERDDAP™ एक बड़ी संख्या में अनुरोधों को जल्दी से संभालना [ग्रिड / क्लस्टर / फेडरेशन ऑफ ERDDAP s](/docs/server-admin/scaling) ।
         
#### &lt;पैलेट्स&gt;{#palettes} 
* शुरू ERDDAP™ संस्करण 2.12, datasets.xml शामिल कर सकते हैं&lt;पैलेट्स&gt; टैग (साथ)&lt;erddapDatasets&lt;पैलेट्स&gt; टैग मान संदेशों से.xml (या संदेशों को उलट देता है.xml मान अगर टैग में datasets.xml खाली है) । यह आपको उपलब्ध पैलेटों की सूची बदलने देता है जबकि ERDDAP™ चल रहा है। यह आपको एक बदलाव करने देता है और जब आप एक नया संस्करण स्थापित करते हैं तो यह बनी रहती है ERDDAP ।
WARNING: पैलेट्स में सूचीबद्ध datasets.xml संदेशों में सूचीबद्ध पैलेटों का एक सुपरसेट होना चाहिए.xml; अन्यथा ERDDAP™ एक अपवाद फेंकना और रोक प्रसंस्करण datasets.xml । यह सुनिश्चित करता है कि सभी ERDDAP™ प्रतिष्ठान कम से कम एक ही कोर पैलेट का समर्थन करते हैं।
चेतावनी: ERDDAP™ यह जांचता है कि पैलेट्स फ़ाइलों को संदेशों में निर्दिष्ट किया गया है। xml वास्तव में मौजूद है, लेकिन यह में सूचीबद्ध पैलेट फ़ाइलों की जांच नहीं करता है। datasets.xml । यह सुनिश्चित करने की आपकी ज़िम्मेदारी है कि फाइलें मौजूद हैं।
    
इसके अलावा शुरू ERDDAP™ संस्करण 2.12, यदि आप एक cptfiles subdirectory बनाते हैं ERDDAP™ सामग्री निर्देशिका ERDDAP™ उस निर्देशिका में सभी \\*.cpt फ़ाइलों को कॉपी करेगा \\[ tomcat \\] /webapps/erddap/WEB-INF/cptfiles निर्देशिका हर बार ERDDAP™ शुरू होता है। इस प्रकार, यदि आप उस निर्देशिका में कस्टम cpt फ़ाइलों को डालते हैं, तो उन फ़ाइलों का उपयोग करके किया जाएगा ERDDAP™ , अपने हिस्से पर कोई अतिरिक्त प्रयास नहीं है, भले ही आप एक नया संस्करण स्थापित करें ERDDAP ।
    
यदि आप अपने लिए कस्टम पैलेट जोड़ते हैं ERDDAP™ आपके पास EDDGrid FromErddap and/or EDDTableFromErddap Datasets in your own time. ERDDAP™ तब उपयोगकर्ता आपके कस्टम पैलेट विकल्प को देखेंगे ERDDAP™ एक Graph वेब पेज बनाएं, लेकिन अगर उपयोगकर्ता उन्हें उपयोग करने की कोशिश करता है, तो उन्हें डिफ़ॉल्ट के साथ एक ग्राफ मिलेगा (आमतौर पर इंद्रधनुष) पैलेट यह इसलिए है क्योंकि छवि रिमोट द्वारा बनाई गई है ERDDAP™ जो कस्टम पैलेट नहीं है। अब केवल समाधान दूरस्थ ईमेल करने के लिए हैं ERDDAP™ प्रशासक अपने कस्टम पैलेट को उसके / उसके पास जोड़ने के लिए ERDDAP या ईमेल क्रिस जॉन noaa.gov पर यह पूछने के लिए कि पैलेट को मानक में जोड़ा जाना चाहिए ERDDAP™ वितरण।
    
#### &lt;OnChange&gt;{#onchange} 
* [ ** &lt;OnChange&gt; ** ] (#onchange) एक के भीतर एक वैकल्पिक टैग है&lt;Dataset&gt; में टैग datasets.xml जब यह डेटासेट बनाया जाता है तो यह एक कार्रवाई को निर्दिष्ट करता है जो किया जाएगा (जब ERDDAP™ पुनरारंभ करना) जब भी यह डेटासेट किसी भी तरह से बदल जाता है।
    * वर्तमान में, EDDGrid उपवर्ग, मेटाडाटा में कोई भी परिवर्तन या अक्ष चर में (उदाहरण के लिए, निकट-वास्तविक समय डेटा के लिए एक नया समय बिंदु) एक बदलाव माना जाता है, लेकिन डेटासेट का पुनः लोड एक बदलाव नहीं माना जाता है (खुद) ।
    * वर्तमान में, EDDTable subclasses के लिए, डेटासेट का कोई भी रीलोडिंग एक बदलाव माना जाता है।
    * वर्तमान में, केवल दो प्रकार के कार्यों की अनुमति है:
        * "http://"या "https://"-- यदि कार्रवाई शुरू होती है तो "http://"या "https://", ERDDAP™ भेजेगा HTTP GET निर्दिष्ट URL का अनुरोध करें। प्रतिक्रिया को नजरअंदाज कर दिया जाएगा। उदाहरण के लिए, यूआरएल कुछ करने के लिए कुछ अन्य वेब सेवा बता सकता है।
            * यदि URL में क्वेरी पार्ट है (" के बाद?) , यह पहले से ही होना चाहिए [प्रतिशत encoded](https://en.wikipedia.org/wiki/Percent-encoding) । आपको बाधाओं में विशेष वर्णों को कोडित करने की आवश्यकता है (प्रारंभिक '&' और मुख्य के अलावा '=' बाधाओं में) %HHH के रूप में, जहां HH चरित्र का 2 अंक hexadecimal मान है। आमतौर पर, आपको बस कुछ punctuation अक्षरों को बदलने की आवश्यकता होती है: % में %25, और %26 में, "%22 में,&lt;%3C में =%3D में&gt;%3E में +%2B में, | %7C में \\[ %5B में \\] %5D में,%20 में अंतरिक्ष, और # 127 से ऊपर के सभी पात्रों को अपने UTF-8 फॉर्म में परिवर्तित करें और फिर %HH प्रारूप में UTF-8 फॉर्म के प्रत्येक बाइट को कोडित करें। (मदद के लिए प्रोग्रामर से पूछें) ।
उदाहरण के लिए, & stationID &gt;="41004"
बन गया stationID %3E =%2241004%22
जब आप एक्सेस करते हैं तो पर्सेंट एन्कोडिंग की आवश्यकता होती है ERDDAP एक ब्राउज़र के अलावा अन्य सॉफ्टवेयर के माध्यम से। ब्राउज़र आमतौर पर आपके लिए प्रतिशत एन्कोडिंग संभालते हैं।
कुछ स्थितियों में, आपको A-Za-z0-9\\_-&#33; ' () \\*, लेकिन अभी भी प्रारंभिक '&' या मुख्य कोड नहीं है '=' बाधाओं में।
प्रोग्रामिंग भाषाओं में ऐसा करने के लिए उपकरण हैं (उदाहरण के लिए, देखें Java ' [ java.net.URLEncoder ](https://docs.oracle.com/javase/8/docs/api/java/net/URLEncoder.html) और Java स्क्रिप्टencodeURIComponent()] (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) ) और वहाँ रहे हैं
                 [उन वेबसाइटों के लिए जो आपके लिए प्रतिशत एनकोड / डीकोड करते हैं](https://www.url-encode-decode.com/) ।
            * चूंकि datasets.xml एक XML फ़ाइल है, आप MUST भी और सभी '&', '&lt;यूआरएल में '&amp;', '&lt;',' और '&gt;' प्रतिशत एन्कोडिंग के बाद।
            * उदाहरण: एक URL के लिए जिसे आप ब्राउज़र में टाइप कर सकते हैं:
                https://www.company.com/webService?department=R%26D&param2=value2  
आपको निर्दिष्ट करना चाहिए&lt;OnChange&gt; द्वारा टैग (एक पंक्ति पर) 
            ```
                <onChange>https://www.company.com/webService?department=R%26D&amp;param2=value2</onChange>
            ```
        * मेल्टो: -- अगर कार्रवाई "mailto:" के साथ शुरू होती है, ERDDAP™ बाद के ईमेल पते पर एक ईमेल भेजेगा, यह दर्शाता है कि डेटासेट को अद्यतन / परिवर्तित किया गया है।
उदाहरण के लिए:&lt;OnChange&gt;mailto:john.smith@company.com&lt;/onChange&gt; यदि आपके पास अच्छा कारण है ERDDAP™ कुछ अन्य प्रकार की कार्रवाई का समर्थन करने के लिए, हमें एक ईमेल भेजें जिसे आप चाहते हैं।
    * यह टैग वैकल्पिक है। जैसा कि आप चाहते हैं उनमें से कई टैग हो सकते हैं। प्रत्येक कार्रवाई के लिए इन टैगों में से एक का उपयोग करें।
    * यह अनुरूप है ERDDAP 'ई-मेल/URL सदस्यता प्रणाली, लेकिन इन कार्यों को लगातार संग्रहीत नहीं किया जाता है (यानी, वे केवल EDD ऑब्जेक्ट में संग्रहीत होते हैं) ।
    * एक सदस्यता को हटाने के लिए, बस उसे हटा दें&lt;onChange&gt; टैग। अगली बार डेटासेट को फिर से लोड किया जाता है।
         
#### &lt;ReloadEveryNMinutes&gt;{#reloadeverynminutes} 
* [ ** &lt;रीलोड हरमन मिनट&gt; ** ] (#reloadeverynminutes) एक के भीतर एक वैकल्पिक टैग है&lt;Dataset&gt; में टैग datasets.xml लगभग सभी डेटासेट प्रकार जो निर्दिष्ट करते हैं कि कितनी बार डेटासेट को फिर से लोड किया जाना चाहिए। उदाहरण के लिए,
    ```
    <reloadEveryNMinutes>60</reloadEveryNMinutes>
    ```
    * आम तौर पर, डेटासेट जो अक्सर बदलते हैं (उदाहरण के लिए, नए डेटा फ़ाइलों को प्राप्त करें) अक्सर पुनः लोड किया जाना चाहिए, उदाहरण के लिए, हर 60 मिनट।
    * डेटासेट जो अपर्याप्त रूप से परिवर्तन करते हैं, उन्हें बार-बार पुनः लोड किया जाना चाहिए, उदाहरण के लिए, प्रत्येक 1440 मिनट (दैनिक) 10080 मिनट (साप्ताहिक) ।
    * यह टैग वैकल्पिक है, लेकिन अनुशंसित है। डिफ़ॉल्ट 10080 है।
    * उदाहरण है:&lt;ReloadEveryNMinutes&gt;1440&lt;/reload हरमन मिनट&gt;
    * जब डेटासेट को फिर से लोड किया जाता है, तो सभी फाइलों में सभी फाइलें *बड़ाParentDirectory* / कैश / * datasetID * निर्देशिका हटा दी जाती है।
    * इससे कोई फर्क नहीं पड़ता कि यह क्या है, डेटासेट को अधिक बार लोड नहीं किया जाएगा&lt;LoadDatasetsMinutes&gt; (डिफ़ॉल्ट = 15) निर्दिष्ट के अनुसार [साइटमैप](/docs/server-admin/deploy-install#setupxml) । इसलिए यदि आप चाहते हैं कि डेटासेट को बहुत बार फिर से लोड किया जाए, तो आपको पुनः लोड करने की आवश्यकता हैEveryNMinutes और loadDatasets MinMinutes to small value.
    * Reload स्थापित न करें न्यूनतम, क्योंकि समाप्त होने का समय होने की संभावना है (उदाहरण के लिए) 14:58 या 15:02, इसलिए डेटासेट केवल प्रमुख रीलोड के आधे हिस्से में पुनः लोड हो जाएगा। इसके बजाय, एक छोटा सा उपयोग करें (उदाहरण के लिए, 10) या बड़ा (उदाहरण के लिए, 20) रीलोड प्रत्येकNMinutes मान।
    * ReloadEveryNMinutes के बावजूद, आप मैन्युअल रूप से कह सकते हैं ERDDAP™ जितनी जल्दी हो सके एक विशिष्ट डेटासेट को पुनः लोड करना [झंडा फाइल](/docs/server-admin/additional-information#flag) ।
    * Curious प्रोग्रामर के लिए ERDDAP™ , सभी डेटासेट का पुनः लोड दो एकल उद्देश्य धागे से संभाला जाता है। एक धागा एक मामूली लोड शुरू करता है अगर यह एक झंडा फ़ाइल या एक प्रमुख फिर से लोड मिल जाता है (जो सभी डेटासेट को यह देखने के लिए चेक करता है कि उन्हें फिर से लोड करने की आवश्यकता है या नहीं।) । दूसरा धागा एक समय में डेटासेट का वास्तविक पुनः लोड करता है। ये धागे पृष्ठभूमि में काम करते हैं ताकि यह सुनिश्चित किया जा सके कि सभी डेटासेट को अद्यतन रखा गया है। थ्रेड जो वास्तव में रीलोड करता है, एक डेटासेट का एक नया संस्करण तैयार करता है, फिर इसे जगह में बदल देता है (अनिवार्य रूप से पुराने संस्करण को परमाणु रूप से बदल रहा है) । इसलिए यह बहुत संभव है कि घटनाओं का निम्नलिखित अनुक्रम होता है (यह एक अच्छी बात है) :
        
        1.   ERDDAP™ डेटासेट को फिर से लोड करना शुरू कर देता है (एक नया संस्करण बनाना) पृष्ठभूमि में।
        2. उपयोगकर्ता 'A' डेटासेट के लिए एक अनुरोध बनाता है। ERDDAP™ प्रतिक्रिया बनाने के लिए डेटासेट के वर्तमान संस्करण का उपयोग करता है। (यह अच्छा है। उपयोगकर्ता के लिए कोई देरी नहीं थी, और डेटासेट का वर्तमान संस्करण कभी भी बहुत stale नहीं होना चाहिए।) 
        3.   ERDDAP™ डेटासेट का नया पुनः लोड संस्करण तैयार करना और उस नए संस्करण को उत्पादन में बदल देना। बाद में सभी नए अनुरोधों को डेटासेट के नए संस्करण द्वारा संभाला जाता है। संगति के लिए, उपयोगकर्ता A का अनुरोध अभी भी मूल संस्करण से भरा जा रहा है।
        4. उपयोगकर्ता 'बी' डेटासेट का अनुरोध करता है और ERDDAP™ प्रतिक्रिया बनाने के लिए डेटासेट के नए संस्करण का उपयोग करता है।
        5. अंततः उपयोगकर्ता A और उपयोगकर्ता B का अनुरोध पूरा हो गया है (शायद A's end पहले, शायद B's end पहले) ।
        
मैं किसी को कह सकता हूं, "जस्ट टू थर्ड्स&#33; हे&#33; यह लंगड़ा है&#33; उन्हें यह निर्धारित करना चाहिए कि डेटासेट की पुनः लोड करने के लिए आवश्यकतानुसार कई धागे का उपयोग किया जाता है, इसलिए यह सब तेजी से हो जाता है और इसमें थोड़ा या कोई अंतराल नहीं होता है। हाँ और नहीं। समस्या यह है कि एक समय में एक से अधिक डेटासेट लोड करने से कई कठिन नई समस्याएं पैदा होती हैं। उन्हें हल करने या उससे निपटने की जरूरत है। वर्तमान प्रणाली अच्छी तरह से काम करती है और प्रबंधनीय समस्याएं होती हैं (उदाहरण के लिए, एक ध्वज से पहले अंतराल के लिए संभावित देखा जाता है) । (यदि आपको उनकी मदद की ज़रूरत है, तो हमें देखें [अतिरिक्त समर्थन प्राप्त करने पर अनुभाग](/docs/intro#support) ।) संबंधित [अपडेट हर्नमिली](#updateeverynmillis) सिस्टम प्रतिक्रिया धागे के भीतर काम करता है, इसलिए यह कई डेटासेट को अपडेट किया जा सकता है और करता है (पूर्ण पुनः लोड नहीं) एक साथ।
##### सक्रिय बनाम प्रतिक्रियाशील{#proactive-vs-reactive} 
 ERDDAP 'रीलोड सिस्टम सक्रिय है - डेटासेट जल्द ही उनके पुनः लोड होने के बाद लोड हो जाता है हर मिनट का समय ऊपर है (यानी, वे "महान" बन जाते हैं, लेकिन कभी भी बहुत अजीब नहीं) क्या डेटासेट उपयोगकर्ताओं से अनुरोध प्राप्त कर रहा है या नहीं। तो ERDDAP™ डेटासेट हमेशा अद्यतन होते हैं और उपयोग के लिए तैयार होते हैं। यह THREDDS के प्रतिक्रियाशील दृष्टिकोण के विपरीत है: एक उपयोगकर्ता का अनुरोध यह है कि THREDDS को यह जांचने के लिए कहता है कि क्या डेटासेट stale है? (यह बहुत सुन्दर हो सकता है) । यदि यह कहानी है तो THREDDS उपयोगकर्ता को प्रतीक्षा करता है (अक्सर कुछ मिनट के लिए) जबकि डेटासेट को पुनः लोड किया जाता है।
        
#### &lt;अपडेट हर्नमिलिस&gt;{#updateeverynmillis} 
* [ ** &lt;EveryNMillis ** ] (#updateeverynmillis) एक के भीतर एक वैकल्पिक टैग है&lt;Dataset&gt; में टैग datasets.xml कुछ डेटासेट प्रकार जो मदद करता है ERDDAP™ डेटासेट के साथ काम करना जो अक्सर बदलते हैं (अक्सर के रूप में हर दूसरे) । विपरीत ERDDAP नियमित, सक्रिय&lt;रीलोड हरNMinutes (#reloadeverynminutes) प्रत्येक डेटासेट को पूरी तरह से लोड करने के लिए सिस्टम, यह वैकल्पिक अतिरिक्त प्रणाली प्रतिक्रियाशील है (एक उपयोगकर्ता अनुरोध द्वारा ट्रिगर) क्योंकि यह वृद्धिशील है (अद्यतन करने की जरूरत है कि सिर्फ सूचना अद्यतन करना) । उदाहरण के लिए, यदि कोई अनुरोध करने के लिए EDDGrid FromDap dataset पिछले अद्यतन के बाद से मिलीसेकेंड की निर्दिष्ट संख्या से अधिक होता है, ERDDAP™ यह देखना होगा कि क्या बाएं के लिए कोई नया मूल्य है (आमतौर पर "time" ) आयाम और यदि ऐसा हो तो उपयोगकर्ता के अनुरोध को संभालने से पहले उन नए मूल्यों को डाउनलोड करें। यह प्रणाली डेटा स्रोत पर न्यूनतम मांगों के साथ तेजी से बदलते डेटासेट को अद्यतन रखने में बहुत अच्छा है, लेकिन कुछ उपयोगकर्ता अनुरोधों के प्रसंस्करण को थोड़ा धीमा करने की लागत पर।
    * इस प्रणाली का उपयोग करने के लिए, जोड़ें (उदाहरण के लिए) :
        ```
        <updateEveryNMillis>1000</updateEveryNMillis>  
        ```
ठीक बाद&lt;ReloadEveryNMinutes&gt; में डेटासेट के लिए टैग datasets.xml । आपके द्वारा निर्दिष्ट मिलीसेकंड की संख्या 1 जितना छोटा हो सकती है (यह सुनिश्चित करने के लिए कि डेटासेट हमेशा अप-टू-डेट है) । 0 का मान (डिफ़ॉल्ट) या नकारात्मक संख्या प्रणाली को बंद कर देती है।
    * उनकी वृद्धिशील प्रकृति के कारण, अद्यतन बहुत जल्दी समाप्त होना चाहिए, इसलिए उपयोगकर्ताओं को कभी भी लंबे समय तक इंतजार नहीं करना चाहिए।
    * यदि पिछले अद्यतन समाप्त होने से पहले दूसरा डेटा अनुरोध आता है, तो दूसरा अनुरोध दूसरे अपडेट को ट्रिगर नहीं करेगा।
    * प्रलेखन के दौरान, हम इन नए वृद्धिशील, आंशिक अद्यतनों के लिए नियमित, पूर्ण डेटासेट रीलोड के लिए "रीलोड" शब्द का उपयोग करने की कोशिश करेंगे।
    * परीक्षण प्रयोजनों के लिए, कुछ निदान log.txt करने के लिए मुद्रित कर रहे हैं अगर [[]&lt;लॉग लेवल&gt; (#loglevel) में datasets.xml "सभी" के लिए सेट है।
    * यदि आप वृद्धिशील अद्यतन का उपयोग करते हैं और विशेष रूप से बाईं ओर (पहला) उदाहरण के लिए, समय, अक्ष बड़ा है, आप सेट करना चाहते हैं&lt;ReloadEveryNMinutes&gt; एक बड़ी संख्या में (1440?) इसलिए अद्यतन डेटासेट अप-टू-डेट रखने के लिए अधिकांश कार्य करते हैं, और पूरी तरह से लोड किया जाता है।
    * नोट: यह नया अपडेट सिस्टम मेटाडाटा अपडेट करता है (उदाहरण के लिए, समय actual\\_range , समय \\_coverage \\_end, ...) लेकिन चालू नहीं हैचांग (ईमेल या स्पर्श यूआरएल) या परिवर्तन RSS फ़ीड (शायद यह होना चाहिए...) ।
    * सभी डेटासेट के लिए जो सबक्लास का उपयोग करते हैं [ EDDGrid सेफिल](#eddgridfromfiles) और [EDDTableFromFiles](#eddtablefromfiles) :
        *    **चेतावनी:** जब आप इसे निर्देशिका में कॉपी करके एक डेटासेट में एक नई डेटा फ़ाइल जोड़ते हैं कि ERDDAP™ लगता है कि वहाँ एक खतरा है कि ERDDAP™ आंशिक रूप से लिखित फ़ाइल को नोटिस करेगा; इसे पढ़ने की कोशिश करें, लेकिन असफल क्योंकि फ़ाइल अधूरी है; फ़ाइल को "bad" फ़ाइल होने की घोषणा करती है और इसे हटा देती है। (अस्थायी रूप से) डेटासेट से।
इससे बचने के लिए, हम **पूरी तरह से सिफारिश** कि आप एक अस्थायी नाम के साथ निर्देशिका में एक नई फाइल कॉपी करें (उदाहरण के लिए, 20150226 .nc Tmp) यह डेटासेट फ़ाइल से मेल नहीं खाता है NameRegex (डाउनलोड .nc ) फिर फ़ाइल को सही नाम में बदलें (उदाहरण के लिए, 20150226 .nc ) । यदि आप इस दृष्टिकोण का उपयोग करते हैं तो, ERDDAP™ अस्थायी फ़ाइल को अनदेखा करेगा और जब यह पूरा हो जाता है और उपयोग करने के लिए तैयार हो जाता है तो केवल सही नाम वाली फ़ाइल को नोटिस करेगा।
        * यदि आप मौजूदा डेटाफ़ाइलों को जगह में संशोधित करते हैं (उदाहरण के लिए, एक नया डेटा बिंदु जोड़ने के लिए) ,&lt;अद्यतनEveryNMillis&gt; अच्छी तरह से काम करेगा यदि परिवर्तन परमाणु रूप से दिखाई देते हैं (तत्काल) और फ़ाइल हमेशा एक वैध फ़ाइल है। उदाहरण के लिए, netcdf-java पुस्तकालय एक "क्लासिक" के असीमित आयाम को जोड़ती है .nc v3 फ़ाइल को परमाणु रूप से बनाने के लिए।
            &lt;अद्यतनEveryNMillis&gt; बुरी तरह से काम करेगा यदि फ़ाइल अवैध है जबकि परिवर्तन किया जा रहा है।
        *   &lt;अद्यतनEveryNMillis&gt; डेटासेट के लिए अच्छी तरह से काम करेगा जहां एक या कुछ फाइलें थोड़ी मात्रा में बदल जाती हैं।
        *   &lt;अद्यतनEveryNMillis&gt; डेटासेट के लिए खराब रूप से काम करेगा जहां फ़ाइलों की एक बड़ी संख्या थोड़ी मात्रा में बदल जाती है। (जब तक कि परिवर्तन परमाणु रूप से दिखाई देते हैं) । इन डेटासेटों के लिए, इसका उपयोग करना बेहतर है&lt;अद्यतनEveryNMillis&gt; और एक सेट करने के लिए [झंडा](/docs/server-admin/additional-information#set-dataset-flag) बताने के लिए ERDDAP™ डेटासेट को फिर से लोड करने के लिए।
        *   &lt;EveryNMillis [[dot]in [[dot]in [[dot]in]in [[dot]]in [[dot]]]in [[dot]]]]]] [[dot]]in [[dot]]]]]] [[dot]]in [[dot]]]in [[dot]]]]]]]] [[dot]]]]]]]]] [[dot]]]]]]]]]] [[dot]]]]]]]]]] [[dot]in [[[dot]]]]]]]]in [[dot]]]]]]]]]]]]]]]]]]]]in [[:]]]]]]]]]]]]]]]]]]]]]]]] [[dot]in [[dot]in [[dot]]in [[dot]in [[dot]]]in [[dot]]]in [[dot]in [[dot]]]]]]]]]]]]]]]in [[dot]]]]]]]]]&lt; subsetVariables &gt; (#subsetvariables) । आम तौर पर, यह एक समस्या नहीं है, क्योंकि subsetVariables उन चीजों के बारे में जानकारी होती है जो अक्सर कभी-कभी बदलाव नहीं करते हैं (उदाहरण के लिए, स्टेशन के नाम, अक्षांश और देशांतरों की सूची) । यदि subsetVariables डेटा परिवर्तन (उदाहरण के लिए, जब डेटासेट में एक नया स्टेशन जोड़ा जाता है) , फिर संपर्क करें [ध्वज यूआरएल](/docs/server-admin/additional-information#set-dataset-flag) डाटासेट के लिए बताने के लिए ERDDAP™ डेटासेट को फिर से लोड करने के लिए। अन्यथा, ERDDAP™ नए सबसेट को नोटिस नहीं करेगा अगली बार जब तक डेटासेट को फिर से लोड नहीं किया जाता है तब तक परिवर्तनीय जानकारी&lt;ReloadEveryNMinutes&gt;।
        * हमारी सामान्य सिफारिश का उपयोग करना है:
        ```
            <reloadEveryNMinutes>1440</reloadEveryNMinutes>  
            <updateEveryNMillis>10000</updateEveryNMillis>
        ```
        * TROUBLE? लिनक्स कंप्यूटर पर, यदि आप उपयोग कर रहे हैं&lt;EveryNMillis साथ EDDGrid FromFiles or EDDTableFromFiles कक्षाएं, आप एक समस्या देख सकते हैं जहां डेटासेट लोड करने में विफल रहता है (कभी-कभी या लगातार) त्रुटि संदेश के साथ: "IOException: इनोटिफाई उदाहरणों की उपयोगकर्ता सीमा तक पहुंच गई या बहुत सारी खुली फाइलें। कारण में एक बग हो सकता है Java जो उदाहरणों को संग्रहित नहीं होने का कारण बनता है। इस समस्या से बचना चाहिए ERDDAP™ v1.66 और उच्चतर। तो सबसे अच्छा समाधान का नवीनतम संस्करण स्विच करना है ERDDAP ।
यदि वह समस्या को हल नहीं करता है (यदि आपके पास वास्तव में बड़ी संख्या में डेटासेट हैं तो इसका उपयोग करना&lt;अद्यतनEveryNMillis&gt;, आप कॉल करके इस समस्या को ठीक कर सकते हैं:
            ```
            sudo sysctl fs.inotify.max\\_user\\_watches=65536  
            sudo sysctl fs.inotify.max\\_user\\_instances=1024  
            sudo sysctl -p  
            ```
या, यदि समस्या बनी रहती है तो उच्च संख्या का उपयोग करें। घड़ियों के लिए डिफ़ॉल्ट 8192 है। उदाहरणों के लिए डिफ़ॉल्ट 128 है।
    * आप डाल सकते हैं&lt;अद्यतन MaxEvents&gt;10&lt;/updateMaxEvents&gt; में datasets.xml   (शीर्ष के पास अन्य सेटिंग्स के साथ) फ़ाइल परिवर्तनों की अधिकतम संख्या को बदलने के लिए (डिफ़ॉल्ट=10) इसे अद्यतन EveryNMillis प्रणाली द्वारा संसाधित किया जाएगा। डेटासेट के लिए बड़ी संख्या उपयोगी हो सकती है जहां यह बहुत महत्वपूर्ण है कि उन्हें हमेशा अद्यतन रखा जाए। देखें [अद्यतनMaxEvents प्रलेखन](#updatemaxevents) ।
    * गंभीर प्रोग्रामर के लिए - इन वृद्धिशील अद्यतनों के विपरीत ERDDAP पूर्ण [ReloadEveryNMinutes](#reloadeverynminutes) प्रणाली, उपयोगकर्ता अनुरोध धागे के भीतर होती है। इसलिए, किसी भी डेटासेट को एक साथ अद्यतन किया जा सकता है। वहाँ कोड है (लॉक) यह सुनिश्चित करने के लिए कि केवल एक धागा किसी भी समय किसी भी दिए गए डेटासेट के लिए अद्यतन पर काम कर रहा है। एकाधिक एक साथ अद्यतन की अनुमति आसान थी; एकाधिक एक साथ पूर्ण लोड की अनुमति कठिन होगी।
         
#### &lt;स्रोतCanConstrainStringEQNE&gt;{#sourcecanconstrainstringeqne} 
* [ ** &lt;स्रोतCanConstrainStringEQNE&gt; ** ] (#sourcecanconstrainstringeqne) EDDTable के भीतर एक OPTIONAL टैग है&lt;Dataset&gt; में टैग datasets.xml यह निर्दिष्ट करता है कि स्रोत = और &#33;= ऑपरेटरों के साथ स्ट्रिंग चर को बाधित कर सकता है।
    * EDDTableFromDapSequence के लिए, यह केवल बाहरी अनुक्रम स्ट्रिंग चर पर लागू होता है। यह माना जाता है कि स्रोत आंतरिक अनुक्रम चर पर किसी भी बाधा को संभाल नहीं सकता है।
    * यह टैग वैकल्पिक है। मान्य मान सही हैं (डिफ़ॉल्ट) और झूठी।
    * EDDTableFromDapSequence के लिए OPeNDAP DRDS सर्वर, यह सच करने के लिए सेट किया जाना चाहिए (डिफ़ॉल्ट) ।
    * EDDTableFromDapSequence के लिए डैपर सर्वर, यह झूठी करने के लिए सेट किया जाना चाहिए।
    * उदाहरण है:
```
        <sourceCanConstrainStringEQNE>true</sourceCanConstrainStringEQNE>  
```
         
#### &lt;स्रोतCanConstrainStringGTLT&gt;{#sourcecanconstrainstringgtlt} 
* [ ** &lt;स्रोतCanConstrainStringGTLT&gt; ** ] (#sourcecanconstrainstringgtlt) EDDTable के भीतर एक OPTIONAL टैग है&lt;डेटासेट&gt; टैग जो निर्दिष्ट करता है कि स्रोत स्ट्रिंग चर को नियंत्रित कर सकता है या नहीं।&lt;,&lt;=,&gt;, और&gt;= ऑपरेटर।
    * EDDTableFromDapSequence के लिए, यह केवल बाहरी अनुक्रम स्ट्रिंग चर पर लागू होता है। यह माना जाता है कि स्रोत आंतरिक अनुक्रम चर पर किसी भी बाधा को संभाल नहीं सकता है।
    * मान्य मान सही हैं (डिफ़ॉल्ट) और झूठी।
    * यह टैग वैकल्पिक है। डिफ़ॉल्ट सही है।
    * EDDTableFromDapSequence के लिए OPeNDAP DRDS सर्वर, यह सच करने के लिए सेट किया जाना चाहिए (डिफ़ॉल्ट) ।
    * EDDTableFromDapSequence के लिए डैपर सर्वर, यह झूठी करने के लिए सेट किया जाना चाहिए।
    * उदाहरण है:
```
        <sourceCanConstrainStringGTLT>true</sourceCanConstrainStringGTLT>  
```
         
#### &lt;स्रोतCanConstrainStringRegex&gt;{#sourcecanconstrainstringregex} 
* [ ** &lt;स्रोतCanConstrainStringRegex&gt; ** ] (#sourcecanconstrainstringregex) EDDTable के भीतर एक OPTIONAL टैग है&lt;डेटासेट&gt; टैग जो निर्दिष्ट करता है कि स्रोत नियमित अभिव्यक्तियों द्वारा स्ट्रिंग चर को नियंत्रित कर सकता है, और यदि ऐसा है तो ऑपरेटर क्या है।
    * वैध मान "=~" हैं (The number of the DAP मानक) , (गलती से कई द्वारा समर्थित DAP सर्वर) या "" (यह दर्शाता है कि स्रोत नियमित अभिव्यक्ति का समर्थन नहीं करता है) ।
    * यह टैग वैकल्पिक है। डिफ़ॉल्ट " है।
    * EDDTableFromDapSequence के लिए OPeNDAP DRDS सर्वर, इसे "" पर सेट किया जाना चाहिए (डिफ़ॉल्ट) ।
    * EDDTableFromDapSequence के लिए डैपर सर्वर, इसे "" पर सेट किया जाना चाहिए (डिफ़ॉल्ट) ।
    * उदाहरण है:
```
        <sourceCanConstrainStringRegex>=~</sourceCanConstrainStringRegex>  
```
#### &lt;स्रोतCandoDistinct&gt;{#sourcecandodistinct} 
* [ ** &lt;स्रोतCandoDistinct&gt; ** ] (#sourcecandodistinct) EDDTableFromDatabase के भीतर एक OPTIONAL टैग है&lt;डेटासेट&gt; टैग जो निर्दिष्ट करता है कि स्रोत डेटाबेस को संभालना चाहिए और निर्धारित करना चाहिए। () उपयोगकर्ता प्रश्नों में बाधाएं।
    * यह टैग वैकल्पिक है। मान्य मान नहीं हैं ( ERDDAP™ अलग-अलग संभालती है; डिफ़ॉल्ट) आंशिक (स्रोत अलग-अलग संभालता है और ERDDAP™ इसे फिर से संभालती है) हाँ (स्रोत अलग संभालता है) ।
    * यदि आप उपयोग नहीं कर रहे हैं और ERDDAP™ अलग होने पर स्मृति से बाहर चल रहा है, हाँ का उपयोग करें।
    * यदि आप हाँ का उपयोग कर रहे हैं और स्रोत डेटाबेस बहुत धीरे-धीरे अलग संभालती है, तो इसका उपयोग न करें।
    * आंशिक रूप से आपको दोनों में से सबसे बुरा लगता है: यह धीमा है क्योंकि विशिष्ट डेटाबेस का संचालन धीमा है और यह स्मृति से बाहर हो सकता है। ERDDAP ।
    * डेटाबेस परिणामों की सिर्फ अनूठी पंक्तियों के अनुरोध के रूप में DISTINCT की व्याख्या करते हैं, जबकि ERDDAP™ इसे परिणामों की अनूठी पंक्तियों की एक क्रमबद्ध सूची के लिए अनुरोध के रूप में व्याख्या करता है। यदि आप इसे आंशिक या हाँ सेट करते हैं, तो आप इसे आंशिक या हाँ सेट कर सकते हैं। ERDDAP™ स्वचालित रूप से डेटाबेस को परिणामों को सॉर्ट करने के लिए भी कहता है।
    * परिणामों में एक छोटा सा अंतर:
नहीं | आंशिक, ERDDAP™ परिणामों की शुरुआत में "" को सॉर्ट करेगा (गैर-"तार से पहले) ।
हाँ, डेटाबेस हो सकता है (पोस्टग्रेस होगा) परिणाम के अंत में "" टाइप करें (गैर-"तार के बाद) ।
मुझे लगता है कि यह भी छोटे शब्दों की छँटाई को प्रभावित करेगा जो लंबे शब्दों से शुरू होता है। उदाहरण के लिए, ERDDAP™ "साइमन" को "साइमन" से पहले सॉर्ट करेगा।
    * उदाहरण है:
```
        <sourceCanDoDistinct>yes</sourceCanDoDistinct>  
```
         
#### &lt;SourceCanorby&gt;{#sourcecanorderby} 
* [ ** &lt;स्रोत CanOrder by ** ] (#sourcecanorderby) EDDTableFromDatabase के भीतर एक OPTIONAL टैग है&lt;डेटासेट&gt; टैग जो निर्दिष्ट करता है कि स्रोत डेटाबेस को संभालना चाहिए या नहीं orderBy  (......) उपयोगकर्ता प्रश्नों में बाधाएं।
    * यह टैग वैकल्पिक है। मान्य मान नहीं हैं ( ERDDAP™ हैंडल orderBy  (......) डिफ़ॉल्ट) आंशिक (स्रोत हैंडल orderBy और ERDDAP™ इसे फिर से संभालती है) हाँ (स्रोत हैंडल orderBy  (......) ) ।
    * यदि आप उपयोग नहीं कर रहे हैं और ERDDAP™ जब हैंडलिंग स्मृति से बाहर चल रहा है orderBy  (......) , हाँ उपयोग करें।
    * यदि आप हाँ का उपयोग कर रहे हैं और स्रोत डेटाबेस हैंडल orderBy  (......) धीरे-धीरे उपयोग नहीं करते।
    * आंशिक रूप से आपको दोनों में से सबसे खराब देता है: यह धीमा है क्योंकि डेटाबेस की हैंडलिंग orderBy  (......) यह धीमी है और यह स्मृति से बाहर हो सकता है ERDDAP ।
    * परिणामों में एक छोटा सा अंतर:
नहीं | आंशिक, ERDDAP™ परिणामों की शुरुआत में "" को सॉर्ट करेगा (गैर-"तार से पहले) ।
हाँ, डेटाबेस हो सकता है (पोस्टग्रेस होगा) परिणाम के अंत में "" टाइप करें (गैर-"तार के बाद) ।
यह भी छोटे शब्दों के छँटाई को प्रभावित कर सकता है जो लंबे शब्दों से शुरू होता है। उदाहरण के लिए, ERDDAP™ "साइमन" से पहले "साइमन" को सॉर्ट करेगा, लेकिन मुझे यकीन नहीं है कि कैसे एक डेटाबेस उन्हें सॉर्ट करेगा।
    * उदाहरण है:
```
        <sourceCanOrderBy>yes</sourceCanOrderBy>  
```
         
#### &lt;SourceNeedsExpandedFP\\_EQ&gt;{#sourceneedsexpandedfp_eq} 
* [ ** &lt;SourceNeedsExpandedFP \\_EQ&gt; ** ] (#sourceneedsexpandedfp_eq) EDDTable के भीतर एक OPTIONAL टैग है&lt;डेटासेट&gt; टैग जो निर्दिष्ट करता है (सच (डिफ़ॉल्ट) या झूठ) यदि स्रोत को प्रश्नों के साथ मदद की आवश्यकता है&lt;संख्यात्मक चर&gt;=&lt;फ्लोटिंगपॉइंटवेल्यू&gt; (और&#33; =,&gt;=,&lt;=). उदाहरण के लिए,
    ```
    <sourceNeedsExpandedFP\\_EQ>false</sourceNeedsExpandedFP\\_EQ>
    ```
    * कुछ डेटा स्रोतों के लिए, =, &#33;=,&lt;=, या&gt; = फ्लोटिंग पॉइंट नंबर के साथ वांछित के रूप में काम नहीं कर सकता है। उदाहरण के लिए, लम्बाई = 220.2 की खोज विफल हो सकती है यदि मान 220.200000001 के रूप में संग्रहीत है।
    * यह समस्या उत्पन्न होती है क्योंकि फ्लोटिंग पॉइंट नंबर होते हैं [वास्तव में कंप्यूटर के भीतर प्रतिनिधित्व नहीं करता](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/) ।
    * यदि स्रोतNeedsExpandedFP\\EQ सही करने के लिए सेट (डिफ़ॉल्ट) , ERDDAP™ इस समस्या से बचने के लिए डेटा स्रोत को भेजे गए प्रश्नों को संशोधित करता है। यह हमेशा सुरक्षित है और इस सेट को सच करने के लिए ठीक है।
         
#### &lt; sourceUrl & gt;{#sourceurl} 
* [ ** &lt; sourceUrl &gt; ** ] (#sourceurl) एक डेटासेट के वैश्विक भीतर एक आम टैग है&lt; addAttributes &gt; टैग जो यूआरएल को निर्दिष्ट करता है जो डेटा का स्रोत है।
    * उदाहरण है:
    ```
        <sourceUrl>https://oceanwatch.pfeg.noaa.gov/thredds/dodsC/satellite/VH/chla/1day</sourceUrl>  
    ```
         (लेकिन यह सब एक पंक्ति में डाल दिया) 
    * में ERDDAP™ सभी डेटासेट में एक "" होगा sourceUrl "संयुक्त वैश्विक विशेषताओं में जो उपयोगकर्ताओं को दिखाया गया है।
    * अधिकांश डेटासेट प्रकारों के लिए, यह टैग आवश्यक है। यह पता लगाने के लिए डेटासेट प्रकार का विवरण देखें कि क्या यह आवश्यक है या नहीं।
    * कुछ डेटासेट के लिए, अलग&lt; sourceUrl &gt; टैग की अनुमति नहीं है। इसके बजाय, आपको " sourceUrl " [वैश्विक विशेषता](#global-attributes) आम तौर पर वैश्विक \\&gt; में addAttributes &lt;। यदि कोई वास्तविक स्रोत URL नहीं है (उदाहरण के लिए, यदि डेटा स्थानीय फ़ाइलों में संग्रहीत किया जाता है) , इस विशेषता में अक्सर सिर्फ एक प्लेसहोल्डर मूल्य होता है, उदाहरण के लिए,&lt;att name="name"&gt; (स्थानीय फाइलें) &lt;/att&gt;।
    * अधिकांश डेटासेट के लिए, यह URL का आधार है जिसका उपयोग डेटा का अनुरोध करने के लिए किया जाता है। उदाहरण के लिए, DAP सर्वर, यह URL है जिसके लिए .dods, .das, .dds, या HTML जोड़ा जा सकता है।
    * चूंकि datasets.xml एक XML फ़ाइल है, आप MUST भी '&' कोडित करते हैं, '&lt;यूआरएल में '&amp;', '&lt;',' और '&gt;'।
    * अधिकांश डेटासेट प्रकारों के लिए, ERDDAP™ मूल कहते हैं sourceUrl   (स्रोत कोड में "localSourceUrl") to [वैश्विक गुण](#global-attributes)   (जहां यह स्रोत कोड में "publicSourceUrl" बन जाता है) । जब डेटा स्रोत स्थानीय फाइलें होती हैं, ERDDAP™ जोड़ना sourceUrl (a) (स्थानीय फाइलें) "वैश्विक विशेषताओं के लिए सुरक्षा सावधानी के रूप में। जब डेटा स्रोत डेटाबेस होता है, ERDDAP™ जोड़ना sourceUrl (a) (स्रोत डेटाबेस) "वैश्विक विशेषताओं के लिए सुरक्षा सावधानी के रूप में। यदि आपके कुछ डेटासेट गैर-सार्वजनिक उपयोग करते हैं sourceUrl ' (आमतौर पर क्योंकि उनका कंप्यूटर आपके DMZ या स्थानीय लैन पर होता है) आप उपयोग कर सकते हैं [&lt;ConvertTopublicSourceUrl&gt; (#converttopublicsourceurl) टैग निर्दिष्ट करने के लिए कैसे स्थानीय परिवर्तित करने के लिए sourceUrl जनता के लिए sourceUrl S.
    * A sourceUrl शुरू हो सकता है http:// , https:// , ftp://, और शायद अन्य उपसर्ग. https यह सुनिश्चित करने के लिए कि स्रोत कौन है, वे कहते हैं कि वे हैं, यह सुनिश्चित करने के लिए स्रोत के डिजिटल प्रमाण पत्र को पढ़ने और जांचें। दुर्लभ मामलों में, यह जांच त्रुटि "javax.net.ssl.SSLProtocolException: handhake चेतावनी: unrecognized \\_name" के साथ विफल हो सकता है। यह शायद प्रमाण पत्र पर डोमेन नाम के कारण होता है कि आप जिस डोमेन नाम का उपयोग कर रहे हैं उसे मेल नहीं खाता है। आप कर सकते हैं और विवरण पढ़ना चाहिए sourceUrl अपने वेब ब्राउज़र में प्रमाण पत्र, विशेष रूप से, "Subject वैकल्पिक नाम" अनुभाग में "डीएनएस नाम" की सूची।
        
कुछ मामलों में, sourceUrl आप उपयोग कर रहे हैं, प्रमाण पत्र पर डोमेन नाम का उपनाम हो सकता है। उदाहरण के लिए,
        https://podaac-opendap.jpl.nasa.gov/opendap/allData/ccmp/L3.5a/monthly/flk/इस त्रुटि को फेंक देगा, लेकिन
        https://opendap.jpl.nasa.gov/opendap/allData/ccmp/L3.5a/monthly/flk/, जो प्रमाण पत्र पर डोमेन नाम का उपयोग करता है, नहीं जीता। इन मामलों में समाधान इसलिए प्रमाण पत्र पर डोमेन नाम को ढूंढना और उसका उपयोग करना है। यदि आप इसे प्रमाण पत्र पर नहीं पा सकते हैं, तो डेटा प्रदाता से संपर्क करें।
        
अन्य मामलों में, प्रमाणपत्र पर डोमेन नाम नाम नामों के एक समूह के लिए हो सकता है। यदि ऐसा होता है या समस्या अन्यथा असंभव है, तो कृपया क्रिस को ईमेल करें। जॉन noaa.gov पर समस्या की रिपोर्ट करने के लिए।
         

#### &lt;addAttributes&gt; {#addattributes} 
* [ ** &lt; addAttributes &gt; ** ] (#addattributs) प्रत्येक डेटासेट के लिए और प्रत्येक परिवर्तनीय जो देता है के लिए एक OPTIONAL टैग है ERDDAP प्रशासक डेटासेट और इसके चर से जुड़े मेटाडाटा विशेषताओं को नियंत्रित करते हैं।
    *    ERDDAP™ डेटासेट के स्रोत से विशेषताओं को जोड़ती है ("sourceAttributes") और " addAttributes आप किस प्रकार परिभाषित करते हैं datasets.xml   (जो प्राथमिकता है) "combinedAttributes" बनाने के लिए, जो क्या हैं ERDDAP™ उपयोगकर्ता देखते हैं। इस प्रकार, आप उपयोग कर सकते हैं addAttributes SourceAttributes के मूल्यों को फिर से परिभाषित करने के लिए, नई विशेषताओं को जोड़ें, या विशेषताओं को हटा दें।
    * The The most of the&lt; addAttributes &gt; टैग 0 या अधिक संलग्न ** &lt;att&gt; ** उप-टैग, जिसका उपयोग व्यक्तिगत विशेषताओं को निर्दिष्ट करने के लिए किया जाता है।
    * प्रत्येक विशेषता में एक नाम और एक मूल्य होता है (उदाहरण के लिए, जिसमें एक विशिष्ट डेटा प्रकार है, डबल) ।
    * किसी दिए गए नाम के साथ केवल एक ही विशेषता हो सकती है। यदि वहाँ अधिक हैं, तो अंतिम व्यक्ति की प्राथमिकता है।
    * मान एक एकल मान हो सकता है या मूल्यों की एक अंतरिक्ष पृथक सूची हो सकती है।
    * सिंटैक्स
        * आदेश&lt;Att&gt; भीतर subtags addAttributes महत्वपूर्ण नहीं है।
        * The The most of the&lt;att&gt; subtag प्रारूप है
        ```
            <att name="*name*" \\[type="*type*"\\] >*value*</att>
        ```
        * सभी विशेषताओं का गंतव्य नाम एक अक्षर के साथ शुरू होता है (A-Z, a-z) और MUST में केवल अक्षर A-Z, A-Z, 0-9, या '\\_' होते हैं।
        * यदि&lt;Att&gt; subtag का कोई मूल्य या null का मान नहीं है, जो विशेषता को संयुक्त विशेषताओं से हटा दिया जाएगा।
उदाहरण के लिए,&lt;att name="rows" /&gt; संयुक्त विशेषताओं से पंक्तियों को हटा देगा।
उदाहरण के लिए,&lt;att name="coordinates"&gt; शून्य&lt;/att&gt; संयुक्त विशेषताओं से निर्देशांक को हटा देगा।
##### विशेषता प्रकार{#attributetype} 
* [ऑप्शनल प्रकार का मूल्य]&lt;att&gt; subtags (#attributetype) मानों के लिए डेटा प्रकार को इंगित करता है। डिफ़ॉल्ट प्रकार स्ट्रिंग है। स्ट्रिंग विशेषता का एक उदाहरण है:
    ```
    <att name="creator\\_name">NASA/GSFC OBPG</att>
    ```
    * एकल मूल्यों के लिए मान्य प्रकार बाइट हैं (8-bit integer) छोटा (16-bit हस्ताक्षरित पूर्णांक) , int (32-bit हस्ताक्षरित पूर्णांक) लंबा (64-बिट हस्ताक्षरित पूर्णांक) तैरना (32-बिट फ्लोटिंग पॉइंट) , डबल (64-बिट फ्लोटिंग पॉइंट) , चार और स्ट्रिंग। उदाहरण के लिए,
        ```
        <att name="scale\\_factor" type="float">0.1</att>
        ```
इन नोटों को देखें [चार डेटा प्रकार](#char) ।
इन नोटों को देखें [लंबे डेटा प्रकार](#long) ।
        
    * मानों की अंतरिक्ष पृथक सूचियों के लिए मान्य प्रकार (या एकल मान) byteList, shortList, unsignedShortList, charList, intList, longList, फ्लोटलिस्ट, डबल सूची उदाहरण के लिए,
        ```
        <att name="actual\\_range" type="doubleList">10.34 23.91</att>  
        ```
एक unsignedShortList आपको असाइन किए गए शॉर्ट्स की सूची निर्दिष्ट करने देता है, लेकिन उन्हें संबंधित यूनिकोड वर्णों की सूची में परिवर्तित किया जाएगा (उदाहरण के लिए, "65 67 69" को "A C E" में परिवर्तित किया जाएगा।
यदि आप एक charList निर्दिष्ट करते हैं, तो किसी विशेष वर्ण (जैसे, अंतरिक्ष, डबल उद्धरण, backslash) को एनकोड करें।&lt;#32, या # 127) जैसा कि आप उन्हें एनसीसीएसवी फ़ाइल के डेटा अनुभाग में कोडित करेंगे (उदाहरण के लिए, "", "\\\\\\\\\\", "\\\\\\\\\\\\\", "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\n "\\u20ac") ।
कोई स्ट्रिंगलिस्ट नहीं है। स्ट्रिंग मूल्यों को मल्टी-लाइन स्ट्रिंग के रूप में स्टोर करें। उदाहरण के लिए,
        ```
        <att name="history">2011-08-05T08:55:02Z ATAM - made CF-1.6 compliant.  
        2012-04-08T08:34:58Z ATAM - Changed 'height' from double to float.</att>  
                ```
                 
#### वैश्विक योगदान{#global-attributes} 
* [ ** वैश्विक गुण&lt; addAttributes &gt; ** ] (#Global-attributes) --
    &lt; addAttributes &gt; भीतर एक OPTIONAL टैग है&lt;डेटासेट&gt; टैग जिसका उपयोग उन विशेषताओं को बदलने के लिए किया जाता है जो पूरे डेटासेट पर लागू होते हैं।
    
    *    ** वैश्विक उपयोग&lt; addAttributes &gt; डेटासेट की वैश्विक विशेषताओं को बदलने के लिए। **  ERDDAP™ डेटासेट के स्रोत से वैश्विक विशेषताओं को जोड़ती है ()** स्रोतAttributes **) और वैश्विक**  addAttributes  **जिसे आप परिभाषित करते हैं datasets.xml   (जो प्राथमिकता है) वैश्विक बनाने के लिए** संयुक्त एथलीट ** क्या है ERDDAP™ उपयोगकर्ता देखते हैं। इस प्रकार, आप उपयोग कर सकते हैं addAttributes SourceAttributes के मूल्यों को फिर से परिभाषित करने के लिए, नई विशेषताओं को जोड़ें, या विशेषताओं को हटा दें।
    * [] ** &lt; addAttributes &gt; **सूचना (#addattributs) जो वैश्विक और परिवर्तनीय पर लागू होता है** &lt; addAttributes &gt; ** ।
    *    [FGDC](https://www.fgdc.gov/standards/projects/FGDC-standards-projects/metadata/base-metadata/index_html) और [आईएसओ 19115-2/19139](https://en.wikipedia.org/wiki/Geospatial_metadata) मेटाडाटा -- आम तौर पर, ERDDAP™ स्वचालित रूप से ISO 19115-2 / 19139 और FGDC उत्पन्न करेगा (FGDC-STD-001-1998) डेटासेट के मेटाडाटा से जानकारी का उपयोग करके प्रत्येक डेटासेट के लिए XML मेटाडाटा फाइलें। तो, **अच्छा डेटासेट मेटाडाटा अच्छा होता है ERDDAP ISO 19115 और FGDC मेटाडाटा कृपया अपने डेटासेट के मेटाडाटा में सुधार करने में बहुत समय और प्रयास करने पर विचार करें (जो किसी भी तरह से करने के लिए एक अच्छी बात है) ।** अधिकांश डेटासेट मेटाडाटा गुण जो ISO 19115 और FGDC मेटाडाटा उत्पन्न करने के लिए उपयोग किए जाते हैं से हैं [ACDD मेटाडाटा मानक](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) और इतने नीचे उल्लेखित हैं।
    * कई वैश्विक विशेषताओं में विशेष हैं ERDDAP™ उन्हें देखने के लिए और उन्हें विभिन्न तरीकों से उपयोग करते हैं। उदाहरण के लिए, करने के लिए एक लिंक infoUrl डेटासेट की सूची और अन्य स्थानों के साथ वेब पृष्ठों पर शामिल है, ताकि उपयोगकर्ता डेटासेट के बारे में अधिक जानकारी प्राप्त कर सकें।
    * जब कोई उपयोगकर्ता डेटा की एक सबसेट का चयन करता है, तो वैश्लेषिकी के देशांतर, अक्षांश, ऊंचाई से संबंधित वैश्लेषिकी (या गहराई) समय सीमा (उदाहरण के लिए, दक्षिणी अधिकांश \\_उत्तरी, उत्तरी अधिकांश \\_उत्तरी, समय \\_coverage \\_start, समय \\_coverage \\_end) स्वचालित रूप से उत्पन्न या अद्यतन कर रहे हैं।
    * वैश्विक नमूना&lt; addAttributes &gt;
        ```
        <addAttributes> 
          <att name="Conventions">COARDS, CF-1.6, ACDD-1.3</att>
          <att name="infoUrl">https://coastwatch.pfeg.noaa.gov/infog/PH\\_ssta\\_las.html</att>
          <att name="institution">NOAA CoastWatch, West Coast Node</att>
          <att name="title">SST, Pathfinder Ver 5.0, Day and Night, Global</att>
          <att name="cwhdf\\_version" />
        </addAttributes>  
        ```
खाली cwhdf \\_version विशेषता स्रोत cwhdf \\_version विशेषता का कारण बनता है (यदि कोई हो) अंतिम, विशेषताओं की संयुक्त सूची से हटाया जाना चाहिए।
    * इस जानकारी की आपूर्ति करने में मदद करता है ERDDAP™ बेहतर काम करते हैं और उपयोगकर्ता डेटासेट को समझने में मदद करते हैं।
अच्छा मेटाडाटा एक डाटासेट प्रयोग करने योग्य बनाता है।
अपर्याप्त मेटाडाटा एक डेटासेट बेकार बनाता है।
कृपया मेटाडाटा विशेषताओं के साथ अच्छा काम करने का समय लें।
##### विशेष वैश्विक विशेषताएँ ERDDAP™ 
###### स्वीकृति{#acknowledgement} 
*    [ **स्वीकृति** ](#acknowledgement) और **acknowledgment**   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) समूह या समूहों को स्वीकार करने का एक तरीका है जो समर्थन प्रदान करता है (विशेष रूप से, वित्तीय) परियोजना के लिए जिसने इस डेटा को बनाया। उदाहरण के लिए,
    ```
    <att name="acknowledgment">AVISO</att>
    ```    
ध्यान दें कि ACDD 1.0 और 1.1 ने वर्तनी "अवशोषित" का उपयोग किया (जो अमेरिका में सामान्य वर्तनी है।) , लेकिन ACDD 1.3 ने इसे "अवज्ञा" में बदल दिया। (जो यू.के. में सामान्य वर्तनी है।) । मेरी समझ यह है कि बदलाव अनिवार्य रूप से एक दुर्घटना थी और उन्होंने निश्चित रूप से बदलाव के सुधार को नहीं पहचाना था। क्या है? अब दुनिया भर में लाखों डेटा फाइलें हैं जिनके पास "अनोवेलेजमेंट" और लाखों लोग हैं जिनके पास "अनोवेलेजमेंट" है। यह एक मानक में "सरल" परिवर्तन के फोल को उजागर करता है, और मानकों में स्थिरता की आवश्यकता पर जोर देता है। क्योंकि ACDD 1.3 (जो ACDD का संस्करण है ERDDAP™ समर्थन) कहते हैं कि "Anoledgement" क्या है? ERDDAP™   (विशेष रूप से जेनरेटडाटासेट एक्सएमएल) प्रोत्साहित करना।
     
###### cdm \\_altitude \\_proxy{#cdm_altitude_proxy} 
*    [ **cdm \\_altitude \\_proxy** ](#cdm_altitude_proxy) केवल EDDTable डेटासेट के लिए है जिसमें ऊंचाई या गहराई परिवर्तनीय नहीं है लेकिन इसमें एक चर है जो ऊंचाई या गहराई के लिए प्रॉक्सी है। (उदाहरण के लिए, दबाव, सिग्मा, बोतल संख्या) , आप उस परिवर्तनीय की पहचान करने के लिए इस विशेषता का उपयोग कर सकते हैं। उदाहरण के लिए,
    ```
    <att name="cdm\\_altitude\\_proxy">pressure</att>  
    ```
यदि [cdm \\_data \\_type](#cdm_data_type) प्रोफाइल या ट्रेजेक्टरीप्रोफाइल है और इसमें कोई ऊंचाई या गहराई परिवर्तनीय नहीं है, cdm \\_altitude \\_proxy MUST को परिभाषित किया गया है। यदि cdm \\_altitude \\_proxy परिभाषित किया गया है, ERDDAP™ निम्नलिखित मेटाडाटा को चर में जोड़ देगा: \\_Coordinate एक्सिस टाइप = हेट और अक्ष = जेड।
     
###### cdm \\_data \\_type{#cdm_data_type} 
*    [ **cdm \\_data \\_type** ](#cdm_data_type)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) एक वैश्विक विशेषता है जो इंगित करता है Unidata   [सामान्य डेटा मॉडल](https://www.unidata.ucar.edu/software/netcdf-java/v4.6/CDM/index.html) डेटासेट के लिए डेटा प्रकार। उदाहरण के लिए,
    ```
    <att name="cdm\\_data\\_type">Point</att>  
    ```
सीडीएम अभी भी विकसित हो रहा है और फिर से बदल सकता है। ERDDAP™ संबंधित और अधिक विस्तृत अनुपालन [Discrete Sampling Geometries (DSG) ](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries) अध्याय [सीएफ 1.6](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) मेटाडाटा सम्मेलन (पहले CF प्वाइंट अवलोकन सम्मेलन बुलाया) ।
    * या तो डेटासेट वैश्विक [स्रोतAttributes](#global-attributes) वैश्विक&lt; addAttributes &gt; MUST में cdm \\_data \\_type विशेषता शामिल है। कुछ डेटासेट प्रकार (EDDTable ओबी) इसे स्वचालित रूप से सेट करेगा।
    * के लिए EDDGrid डेटासेट, cdm \\_data \\_type विकल्प ग्रिड हैं (डिफ़ॉल्ट और अब तक के लिए सबसे आम प्रकार EDDGrid डेटासेट) , मूविंगग्रिड, अन्य, प्वाइंट, प्रोफाइल, रेडियल स्वीप, टाइमसीरीज, टाइमसीरीजप्रोफाइल, स्वाथ, ट्रेजेक्टरी, और ट्रेजेक्टरीप्रोफाइल। वर्तमान में, EDDGrid किसी भी संबंधित मेटाडाटा को निर्दिष्ट करने की आवश्यकता नहीं है, न ही यह जांचता है कि डेटा cdm \\_data \\_type से मेल खाता है। यह शायद निकट भविष्य में बदल जाएगा।
    * EDDTable एक कठोर तरीके से cdm \\_data \\_type का उपयोग करता है, CDM के बजाय CF के DSG विनिर्देशन का पालन करता है, जो कुछ कारणों से DSG के अनुरूप होने के लिए अद्यतन नहीं किया गया है। यदि डेटासेट का मेटाडाटा अनुपालन नहीं करता है ERDDAP 's cdm \\_data \\_type' आवश्यकताओं (नीचे देखें) डेटासेट लोड करने में विफल हो जाएगा और एक उत्पन्न करेगा [त्रुटि संदेश](#troubleshooting-tips) । (यह एक अच्छी बात है, इस अर्थ में कि त्रुटि संदेश आपको बता देगा कि क्या गलत है ताकि आप इसे ठीक कर सकें।) अगर डेटासेट का डेटा डेटासेट के मेटाडाटा सेटअप से मेल नहीं खाता है (उदाहरण के लिए, यदि किसी व्यक्ति के डेटासेट में दिए गए स्टेशन के लिए एक से अधिक अक्षांश मान है) डेटा के लिए कुछ अनुरोध प्रतिक्रिया में गलत डेटा वापस आ जाएंगे। इसलिए सुनिश्चित करें कि आपको यह सब सही है।
        
इन सभी डेटासेटों के लिए, सम्मेलनों में और Metadata\\_Conventions वैश्विक गुण, कृपया CF-1.6 देखें (नहीं CF-1.0, 1.1, 1.2, 1.3, 1.4, या 1.5) , CF-1.6 के बाद से डिस्क्रेटे सैम्पलिंग ज्यामिति से संबंधित परिवर्तनों को शामिल करने वाला पहला संस्करण है (DSG) सम्मेलन।
        *   ** ERDDAP™ CF DSG के लिए कोई सरल संबंध नहीं है** 
        *    ERDDAP™ एक स्रोत डेटासेट से एक मान्य DSG डेटासेट बना सकता है जो पहले से ही एक वैध DSG फ़ाइल है (s) एक स्रोत डेटासेट से बाहर, जो DSG के लिए सेट नहीं है लेकिन मेटाडाटा में बदलाव के माध्यम से बनाया जा सकता है। (जिनमें से कुछ हैं ERDDAP डीएसजी सेटअप को निर्दिष्ट करने के लिए अधिक सामान्य दृष्टिकोण प्रदान करने के लिए विशिष्ट) ।
        *    ERDDAP™ जब यह डेटासेट लोड करता है तो कई वैधता परीक्षण करता है। यदि डेटासेट में cdm \\_data\\_type है (या featureType ) विशेषता सफलतापूर्वक लोड ERDDAP™ फिर ERDDAP™ यह कह रहा है कि डेटासेट DSG आवश्यकताओं को पूरा करता है (अन्यथा, ERDDAP™ यह पहली समस्या है कि यह पाया समझा एक अपवाद फेंक देंगे) ।
चेतावनी: एक सफलतापूर्वक लोड डेटासेट DSG आवश्यकताओं को पूरा करने के लिए प्रकट होता है (इसमें विशेषताओं का सही संयोजन है) लेकिन अभी भी गलत तरीके से स्थापित किया जा सकता है, जिससे गलत परिणाम हो सकते हैं .nc CF और CF .nc CFMA प्रतिक्रिया फ़ाइलों। (सॉफ्टवेयर कुछ मायनों में स्मार्ट है और दूसरों में clueless है।) 
        * जब आप डेटासेट के मेटाडाटा को देखते हैं ERDDAP™ , DSG डेटासेट में दिखाई देता है ERDDAP आंतरिक स्वरूप (एक विशाल, डेटाबेस की तरह तालिका) । यह DSG प्रारूपों में से एक में नहीं है (उदाहरण के लिए, आयाम और मेटाडाटा सही नहीं है) लेकिन डेटासेट को DSG डेटासेट के रूप में इलाज के लिए आवश्यक जानकारी मेटाडाटा में है (उदाहरण के लिए, cdm \\_data \\_type = TimeSeries और cdm \\_timeseries \\_variables= *ACsvListOfStationRelatedVarables* वैश्विक मेटाडाटा और cf \\_role = timeseries \\_id में कुछ चर के लिए) ।
        * यदि कोई उपयोगकर्ता डेटासेट की एक सबसेट का अनुरोध करता है .nc CF (एक .nc DSG की Contiguous Ragged Array फ़ाइल प्रारूप में फ़ाइल) या .nc CFMA फ़ाइल (a .nc DSG की बहुआयामी सरणी फ़ाइल प्रारूप में फ़ाइल) यह फ़ाइल एक वैध CF DSG फ़ाइल होगी।
हालांकि, अगर डेटासेट को गलत तरीके से स्थापित किया गया था (इसलिए कि मेटाडाटा द्वारा किए गए वादे सच नहीं हैं) फिर जवाब फ़ाइल तकनीकी रूप से मान्य होगी लेकिन कुछ तरीके से गलत होगा।
             
###### EDDTable cdm_data_types
* EDDTable डेटासेट के लिए, cdm \\_data \\_type विकल्प (और संबंधित आवश्यकताओं में ERDDAP ) हैं
###### अंक{#point} 
*    [अंक](#point) -- असंबंधित समय और स्थानों पर किए गए मापों के एक सेट के लिए है।
    * अन्य के अलावा अन्य सभी cdm \\_data \\_types के साथ, पॉइंट डेटासेट्स MUST में देशांतर, अक्षांश और समय चर है।
###### प्रोफ़ाइल{#profile} 
*    [प्रोफ़ाइल](#profile) - सभी एक समय में लिया माप का एक सेट है, एक अक्षांश देशांतर स्थान पर, लेकिन एक से अधिक गहराई पर (या ऊंचाई) । डेटासेट इन प्रोफाइल का एक संग्रह हो सकता है, उदाहरण के लिए, विभिन्न स्थानों से 7 प्रोफाइल। यह cdm \\_data \\_type किसी भी प्रोफाइल के बीच कोई तार्किक संबंध नहीं है।
    
* चर में से एक (उदाहरण के लिए, प्रोफाइल \number) MUST में चर विशेषता cf \\_role=profile \\_id है जो वेरिएबल की पहचान करने के लिए विशिष्ट रूप से प्रोफाइल की पहचान करता है।
    ```
    <att name="cf\\_role">profile\\_id</att>  
    ```
यदि कोई अन्य चर उपयुक्त नहीं है, तो समय चर का उपयोग करने पर विचार करें।
###### cdm \\_profile \\_variables{#cdm_profile_variables} 
* डेटासेट MUST में वैश्विक योगदान शामिल है [cdm \\_profile \\_variables](#cdm_profile_variables) जहां मूल्य उन चरों की एक अल्पसंख्यक सूची है जिनमें प्रत्येक प्रोफ़ाइल के बारे में जानकारी है। किसी दिए गए प्रोफाइल के लिए, इन चरों के मूल्यों को स्थिर किया जाना चाहिए। उदाहरण के लिए,
    ```
    <att name="cdm\\_profile\\_variables">profile\\_number,time,latitude,longitude</att>
    ```
MUST सूची में Cf \\_role = प्रोफाइल \\_id चर और प्रोफ़ाइल, और समय, अक्षांश और देशांतर के बारे में जानकारी के साथ अन्य सभी चर शामिल हैं।
सूची में कभी ऊंचाई, गहराई या किसी भी अवलोकन चर शामिल नहीं होंगे।
     

 \\[ राय: cdm \\_data \\_type = प्रोफाइल शायद ही कभी इस्तेमाल किया जाना चाहिए। व्यवहार में, एक दिए गए डेटासेट आमतौर पर वास्तव में एक टाइमसीरीजप्रोफाइल है (एक निश्चित स्थिति में प्रोफाइल) या एक TrajectoryProfile (एक trajectory के साथ प्रोफाइल) इसलिए इसे ठीक से पहचाना जाना चाहिए। \\]   
###### समयसीमा{#timeseries} 
*    [समयसीमा](#timeseries) -- माप का एक अनुक्रम है (उदाहरण के लिए, समुद्री जल तापमान) एक पर लिया, तय, अक्षांश, देशांतर, गहराई (या ऊंचाई) स्थान (इसे "स्टेशन" कहते हैं।) डेटासेट इन टाइम सीरीज़ का एक संग्रह हो सकता है, उदाहरण के लिए, प्रत्येक 3 अलग-अलग स्थानों से एक अनुक्रम।
    * चर में से एक (उदाहरण के लिए, स्टेशन_id) MUST में परिवर्तनीय विशेषता cf \\_role = timeseries \\_id है ताकि वेरिएबल की पहचान की जा सके जो विशिष्ट रूप से स्टेशनों की पहचान करती है।
        ```
        <att name="cf\\_role">timeseries\\_id</att>
        ```
###### cdm \\_timeseries \\_variables{#cdm_timeseries_variables} 
* डेटासेट MUST में वैश्विक योगदान शामिल है [cdm \\_timeseries \\_variables](#cdm_timeseries_variables) जहां मूल्य प्रत्येक स्टेशन के बारे में जानकारी रखने वाले चर की अल्पविराम-अलग सूची है। किसी दिए गए स्टेशन के लिए, इन चरों के मूल्य MUST स्थिर हो सकते हैं। उदाहरण के लिए,
    ```
    <att name="cdm\\_timeseries\\_variables">station\\_id,station\\_type,latitude,longitude</att>
    ```
MUST सूची में Cf \\_role = timeseries \\_id चर और स्टेशन के बारे में जानकारी के साथ अन्य सभी चर शामिल हैं, जिसमें लगभग हमेशा अक्षांश और देशांतर शामिल होता है। (और ऊंचाई या गहराई) ।
सूची में कभी भी समय या किसी भी अवलोकन चर शामिल नहीं होंगे।
* कुछ moored buoys के लिए, एक डेटासेट में अक्षांश और देशांतर चर के दो सेट हो सकते हैं:
    1. अक्षांश और देशांतर मानों की एक जोड़ी जो स्थिर हैं (यानी, मूरिंग का निश्चित स्थान) । में ERDDAP™ इन चरों को देना destinationName अक्षांश और देशांतर के s, और cdm \\_timeseries \\_variables की सूची में इन चरों को शामिल करते हैं।
    2. प्रत्येक अवलोकन के साथ जुड़े सटीक अक्षांश और देशांतर मान। में ERDDAP™ इन चरों को अलग-अलग देना destinationName s (उदाहरण के लिए, सटीकलाट और सटीक लोन) और इन चरों को सीडीएम \\_timeseries \\_variables की सूची में शामिल नहीं है।
इसके लिए तर्क है: एक सैद्धांतिक परिप्रेक्ष्य से, एक DSG TimeSeries डेटासेट, अक्षांश और देशांतर के लिए (और ऊंचाई या गहराई) स्टेशन का स्थान MUST स्थिर है।
###### TimeSeriesProfile{#timeseriesprofile} 
*    [TimeSeriesProfile](#timeseriesprofile) -- एक, निश्चित, अक्षांश देशांतर स्थान पर लिए गए प्रोफाइल के अनुक्रम के लिए है। प्रत्येक प्रोफ़ाइल कई ऊंचाई या गहराई पर लिया माप का एक सेट है। डेटासेट इन टाइमसीरीजप्रोफाइल्स का एक संग्रह हो सकता है, उदाहरण के लिए, प्रत्येक 12 विभिन्न स्थानों पर लिए गए प्रोफाइल का अनुक्रम।
    * चर में से एक (उदाहरण के लिए, स्टेशन_id) MUST में परिवर्तनीय विशेषता cf \\_role = timeseries \\_id है ताकि वेरिएबल की पहचान की जा सके जो विशिष्ट रूप से स्टेशनों की पहचान करती है।
    ```
        <att name="cf\\_role">timeseries\\_id</att>
    ```
    * चर में से एक (उदाहरण के लिए, प्रोफाइल \number) MUST में चर विशेषता cf \\_role=profile \\_id है जो वेरिएबल की पहचान करने के लिए विशिष्ट रूप से प्रोफाइल की पहचान करता है।
        ```
        <att name="cf\\_role">profile\\_id</att>  
        ```
         (एक दिए गए प्रोफाइल \\_id को केवल एक दिए गए टाइमरीज़ \\_id के लिए अद्वितीय होना चाहिए।) यदि कोई अन्य चर उपयुक्त नहीं है, तो समय चर का उपयोग करने पर विचार करें।
    * Dataset MUST में वैश्विकAttribute cdm\\_timeseries\\_variables शामिल हैं, जहां मान प्रत्येक स्टेशन के बारे में जानकारी रखने वाले वेरिएबल्स की अल्पसंख्यक सूची है। किसी दिए गए स्टेशन के लिए, इन चरों के मूल्य MUST स्थिर हो सकते हैं। उदाहरण के लिए,
        ```
        <att name="cdm\\_timeseries\\_variables">station\\_id,station\\_type,latitude,longitude</att>
        ```
MUST सूची में Cf \\_role = timeseries \\_id चर और स्टेशन के बारे में जानकारी के साथ अन्य सभी चर शामिल हैं, जिसमें लगभग हमेशा अक्षांश और देशांतर शामिल होता है।
सूची में कभी समय, ऊंचाई, गहराई या किसी भी अवलोकन चर शामिल नहीं होंगे।
    * Dataset MUST में वैश्विकAttribute cdm \\_profile \\_variables शामिल हैं, जहां मूल्य उन चरों की एक Coma-separated सूची है जिनकी प्रत्येक प्रोफ़ाइल के बारे में जानकारी है। किसी दिए गए प्रोफाइल के लिए, इन चरों के मूल्यों को स्थिर किया जाना चाहिए। उदाहरण के लिए,
        ```
        <att name="cdm\\_profile\\_variables">profile\\_number,time</att>
        ```
MUST सूची में Cf \\_role = प्रोफाइल \\_id चर और प्रोफ़ाइल के बारे में जानकारी के साथ अन्य सभी चर शामिल हैं, जिसमें लगभग हमेशा समय शामिल होता है।
सूची में कभी अक्षांश, देशांतर, ऊंचाई, गहराई या किसी भी अवलोकन चर शामिल नहीं होंगे।
###### बेदखलदार{#trajectory} 
*    [बेदखलदार](#trajectory) - एक trajectory के साथ लिया माप का एक अनुक्रम है (अंतरिक्ष और समय के माध्यम से एक पथ)   (उदाहरण के लिए, समुद्र \\_water \\_ताप एक जहाज द्वारा लिया क्योंकि यह पानी के माध्यम से चलता है) । डेटासेट इन ट्रेजेक्टरियों का एक संग्रह हो सकता है, उदाहरण के लिए, प्रत्येक 4 अलग जहाजों से एक अनुक्रम।
    * चर में से एक (उदाहरण के लिए, जहाज \\_id) MUST विशेषता cf \\_role = trajectory \\_id है कि अद्वितीय trajectories की पहचान करने के लिए।
        ```  
        <att name="cf\\_role">trajectory\\_id</att>
        ```
###### cdm \\_trajectory \\_variables{#cdm_trajectory_variables} 
* डेटासेट MUST में वैश्विक योगदान शामिल है [cdm \\_trajectory \\_variables](#cdm_trajectory_variables) जहां मूल्य उन चरों की एक अल्पसंख्यक सूची है जिनके पास प्रत्येक ट्रेजेक्टरी के बारे में जानकारी है। किसी दिए गए प्रक्षेपवक्र के लिए, इन चरों के मूल्यों को स्थिर किया जाना चाहिए। उदाहरण के लिए,
    ```
    <att name="cdm\\_trajectory\\_variables">ship\\_id,ship\\_type,ship\\_owner</att>
    ```
MUST सूची में Cf \\_role = trajectory \\_id चर और अन्य सभी चर शामिल हैं, जिनमें ट्रेजेक्टरी के बारे में जानकारी है।
सूची में कभी समय, अक्षांश, देशांतर, या किसी भी अवलोकन चर शामिल नहीं होंगे।
###### ट्रेजेक्टरीप्रोफाइल{#trajectoryprofile} 
*    [ट्रेजेक्टरीप्रोफाइल](#trajectoryprofile) -- एक प्रक्षेपवक्र के साथ ली गई प्रोफाइल का एक अनुक्रम है। डेटासेट इन ट्रेजेक्टरीप्रोफाइल्स का एक संग्रह हो सकता है, उदाहरण के लिए, 14 विभिन्न जहाजों द्वारा लिए गए प्रोफाइल का एक अनुक्रम।
    * चर में से एक (उदाहरण के लिए, जहाज \\_id) MUST में परिवर्तनीय विशेषता cf \\_role = trajectory \\_id है जो कि वेरिएबल की पहचान करता है जो विशिष्ट रूप से ट्रेजेक्टरी की पहचान करता है।
        ``` 
        <att name="cf\\_role">trajectory\\_id</att>
        ```
    * चर में से एक (उदाहरण के लिए, प्रोफाइल \number) MUST में चर विशेषता cf \\_role=profile \\_id है जो वेरिएबल की पहचान करने के लिए विशिष्ट रूप से प्रोफाइल की पहचान करता है।
        ```
        <att name="cf\\_role">profile\\_id</att>  
        ```
         (एक दिए गए प्रोफाइल \\_id को केवल एक दिए गए ट्रेजेक्टरी \\_id के लिए अद्वितीय होना चाहिए।) यदि कोई अन्य चर उपयुक्त नहीं है, तो समय चर का उपयोग करने पर विचार करें।
    * Dataset MUST में वैश्विकAttribute cdm\\_trajectory\\_variables शामिल हैं, जहां मूल्य उन चरों की एक अल्पसंख्यक सूची है जिनके पास प्रत्येक trajectory के बारे में जानकारी है। किसी दिए गए प्रक्षेपवक्र के लिए, इन चरों के मूल्यों को स्थिर किया जाना चाहिए। उदाहरण के लिए,
        ```
        <att name="cdm\\_trajectory\\_variables">ship\\_id,ship\\_type,ship\\_owner</att>
        ```
MUST सूची में Cf \\_role = trajectory \\_id चर और अन्य सभी चर शामिल हैं, जिनमें ट्रेजेक्टरी के बारे में जानकारी है।
सूची में कभी प्रोफ़ाइल से संबंधित चर, समय, अक्षांश, देशांतर, या किसी भी अवलोकन चर शामिल नहीं होंगे।
    * Dataset MUST में वैश्विकAttribute cdm \\_profile \\_variables शामिल हैं, जहां मूल्य उन चरों की एक Coma-separated सूची है जिनकी प्रत्येक प्रोफ़ाइल के बारे में जानकारी है। किसी दिए गए प्रोफाइल के लिए, इन चरों के मूल्यों को स्थिर किया जाना चाहिए। उदाहरण के लिए,
        ```
        <att name="cdm\\_profile\\_variables">profile\\_number,time,latitude,longitude</att>
        ```
MUST सूची में Cf \\_role = प्रोफाइल \\_id चर और प्रोफ़ाइल के बारे में जानकारी के साथ अन्य सभी चर शामिल हैं, जिसमें लगभग हमेशा समय, अक्षांश और देशांतर शामिल हैं।
सूची में कभी ऊंचाई, गहराई या किसी भी अवलोकन चर शामिल नहीं होंगे।
###### अन्य{#other} 
*    [अन्य](#other) -- कोई आवश्यकता नहीं है। इसका उपयोग अगर डेटासेट दूसरे विकल्पों में से एक फिट नहीं है, खासकर अगर डेटासेट में अक्षांश, देशांतर और समय चर शामिल नहीं है।
     
###### संबंधित नोट्स{#related-notes} 
* सभी EDDTable डेटासेट एक cdm \\_data\\_type के साथ "अन्य" MUST के अलावा देशांतर, अक्षांश और समय चर है।
* प्रोफाइल के साथ डेटासेट MUST में एक ऊंचाई परिवर्तनीय, एक गहराई परिवर्तनीय या एक है [cdm \\_altitude \\_proxy](#cdm_altitude_proxy) चर।
* यदि आप डेटासेट नहीं बना सकते हैं तो आदर्श cdm \\_data \\_type के लिए सभी आवश्यकताओं का पालन करें, "Point" का उपयोग करें। (जिसमें कुछ आवश्यकताएं हैं) या "अन्य" (जिसकी कोई आवश्यकता नहीं है) इसके बजाय।
* इस जानकारी का उपयोग करके किया जाता है ERDDAP™ विभिन्न तरीकों से, उदाहरण के लिए, लेकिन ज्यादातर बनाने के लिए .nc CF फ़ाइलें ( .nc फाइलें जो डेटासेट के सीडीएम \\_data\\_type से जुड़े Contiguous Ragged Array प्रतिनिधित्व का अनुपालन करती हैं) और .nc CFMA फ़ाइलें ( .nc फ़ाइल जो डेटासेट के सीडीएम \\_data\\_type से जुड़े बहुआयामी ऐरे प्रतिनिधित्व का अनुपालन करती है) में परिभाषित [Discrete Sampling Geometries (DSG) ](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries) अध्याय [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) मेटाडाटा सम्मेलन, जिसे पहले "सीएफ प्वाइंट अवलोकन सम्मेलन" नाम दिया गया था।
* Hint: इन डेटासेट के लिए सही सेटिंग [ subsetVariables ](#subsetvariables) आमतौर पर cdm \\__variables विशेषताओं में सूचीबद्ध सभी चरों का संयोजन होता है। उदाहरण के लिए, TimeSeriesProfile के लिए, cdm \\_timeseries \\_variables प्लस cdm \\_profile \\_variables का उपयोग करें।
######  contributor\\_name  {#contributor_name} 
*    [ ** contributor\\_name ** ](#contributor_name)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) एक व्यक्ति, संगठन या परियोजना की पहचान करने का तरीका है जो इस डेटासेट में योगदान देता है (उदाहरण के लिए, डेटा के मूल निर्माता, इससे पहले कि इसे इस डेटासेट के निर्माता द्वारा फिर से संसाधित किया गया था) । उदाहरण के लिए,
    ```
        <att name="contributor\\_name">NOAA OceanWatch - Central Pacific</att>  
    ```
यदि "contributor" वास्तव में डेटासेट पर लागू नहीं होता है, तो इस विशेषता को छोड़ दें। तुलना में [ creator\\_name ](#creator_name) यह कभी-कभी फंडिंग स्रोत पर केंद्रित होता है।
######  contributor\\_role  {#contributor_role} 
*    [ ** contributor\\_role ** ](#contributor_role)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) की भूमिका की पहचान करने का तरीका है [ contributor\\_name ](#creator_name) । उदाहरण के लिए,
    ```
        <att name="contributor\\_role">Source of Level 2b data</att>  
    ```
यदि "contributor" वास्तव में डेटासेट पर लागू नहीं होता है, तो इस विशेषता को छोड़ दें।
###### सम्मेलन{#conventions} 
*    [ **सम्मेलन** ](#conventions)   (से [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) मेटाडाटा मानक) पूरी तरह से अनुशंसा की जाती है। (यह भविष्य में आवश्यक हो सकता है।) मान मेटाडाटा मानकों की एक अल्पविराम-अलग सूची है जो इस डेटासेट का अनुसरण करती है। उदाहरण के लिए:
    ```
    <att name="Conventions">COARDS, CF-1.6, ACDD-1.3</att>  
    ```
आम मेटाडाटा सम्मेलनों में इस्तेमाल किया ERDDAP™ हैं:
    
    *    [ COARDS सम्मेलन](https://ferret.pmel.noaa.gov/noaa_coop/coop_cdf_profile.html) CF के पूर्ववर्ती है।
    *    [जलवायु और पूर्वानुमान (CF) सम्मेलन](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) में कई अनुशंसित और आवश्यक विशेषताओं का स्रोत है ERDDAP । CF का वर्तमान संस्करण "CF-1.6" के रूप में पहचाना जाता है।
    * The The most of the NetCDF डेटासेट डिस्कवरी के लिए योगदान सम्मेलन (एसीडी) में कई अनुशंसित और आवश्यक विशेषताओं का स्रोत है ERDDAP । ACDD का मूल 1.0 संस्करण (एथेन डेविस द्वारा काम का एक शानदार टुकड़ा) , के रूप में पहचाना गया था [ Unidata Dataset डिस्कवरी v1.0](https://wiki.esipfed.org/ArchivalCopyOfVersion1) वर्तमान (2015 में शुरू) ACDD का 1.3 संस्करण पहचाना जाता है [ACDD-1.3](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) । यदि आपके डेटासेट का उपयोग किया गया है Unidata डेटासेट डिस्कवरी v1.0, हम आपको प्रोत्साहित करते हैं [ACDD-1.3 का उपयोग करने के लिए अपने डेटासेट को स्विच करें](#switch-to-acdd-13) ।
    
यदि आपका डेटासेट कुछ अतिरिक्त मेटाडाटा मानक का अनुसरण करता है, तो कृपया कन्वेंशन्स विशेषता में CSV सूची में नाम जोड़ें।
######  coverage\\_content\\_type  {#coverage_content_type} 
*    [ ** coverage\\_content\\_type ** ](#coverage_content_type)   (से [आईएसओ 19115](https://en.wikipedia.org/wiki/Geospatial_metadata) मेटाडाटा मानक) ग्रिड डेटा के प्रकार की पहचान करने का तरीका है (में EDDGrid डेटासेट) । उदाहरण के लिए,
    ```
    <att name="coverage\\_content\\_type">modelResult</att>  
    ```
एकमात्र अनुमत मान सहायक हैंसूचना, छवि, मॉडलविनियमन, भौतिक मापन (डिफ़ॉल्ट जब ISO 19115 मेटाडाटा उत्पन्न होता है) , गुणवत्तासूचना, संदर्भ सूचना और विषयगत वर्गीकरण। (EDDTable Datasets के लिए इस टैग का उपयोग न करें।)   
######  creator\\_name  {#creator_name} 
*    [ ** creator\\_name ** ](#creator_name)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) व्यक्ति, संगठन या परियोजना की पहचान करने का तरीका है (यदि कोई विशिष्ट व्यक्ति या संगठन नहीं है) निर्माण के लिए जिम्मेदार (या हाल के पुन: प्रसंस्करण) इस डेटा का। उदाहरण के लिए,
    ```
    <att name="creator\\_name">NOAA NMFS SWFSC ERD</att>  
    ```
यदि डेटा को बड़े पैमाने पर पुन: संसाधित किया गया था (उदाहरण के लिए, स्तर 2 से स्तर 3 या 4 से उपग्रह डेटा) , फिर आमतौर पर पुन: प्रसंस्करणकर्ता को निर्माता के रूप में सूचीबद्ध किया जाता है और मूल निर्माता को इसके माध्यम से सूचीबद्ध किया जाता है [ contributor\\_name ](#contributor_name) । तुलना में [परियोजना](#project) , यह अधिक लचीला है, क्योंकि यह किसी व्यक्ति, एक संगठन या एक परियोजना की पहचान कर सकता है।
######  creator\\_email  {#creator_email} 
*    [ ** creator\\_email ** ](#creator_email)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) एक ईमेल पते की पहचान करने का तरीका है (सही ढंग से स्वरूपित) यह निर्माता से संपर्क करने का एक तरीका प्रदान करता है। उदाहरण के लिए,
    ```
    <att name="creator\\_email">erd.data@noaa.gov</att>  
    ```
######  creator\\_url  {#creator_url} 
*    [ ** creator\\_url ** ](#creator_url)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) उस संगठन के लिए एक यूआरएल की पहचान करने का तरीका है जिसने डेटासेट बनाया, या इस डेटासेट के बारे में निर्माता की जानकारी के साथ एक यूआरएल (लेकिन इसका उद्देश्य अधिक है [ infoUrl ](#infourl) ) । उदाहरण के लिए,
    ```
    <att name="creator\\_url">https://www.pfeg.noaa.gov</att>  
    ```
######  date\\_created  {#date_created} 
*    [ ** date\\_created ** ](#date_created)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) उस तारीख की पहचान करने का तरीका है जिस पर डेटा पहले बनाया गया था (उदाहरण के लिए, इस रूप में संसाधित) , ISO 8601 प्रारूप में। उदाहरण के लिए,
    ```
    <att name="date\\_created">2010-01-30</att>  
    ```
यदि डेटा को समय-समय पर डेटासेट में जोड़ा जाता है, तो यह पहली तारीख है कि मूल डेटा उपलब्ध कराया गया था।
######  date\\_modified  {#date_modified} 
*    [ ** date\\_modified ** ](#date_modified)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) उस तारीख की पहचान करने का तरीका है जिस पर डेटा को अंतिम रूप दिया गया था (उदाहरण के लिए, जब कोई त्रुटि तय की गई थी या जब नवीनतम डेटा जोड़ा गया था) , ISO 8601 प्रारूप में। उदाहरण के लिए,
    ```
    <att name="date\\_modified">2012-03-15</att>  
    ```
######  date\\_issued  {#date_issued} 
*    [ ** date\\_issued ** ](#date_issued)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) जिस तारीख पर डेटा पहले दूसरों के लिए उपलब्ध कराया गया था, ISO 8601 प्रारूप में, उदाहरण के लिए, 2012-03-15. उदाहरण के लिए,
    ```
    <att name="date\\_issued">2010-07-30</att>  
    ```
उदाहरण के लिए, डेटासेट में एक हो सकता है [ date\\_created ](#date_created) 2010-01-30 की, लेकिन केवल सार्वजनिक रूप से 2010-07-30 उपलब्ध कराया गया था। date\\_issued आम तौर पर प्रयोग किया जाता है date\\_created और date\\_modified । अगर date\\_issued इसे छोड़कर सामग्री पर बढ़ने के लिए date\\_created ।
###### वैश्विक drawLandMask  {#global-drawlandmask} 
*    [ ** drawLandMask ** ](#global-drawlandmask) -- यह एक वैकल्पिक वैश्विक विशेषता है जिसका उपयोग करके किया जाता है ERDDAP™   (कोई मेटाडाटा मानकों) जो डेटासेट के मेक ए ग्राफ फॉर्म पर "ड्रॉ लैंड मास्क" विकल्प के लिए डिफ़ॉल्ट मान निर्दिष्ट करता है ( * datasetID * ग्राफ़) और एक URL में &.land पैरामीटर के लिए डेटा के नक्शे का अनुरोध करता है। उदाहरण के लिए,
    ```
    <att name="drawLandMask">over</att>  
    ```
देखें [ drawLandMask अवलोकन](#drawlandmask) ।
######  featureType  {#featuretype} 
*    [ ** featureType ** ](#featuretype)   (से [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) मेटाडाटा मानक) IGNORED और / या REPLACED है। यदि डेटासेट है [cdm \\_data \\_type](#cdm_data_type) उपयुक्त है, ERDDAP™ इसे बनाने के लिए स्वचालित रूप से उपयोग किया जाएगा featureType विशेषता। इसलिए इसे जोड़ने की कोई आवश्यकता नहीं है।
    
हालांकि, अगर आप उपयोग कर रहे हैं [EDDTableFromNcCFFiles](#eddtablefromnccffiles) फ़ाइलों से डेटासेट बनाने के लिए जो फाइलों का अनुसरण करते हैं [CF Discrete Sampling Geometries (DSG) मानक](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#discrete-sampling-geometries) , फ़ाइलों को स्वयं होना चाहिए featureType सही ढंग से परिभाषित, ताकि ERDDAP™ फाइलों को सही ढंग से पढ़ सकते हैं। यह उस प्रकार की फ़ाइल के लिए CF DSG आवश्यकताओं का हिस्सा है।
     
###### इतिहास{#history} 
*    [ **इतिहास** ](#history)   (से [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) और [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानकों) प्रत्येक प्रसंस्करण चरण के लिए एक लाइन के साथ एक RECOMMENDED बहु लाइन स्ट्रिंग वैश्विक विशेषता है कि डेटा गुजर रहा है। उदाहरण के लिए,
    ```
    <att name="history">2011-08-05T08:55:02Z CMOR: Rewrote data to comply with CF standards.  
    2012-04-08T08:34:58Z CMOR: Converted 'height' type from 'd' to 'f'.</att>
    ```
    * आदर्श रूप से, प्रत्येक लाइन में ISO 8601:2004 है (E) स्वरूपित दिनांक + समय (उदाहरण के लिए, 2011-08-05T08:55:02Z) इसके बाद प्रसंस्करण चरण का वर्णन होता है।
    *    ERDDAP™ यदि यह पहले से मौजूद नहीं है तो यह बनाता है।
    * अगर यह पहले से ही मौजूद है, ERDDAP™ मौजूदा जानकारी को नई जानकारी प्रदान करेगा।
    * इतिहास महत्वपूर्ण है क्योंकि यह ग्राहकों को डेटा के मूल स्रोत पर वापस जाने की अनुमति देता है।
######  infoUrl  {#infourl} 
*    [ ** infoUrl ** ](#infourl) इस डेटासेट के बारे में अधिक जानकारी के साथ एक वेब पेज के यूआरएल के साथ एक REQUIRED वैश्विक विशेषता है। (आमतौर पर सोर्स संस्था की वेबसाइट पर) । उदाहरण के लिए,
    ```
    <att name="infoUrl">http://www.globec.org/</att>
    ```
    * या तो डेटासेट वैश्विक [स्रोतAttributes](#global-attributes) वैश्विक&lt; addAttributes &gt; इस विशेषता में शामिल है।
    *    infoUrl क्योंकि यह ग्राहकों को मूल स्रोत से डेटा के बारे में अधिक जानने की अनुमति देता है।
    *    ERDDAP™ एक लिंक प्रदर्शित करता है infoUrl डेटासेट के डेटा एक्सेस फॉर्म पर ( * datasetID * एचटीएमएल) A Graph web page ( * datasetID * ग्राफ़) , और अन्य वेब पेज।
    * यदि URL में क्वेरी पार्ट है (" के बाद?) , यह पहले से ही होना चाहिए [प्रतिशत encoded](https://en.wikipedia.org/wiki/Percent-encoding) । आपको बाधाओं में विशेष वर्णों को कोडित करने की आवश्यकता है (प्रारंभिक '&' और मुख्य के अलावा '=' यदि कोई हो) %HHH के रूप में, जहां HH चरित्र का 2 अंक hexadecimal मान है। आमतौर पर, आपको बस कुछ punctuation अक्षरों को बदलने की आवश्यकता होती है: % में %25, और %26 में, "%22 में,&lt;%3C में =%3D में&gt;%3E में +%2B में, | %7C में \\[ %5B में \\] %5D में,%20 में अंतरिक्ष, और # 127 से ऊपर के सभी पात्रों को अपने UTF-8 फॉर्म में परिवर्तित करें और फिर %HH प्रारूप में UTF-8 फॉर्म के प्रत्येक बाइट को कोडित करें। (मदद के लिए प्रोग्रामर से पूछें) ।
उदाहरण के लिए, & stationID &gt;="41004"
बन गया stationID %3E =%2241004%22
जब आप एक्सेस करते हैं तो पर्सेंट एन्कोडिंग की आवश्यकता होती है ERDDAP एक ब्राउज़र के अलावा अन्य सॉफ्टवेयर के माध्यम से। ब्राउज़र आमतौर पर आपके लिए प्रतिशत एन्कोडिंग संभालते हैं।
कुछ स्थितियों में, आपको A-Za-z0-9\\_-&#33; ' () \\*, लेकिन अभी भी प्रारंभिक '&' या मुख्य कोड नहीं है '=' ।
प्रोग्रामिंग भाषाओं में ऐसा करने के लिए उपकरण हैं (उदाहरण के लिए, देखें Java ' [ java.net.URLEncoder ](https://docs.oracle.com/javase/8/docs/api/java/net/URLEncoder.html)   
और Java स्क्रिप्टencodeURIComponent()] (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) ) और वहाँ रहे हैं
         [उन वेबसाइटों के लिए जो आपके लिए प्रतिशत एनकोड / डीकोड करते हैं](https://www.url-encode-decode.com/) ।
    * चूंकि datasets.xml एक XML फ़ाइल है, आप MUST भी और सभी '&', '&lt;यूआरएल में '&amp;', '&lt;',' और '&gt;' प्रतिशत एन्कोडिंग के बाद।
    *    infoUrl इसके लिए अद्वितीय है ERDDAP । यह किसी भी मेटाडाटा मानक से नहीं है।
###### संस्था{#institution} 
*    [ **संस्था** ](#institution)   (से [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) और [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानकों) एक REQUIRED वैश्विक विशेषता है जिसमें संस्थान के नाम का संक्षिप्त संस्करण है जो इस डेटा का स्रोत है (आमतौर पर एक संक्षिप्त, आमतौर पर आमतौर पर आमतौर पर एक संक्षिप्त शब्द)।&lt;20 वर्ण). उदाहरण के लिए,
    ```
    <att name="institution">NASA GSFC</att>
    ```
    * या तो डेटासेट वैश्विक [स्रोतAttributes](#global-attributes) वैश्विक&lt; addAttributes &gt; इस विशेषता में शामिल है।
    *    ERDDAP™ जब भी यह डेटासेट की सूची प्रदर्शित करता है तो संस्थान प्रदर्शित करता है। यदि यहाँ एक संस्थान का नाम 20 अक्षरों से अधिक लंबा है, तो केवल पहले 20 अक्षर डेटासेट की सूची में दिखाई देंगे। (लेकिन पूरे संस्थान को आसन्न "? आइकन पर माउस कर्सर डालने से देखा जा सकता है) ।
    * यदि आप संस्थान को सूची में जोड़ते हैं&lt; categoryAttributes &gt; में ERDDAP ' [साइटमैप](/docs/server-admin/deploy-install#setupxml) फ़ाइल, उपयोगकर्ता आसानी से उसी संस्थान से डेटासेट पा सकते हैं ERDDAP होम पेज पर "वर्ग द्वारा डेटासेट के लिए खोज"।
###### कीवर्ड{#keywords} 
*    [ **कीवर्ड** ](#keywords)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) Recommended comma-separated list of words and लघु वाक्यांशों (उदाहरण के लिए, [GCMD विज्ञान कीवर्ड](https://wiki.earthdata.nasa.gov/display/CMR/GCMD+Keyword+Access) ) यह एक सामान्य तरीके से डेटासेट का वर्णन करता है और डेटासेट के किसी अन्य ज्ञान को नहीं मानते हैं। (उदाहरण के लिए, महासागरीय डेटा के लिए, महासागर शामिल हैं) । उदाहरण के लिए,
    ```
    <att name="keywords">ano, circulation, coastwatch, currents, derived, Earth Science &gt; Oceans &gt; Ocean Circulation &gt; Ocean Currents, eastward, eastward\\_sea\\_water\\_velocity, experimental, hf radio, meridional, noaa, northward, northward\\_sea\\_water\\_velocity, nuevo, ocean, oceans, radio, radio-derived, scan, sea, seawater, velocity, water, zonal</att>  
    ```
चूंकि datasets.xml एक XML दस्तावेज़ है, वर्ण और,&lt;कीवर्ड की तरह एक विशेषता में (उदाहरण के लिए, GCMD विज्ञान कीवर्ड में &gt; वर्ण) इसे एंडैम्प के रूप में वर्गीकृत किया जाना चाहिए;&lt;क्रमश:, और & gt;
जब डेटासेट में लोड हो जाता है ERDDAP ,
    
    * "Earth science &gt;" को किसी भी GCMD कीवर्ड की शुरुआत में जोड़ा जाता है जिसमें इसकी कमी होती है।
    * GCMD कीवर्ड को टाइटल केस में बदल दिया जाता है (अर्थात्, पहले अक्षरों को पूंजीकृत किया जाता है) ।
    * कीवर्ड क्रमबद्ध क्रम में व्यवस्थित होते हैं और किसी भी नए अक्षर को हटा दिया जाता है।
     
######  keywords\\_vocabulary  {#keywords_vocabulary} 
*    [ ** keywords\\_vocabulary ** ](#keywords_vocabulary)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) एक RECOMMENDED विशेषता है: यदि आप अपने कीवर्ड विशेषता में शब्दों / वाक्यांशों के लिए एक दिशानिर्देश का पालन कर रहे हैं (उदाहरण के लिए, GCMD विज्ञान कीवर्ड) , उस गाइडलाइन का नाम यहां रखें। उदाहरण के लिए,
    ```
    <att name="keywords\\_vocabulary">GCMD Science Keywords</att>  
    ```
###### लाइसेंस{#license} 
*    [ **लाइसेंस** ](#license)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) लाइसेंस और/या उपयोग प्रतिबंधों के साथ एक STRONGLY RECOMMEND वैश्विक विशेषता है। उदाहरण के लिए,
    ```
    <att name="license">\\[standard\\]</att>
    ```
    * यदि \\[ मानक \\] " विशेषता मान में होता है, इसे मानक द्वारा प्रतिस्थापित किया जाएगा ERDDAP™ लाइसेंस&lt;StandardLicense ERDDAP '
         \\[ tomcat \\] / webapps/erddap/WEB-INF/classes/gov/noaa/pfel/erddap/util/message.xml फ़ाइल.
         
######  Metadata\\_Conventions  {#metadata_conventions} 
*    [ ** Metadata\\_Conventions ** ](#metadata_conventions) पुराना [ACDD 1.0](https://wiki.esipfed.org/ArchivalCopyOfVersion1)   (जिसे पहचाना गया था Metadata\\_Conventions जैसा कि " Unidata Dataset डिस्कवरी v1.0) मेटाडाटा मानक। विशेषता मान इस डेटासेट द्वारा उपयोग किए जाने वाले मेटाडाटा सम्मेलनों की एक कॉमा-सेपरेटेड सूची थी।
यदि कोई डेटासेट ACDD 1.0 का उपयोग करता है, तो यह विशेषता STRONGLY RECOMMENDED है, उदाहरण के लिए,
    ```
    <att name="Metadata\\_Conventions">COARDS, CF-1.6, Unidata Dataset Discovery v1.0</att>  
    ```
लेकिन ERDDAP™ अब ACDD-1.3 की सिफारिश करता है। यदि आपके पास है [ACDD-1.3 का उपयोग करने के लिए अपने डेटासेट को स्विच किया](#switch-to-acdd-13) , का उपयोग Metadata\\_Conventions STRONGLY DISCOURAGED: सिर्फ इस्तेमाल किया [[]&lt;सम्मेलनों&gt; (#conventions) इसके बजाय।
######  processing\\_level  {#processing_level} 
*    [ ** processing\\_level ** ](#processing_level)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) प्रसंस्करण का एक RECOMMENDED पाठ्य विवरण है (उदाहरण के लिए, [नासा की पृथ्वी अवलोकन प्रणाली डेटा और सूचना प्रणाली डेटा प्रोसेसिंग स्तर](https://www.earthdata.nasa.gov/learn/earth-observation-data-basics/data-processing-levels) उदाहरण के लिए, लेवल 3) या गुणवत्ता नियंत्रण स्तर (उदाहरण के लिए, विज्ञान गुणवत्ता) डेटा का। उदाहरण के लिए,
    ```
    <att name="processing\\_level">3</att>  
    ```
###### परियोजना{#project} 
*    [ **परियोजना** ](#project)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) यह परियोजना की पहचान करने के लिए एक वैकल्पिक विशेषता है कि डेटासेट का हिस्सा है। उदाहरण के लिए,
    ```
    <att name="project">GTSPP</att>  
    ```
यदि डेटासेट परियोजना का हिस्सा नहीं है, तो इस विशेषता का उपयोग न करें। तुलना में [ creator\\_name ](#creator_name) यह परियोजना पर केंद्रित है (एक व्यक्ति या संगठन नहीं, जो कई परियोजनाओं में शामिल हो सकता है) ।
######  publisher\\_name  {#publisher_name} 
*    [ ** publisher\\_name ** ](#publisher_name)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) व्यक्ति, संगठन या परियोजना की पहचान करने का तरीका है जो इस डेटासेट को प्रकाशित कर रहा है। उदाहरण के लिए,
    ```
    <att name="publisher\\_name">JPL</att>  
    ```
उदाहरण के लिए, आप प्रकाशक हैं अगर किसी अन्य व्यक्ति या समूह [बनाया](#creator_name) डेटासेट ERDDAP । यदि "publisher" वास्तव में डेटासेट पर लागू नहीं होता है, तो इस विशेषता को छोड़ दें। तुलना में [ creator\\_name ](#creator_name) , प्रकाशक शायद डेटा को संशोधित या फिर से संसाधित नहीं किया गया था; प्रकाशक सिर्फ एक नए स्थान पर उपलब्ध डेटा बना रहा है।
######  publisher\\_email  {#publisher_email} 
*    [ ** publisher\\_email ** ](#publisher_email)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) एक ईमेल पते की पहचान करने का तरीका है (सही ढंग से स्वरूपित, उदाहरण के लिए, john \\_smith@great.org) यह प्रकाशक से संपर्क करने का एक तरीका प्रदान करता है। उदाहरण के लिए,
    ```
    <att name="publisher\\_email">john\\_smith@great.org</att>  
    ```
यदि "publisher" वास्तव में डेटासेट पर लागू नहीं होता है, तो इस विशेषता को छोड़ दें।
######  publisher\\_url  {#publisher_url} 
*    [ ** publisher\\_url ** ](#publisher_url)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) उस संगठन के लिए एक URL की पहचान करने का तरीका है जिसने डेटासेट प्रकाशित किया था, या इस डेटासेट के बारे में प्रकाशक की जानकारी के साथ एक URL है। (लेकिन इसका उद्देश्य अधिक है [ infoUrl ](#infourl) ) । उदाहरण के लिए,
    ```
    <att name="publisher\\_url">https://podaac.jpl.nasa.gov</att>  
    ```
यदि "publisher" वास्तव में डेटासेट पर लागू नहीं होता है, तो इस विशेषता को छोड़ दें।
######  real\\_time  {#real_time} 
*    [ ** real\\_time ** ](#real_time) एक वैश्विक स्ट्रिंग विशेषता है (किसी भी मानक से नहीं) यह दर्शाता है कि यह एक वास्तविक समय डेटासेट है। उदाहरण के लिए,
    ```
    <att name="real\\_time">true</att>  
    ```
यदि यह गलत है (डिफ़ॉल्ट) , ERDDAP™ फ़ाइल प्रकारों के लिए अनुरोधों के जवाब कैश करेगा जहां पूरी फ़ाइल पहले बनाई जानी चाहिए ERDDAP™ उपयोगकर्ता को जवाब भेजने के लिए शुरू कर सकते हैं और उन्हें लगभग 15 मिनट तक पुन: उपयोग कर सकते हैं। (उदाहरण के लिए .nc PNG) ।
अगर यह सच है, ERDDAP™ कभी जवाब फ़ाइलों को कैश नहीं करेगा और हमेशा नए बनाए गए फ़ाइलों को वापस कर देगा।
######  sourceUrl विशेषता{#sourceurl-attribute} 
*    [ ** sourceUrl ** ](#sourceurl-attribute) डेटा के स्रोत के यूआरएल के साथ एक वैश्विक विशेषता है। उदाहरण के लिए,
    ```
    <att name="sourceUrl">https://opendap.co-ops.nos.noaa.gov/ioos-dif-sos/SOS</att>  
    ```
     (लेकिन यह सब एक पंक्ति में डाल दिया) 
    *    ERDDAP™ आमतौर पर इस वैश्विक विशेषता को स्वचालित रूप से बनाता है। दो अपवाद EDDTableFrom हैं Hyrax फ़ाइलें और EDDTableFromThreddsFiles।
    * यदि स्रोत स्थानीय फ़ाइल है और फ़ाइल आपके संगठन द्वारा बनाई गई थी, तो उपयोग करें
    ```
        <att name="sourceUrl">(local files)</att>
    ```
    * यदि स्रोत स्थानीय डेटाबेस है और डेटा आपके संगठन द्वारा बनाया गया है, तो उपयोग करें
    ```
        <att name="sourceUrl">(local database)</att>
    ```
    *    sourceUrl यह महत्वपूर्ण है क्योंकि यह ग्राहकों को डेटा के मूल स्रोत पर बैकट्रैक करने की अनुमति देता है।
    *    sourceUrl इसके लिए अद्वितीय है ERDDAP । यह किसी भी मेटाडाटा मानक से नहीं है।
        
######  standard\\_name\\_vocabulary  {#standard_name_vocabulary} 
*    [ ** standard\\_name\\_vocabulary ** ](#standard_name_vocabulary)   (से [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) नियंत्रित शब्दावली के नाम की पहचान करने के लिए एक RECOMMENDED विशेषता है जिसमें से परिवर्तनीय [ standard\\_name ](#standard_name) (s) लिया जाता है। उदाहरण के लिए,
    ```
    <att name="standard\\_name\\_vocabulary">CF Standard Name Table v77</att>  
    ```
संस्करण 77 के लिए [CF मानक नाम तालिका](https://cfconventions.org/Data/cf-standard-names/current/build/cf-standard-name-table.html) ।
         
#####  subsetVariables  {#subsetvariables} 
*    ** subsetVariables **   (केवल EDDTable Datasets के लिए) एक Recommended वैश्विक विशेषता है कि आप की एक comma-separated सूची निर्दिष्ट करने देता है [&lt; dataVariable &gt; (#datavariable)   [ destinationName ](#destinationname) चर की पहचान करने के लिए जिनके पास सीमित संख्या में मान हैं (एक अन्य तरीका कहा गया है: चर जिसके लिए प्रत्येक मान में कई डुप्लिकेट हैं।) । उदाहरण के लिए,
    ```
        <att name="subsetVariables">station\\_id, longitude, latitude</att>  
    ```
यदि यह विशेषता मौजूद है, तो डेटासेट में एक होगा * datasetID * वेब पेज (प्रत्येक डेटासेट सूची में इसके लिए एक लिंक) जो उपयोगकर्ताओं को जल्दी और आसानी से डेटा के विभिन्न सेटों का चयन करने देता है।
    * प्रत्येक बार डेटासेट लोड हो जाता है, ERDDAP डिस्क पर लोड और स्टोर सभी अलग-अलग के साथ एक तालिका है () सबसेट के संयोजन चर के चर मूल्यों। ERDDAP™ पढ़ सकते हैं कि subsetVariables तालिका और यह बहुत जल्दी प्रक्रिया (विशेष रूप से डेटा फ़ाइलों के बहुत सारे पढ़ने या डेटाबेस या अन्य बाहरी सेवा से डेटा प्राप्त करने की तुलना में) ।
    * यह अनुमति देता है ERDDAP™ 3 चीजें करने के लिए:
        1. यह अनुमति देता है ERDDAP™ डेटा एक्सेस फॉर्म पर एक ड्रॉपडाउन सूची में संभावित मूल्यों की एक सूची डालने के लिए, एक ग्राफ वेब पेज बनाएं, और .subset वेबपेज।
        2. यह अनुमति देता है ERDDAP™ उस डेटासेट के लिए एक .subset वेबपेज प्रदान करने के लिए। यह पृष्ठ रोचक है क्योंकि यह उन चरों के मूल्यों के मान्य संयोजनों को ढूंढना आसान बनाता है, जो कुछ डेटासेटों और कुछ चरों के लिए बहुत कठिन है। (लगभग असंभव) । फिर, सभी उपयोगकर्ता विशिष्ट के लिए अनुरोध करता है () सबसेट चर डेटा बहुत तेज होगा।
        3. यदि कोई उपयोगकर्ता अनुरोध है कि केवल उन चरों की एक सबसेट को संदर्भित करता है, ERDDAP™ जल्दी पढ़ सकते हैं subsetVariables तालिका, और अनुरोध का जवाब दें। यह एक टन समय और प्रयास को बचा सकता है ERDDAP ।
    * आदेश destinationName आप निर्दिष्ट करते हैं, जिस पर क्रमबद्ध क्रम निर्धारित करता है * datasetID * इसलिए आप आमतौर पर सबसे महत्वपूर्ण चर पहले निर्दिष्ट करेंगे, फिर कम से कम महत्वपूर्ण। उदाहरण के लिए, कई स्टेशनों के लिए समय श्रृंखला डेटा के साथ डेटासेट के लिए, आप उपयोग कर सकते हैं, उदाहरण के लिए,
        ```
            <att name="subsetVariables">station\\_id, longitude, latitude</att>  
        ```
ताकि मूल्यों को स्टेशन \\_id द्वारा क्रमबद्ध किया जा सके।
    * जाहिर है, यह आपकी पसंद है जो चर में शामिल होने के लिए है subsetVariables सूची, लेकिन सुझाव दिया उपयोग है:
        
सामान्य तौर पर, वेरिएबल्स शामिल हैं जिसके लिए आप चाहते हैं ERDDAP™ डेटासेट के डेटा एक्सेस फॉर्म पर विकल्पों की एक ड्रॉप-डाउन सूची प्रदर्शित करने के लिए (एचटीएमएल) मेक-ए-ग्राफ (ग्राफ़) वेब पेज
        
सामान्य तौर पर, डेटासेट की विशेषताओं के बारे में जानकारी के साथ चर शामिल करें (विशेष रूप से स्टेशनों, प्रोफाइल और/या प्रक्षेपवक्रों से [cdm \\_timeseries \\_variables](#cdm_timeseries_variables) , [cdm \\_profile \\_variables](#cdm_profile_variables) , [cdm \\_trajectory \\_variables](#cdm_trajectory_variables) ) । इन चरों के लिए केवल कुछ अलग-अलग मान हैं, इसलिए वे ड्रॉप-डाउन सूचियों के साथ अच्छी तरह से काम करते हैं।
        
कभी भी व्यक्तिगत टिप्पणियों से जुड़े किसी भी डेटा चर को शामिल न करें (उदाहरण के लिए, समय, तापमान, लवणता, वर्तमान गति) में subsetVariables सूची इन चरों के लिए कई अलग-अलग मान हैं, इसलिए एक ड्रॉप-डाउन सूची लोड करने में धीमा होगी और साथ में काम करना कठिन होगा। (नहीं) ।
        
    * यदि इन चरों के विशिष्ट संयोजनों की संख्या लगभग 1,000,000 से अधिक है, तो आपको प्रतिबंधित करने पर विचार करना चाहिए subsetVariables कि आप 1,000,000 से नीचे अलग संयोजनों की संख्या को कम करने के लिए निर्दिष्ट; अन्यथा, * datasetID * वेब पृष्ठों को धीरे से उत्पन्न किया जा सकता है। अत्यधिक मामलों में, डेटासेट में लोड नहीं हो सकता है ERDDAP™ क्योंकि अलग संयोजनों की सूची पैदा करने के लिए बहुत ज्यादा स्मृति का उपयोग करता है। यदि हां, तो आप कुछ चरों को हटा सकते हैं subsetVariables सूची
    * यदि किसी एक सबसेट चर के विशिष्ट मानों की संख्या लगभग 20,000 से अधिक है, तो आपको उस परिवर्तनीय को सूची में शामिल नहीं करना चाहिए subsetVariables अन्यथा, यह संचारित करने के लिए लंबे समय तक लेता है * datasetID * सबसेट * datasetID * ग्राफ़, और * datasetID * HTML वेब पेज इसके अलावा, मैक पर, स्क्रॉल बार की कमी के कारण 500 से अधिक वस्तुओं के साथ ड्रॉप डाउन सूची से चयन करना बहुत मुश्किल है। एक समझौता है: सूची से चर को हटा दें जब उपयोगकर्ता ड्रॉप डाउन सूची से मान चुनने की संभावना नहीं रखते हैं।
    * आपको यह देखने के लिए प्रत्येक डेटासेट का परीक्षण करना चाहिए कि क्या है? subsetVariables सेटिंग ठीक है। यदि स्रोत डेटा सर्वर धीमा है और यह बहुत लंबा लगता है (या विफल) डेटा डाउनलोड करने के लिए, या तो निर्दिष्ट चर की संख्या को कम करें या हटा दें subsetVariables वैश्विक विशेषता।
    * सबसेट चर बहुत उपयोगी है। यदि आपका डेटासेट उपयुक्त है, तो कृपया एक बनाएं subsetVariables विशेषता।
    * EDDTableFrom SOS स्वचालित रूप से जोड़ता है
        ```
            <att name="subsetVariables">station\\_id, longitude, latitude</att>  
        ```
जब डेटासेट बनाया जाता है।
        * संभावित चेतावनी: यदि उपयोगकर्ता का उपयोग करना * datasetID * सबसेट वेब पेज एक मूल्य का चयन करता है जिसमें एक कैरिज रिटर्न या न्यूलाइन कैरेक्टर होता है, * datasetID * सबसेट विफल हो जाएगा। ERDDAP™ कुछ HTML विवरणों के कारण इस मुद्दे के आसपास काम नहीं कर सकते। किसी भी मामले में, डेटा से कैरिज रिटर्न और न्यूलाइन वर्णों को हटाने के लिए लगभग हमेशा एक अच्छा विचार है। यदि आप EDDTable समस्या को ठीक करने में मदद करते हैं। subsetVariables में DataTable विधि ERDDAP डेटा मानों का पता लगाता है जो परेशानी पैदा करेगा, यह ईमेल को ऑफेंड मूल्यों की सूची के साथ एक चेतावनी ईमेल करेगा सब कुछ सेटअप.xml में निर्दिष्ट ईमेल पते के लिए। इस तरह, आप जानते हैं कि क्या तय किया जाना चाहिए।
        *    **पूर्व निर्मित सबसेट टेबल।** आम तौर पर, जब ERDDAP™ डेटासेट लोड करता है, यह विशिष्ट अनुरोध करता है () डेटा स्रोत से सबसेट चर डेटा तालिका, सिर्फ एक सामान्य डेटा अनुरोध के माध्यम से। कुछ मामलों में, यह डेटा डेटा स्रोत से उपलब्ध नहीं है या डेटा स्रोत से प्राप्त डेटा स्रोत सर्वर पर कठिन हो सकता है। यदि हां, तो आप एक तालिका की आपूर्ति कर सकते हैं जिसमें जानकारी एक में शामिल है। .json या नाम के साथ .csv फ़ाइल *tomcat* /content/erddap/subset/ * datasetID *  .json   (या .csv) । यदि उपस्थित हो, ERDDAP™ जब डेटासेट लोड हो जाता है और इसे सबसेट डेटा के स्रोत के रूप में उपयोग किया जाता है तो इसे एक बार पढ़ा जाएगा।
            * यदि इसे पढ़ने में त्रुटि होती है तो डेटासेट लोड होने में विफल हो जाएगा।
            * यह MUST सटीक समान स्तंभ नाम है (उदाहरण के लिए, समान मामला) जैसा&lt; subsetVariables &gt;, लेकिन कॉलम किसी भी क्रम में हो सकता है।
            * यह MAY में अतिरिक्त कॉलम हैं (उन्हें हटा दिया जाएगा और नव अनावश्यक पंक्तियों को हटा दिया जाएगा) ।
            * मिसिंग मान लापता मान होना चाहिए (नहीं -99) ।
            *    .json फ़ाइलों को बनाने के लिए थोड़ा कठिन हो सकता है लेकिन यूनिकोड वर्णों के साथ अच्छी तरह से सौदा किया जा सकता है। .json यदि आप उन्हें बनाने के लिए फ़ाइलों को बनाना आसान है ERDDAP ।
            * .csv फ़ाइलों के साथ काम करना आसान है, लेकिन केवल ISO 8859-1 वर्णों के लिए उपयुक्त है। .csv फाइलें MUST में पहली पंक्ति और बाद की पंक्तियों पर डेटा पर कॉलम नाम हैं।
        * विशाल डेटासेट के लिए या जब&lt; subsetVariables &gt; गलत विन्यास किया जाता है, मानों के संयोजन की तालिका बहुत बड़ी हो सकती है, जिससे बहुत ज्यादा डेटा या OutOfMemory त्रुटियों का कारण बन सकता है। समाधान की सूची से चर को हटाने के लिए है&lt; subsetVariables &gt; जिसके लिए वहाँ मूल्यों की एक बड़ी संख्या हैं, या उस तालिका के आकार उचित होने तक आवश्यकतानुसार चर को हटा दें। त्रुटि के बावजूद, त्रुटि के कुछ हिस्सों ERDDAP™ कि उपयोग subsetVariables प्रणाली अच्छी तरह से काम नहीं करती (उदाहरण के लिए, वेब पेज बहुत धीरे-धीरे लोड होते हैं) जब बहुत अधिक पंक्तियां होती हैं (उदाहरण के लिए, मिलियन से अधिक) उस तालिका में।
        *    subsetVariables यह निर्दिष्ट करने के लिए कुछ भी नहीं है कि कौन से परिवर्तनीय उपयोगकर्ता बाधाओं में उपयोग कर सकते हैं, यानी उपयोगकर्ता डेटासेट के उप सेट का अनुरोध कैसे कर सकते हैं। ERDDAP™ हमेशा बाधाओं को किसी भी चर को संदर्भित करने की अनुमति देता है।
###### टाइम यूनिट{#time-units} 
 [टाइम और टाइमस्टैम्प](#time-units) कॉलम में ISO 8601:2004 होना चाहिए (E) स्वरूपित दिनांक + समय जेड स्ट्रिंग्स (उदाहरण के लिए, 1985-01-31T15:31:00Z) ।
             
###### सारांश{#summary} 
*    [ **सारांश** ](#summary)   (से [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) और [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानकों) डेटासेट के लंबे विवरण के साथ एक REQUIRED वैश्विक विशेषता है (आमतौर पर)&lt;500 वर्ण). उदाहरण के लिए,
    ```
    <att name="summary">VIIRSN Level-3 Standard Mapped Image, Global, 4km, Chlorophyll a, Daily. The Visible and Infrared Imager/Radiometer Suite (VIIRS) is a multi-disciplinary instrument that flies on the National Polar-orbiting Operational Environmental Satellite System (NPOESS) series of spacecraft, including the NPOESS Preparatory Project (NPP).</att>
    ```
    * या तो डेटासेट वैश्विक [स्रोतAttributes](#global-attributes) वैश्विक&lt; addAttributes &gt; इस विशेषता में शामिल है।
    * सारांश बहुत महत्वपूर्ण है क्योंकि यह ग्राहकों को डेटासेट का वर्णन पढ़ने की अनुमति देता है जिसमें शीर्षक की तुलना में अधिक जानकारी होती है और इस प्रकार जल्दी से यह समझने की कोशिश करता है कि डेटासेट क्या है।
    * सलाह: कृपया सारांश लिखें ताकि यह कुछ यादृच्छिक व्यक्ति को डेटासेट का वर्णन करने के लिए काम करेगा जो आप सड़क पर या एक सहयोगी से मिलते हैं। पढ़ना [पांच डब्ल्यू और एक एच](https://en.wikipedia.org/wiki/Five_Ws) कौन डेटासेट बनाया? क्या जानकारी एकत्र की गई थी? जब डेटा एकत्र किया गया था? यह कहाँ एकत्र किया गया था? यह क्यों एकत्र किया गया था? यह कैसे एकत्र किया गया था?
    *    ERDDAP™ डेटासेट के डेटा एक्सेस फॉर्म पर सारांश प्रदर्शित करता है ( * datasetID * एचटीएमएल) A Graph web page ( * datasetID * ग्राफ़) , और अन्य वेब पेज। ERDDAP™ FGDC और ISO 19115 दस्तावेजों को बनाते समय सारांश का उपयोग करता है।
######  testOutOfDate  {#testoutofdate} 
*    [ ** testOutOfDate ** ](#testoutofdate)   (वैकल्पिक ERDDAP -विशिष्ट वैश्विक मेटाडाटा विशेषता, किसी भी मानक से नहीं) निर्दिष्ट करता है, सरल तरीके से, जब निकट-वास्तविक समय डेटासेट के लिए डेटा को आउट-ऑफ-डेट माना जाता है, जैसा कि निर्दिष्ट किया गया है now-  *n* उदाहरण के लिए, now- डेटा के लिए 2 दिन जो आमतौर पर टाइम वैल्यू के 24-48 घंटे बाद दिखाई देते हैं। पूर्वानुमान डेटा के लिए, अब उपयोग करें **+**  *n* उदाहरण के लिए, भविष्य में 8 दिनों में, भविष्य में पूर्वानुमान डेटा के लिए अब + 6 दिन। (देखें [ now-  *n* वाक्यविन्यास](https://coastwatch.pfeg.noaa.gov/erddap/tabledap/documentation.html#now) ।) यदि डेटासेट के लिए अधिकतम समय मान निर्दिष्ट समय की तुलना में हाल ही में है, तो डेटासेट को अप-टू-डेट माना जाता है। यदि निर्दिष्ट समय से अधिकतम समय मान पुराना है तो डेटासेट को अप-टू-डेट माना जाता है। आउट-ऑफ-डेट डेटासेट के लिए, संभवतः डेटा स्रोत के साथ एक समस्या है, इसलिए ERDDAP™ हाल के समय बिंदुओं से डेटा तक पहुंच पाने में असमर्थ है।
    
The The most of the testOutOfDate मूल्य में एक स्तंभ के रूप में प्रदर्शित होता है [ allDatasets डेटासेट](#eddtablefromalldatasets) अपने ERDDAP । इसका उपयोग आउटऑफ़डेट इंडेक्स की गणना करने के लिए भी किया जाता है, जो अन्य कॉलम में है allDatasets डेटासेट।
यदि सूचकांक है&lt;1, डेटासेट को अप-टू-डेट माना जाता है।
यदि सूचकांक है&lt;=1, डेटासेट को आउट-ऑफ-डेट माना जाता है।
यदि सूचकांक है&lt;=2, डेटासेट को बहुत पुराना माना जाता है।
    
The The most of the testOutOfDate मूल्य का भी उपयोग किया जाता है ERDDAP™ उत्पन्न करने के लिएhttps://*yourDomain*/erddap/outOfDateDatasets.htmlवेब पेज ( [उदाहरण](https://coastwatch.pfeg.noaa.gov/erddap/outOfDateDatasets.html) ) जो डेटासेट दिखाता है&lt; testOutOfDate &gt; टैग, डेटासेट के साथ यह बताया गया है कि वे किस तरह हैं। यदि आप फ़ाइल प्रकार बदल जाते हैं (HTML से .csv तक, .jsonlCSV , .nc , .tsv ...) , आप विभिन्न फ़ाइल स्वरूपों में उस जानकारी प्राप्त कर सकते हैं।
    
जब संभव हो, [जनरेट DatasetXml](#generatedatasetsxml) जोड़ना testOutOfDate वैश्विक विशेषता addAttributes डेटासेट का। यह मान एक सुझाव है जो जनरेटडाटासेटएक्सएमएल को उपलब्ध सूचना पर आधारित है। यदि मूल्य उचित नहीं है, तो इसे बदल दें।
    
यहां "आउट-ऑफ-डेट" बहुत अलग है&lt;रीलोड हरNMinutes (#reloadeverynminutes) , जो कैसे अप-टू-डेट से संबंधित है ERDDAP डेटासेट का ज्ञान है। The The most of the&lt; testOutOfDate &gt; प्रणाली मानती है कि ERDDAP डेटासेट का ज्ञान अप-टू-डेट है। प्रश्न&lt; testOutOfDate &gt; सौदों के साथ है: क्या डेटा के स्रोत के साथ कुछ गलत दिखाई देता है, जिससे हाल के डेटा को सुलभ नहीं किया जा सकता है ERDDAP ?
    
###### शीर्षक{#title} 
*    [ **शीर्षक** ](#title)   (से [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) और [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानकों) डेटासेट के संक्षिप्त विवरण के साथ एक आवश्यक वैश्विक विशेषता है (आमतौर पर)&lt;= 95 वर्ण). उदाहरण के लिए,
    ```
    <att name="title">VIIRSN Level-3 Mapped, Global, 4km, Chlorophyll a, Daily</att>
    ```
    * या तो डेटासेट वैश्विक [स्रोतAttributes](#global-attributes) वैश्विक&lt; addAttributes &gt; इस विशेषता में शामिल है।
    * शीर्षक महत्वपूर्ण है क्योंकि द्वारा प्रस्तुत डाटासेट की हर सूची ERDDAP   (अन्य खोज परिणामों के अलावा) वर्णमाला क्रम में डेटासेट को सूचीबद्ध करता है। इसलिए यदि आप डेटासेट के आदेश को निर्दिष्ट करना चाहते हैं, या कुछ डेटासेट समूहीकृत हैं, तो आपको उस मन में शीर्षक बनाना होगा। डेटासेट की कई सूची (उदाहरण के लिए, किसी श्रेणी की खोज के जवाब में) , पूरी सूची का एक सबसेट दिखाने के लिए और एक अलग क्रम में। इसलिए प्रत्येक डेटासेट का शीर्षक अपने आप में खड़ा होना चाहिए।
    * यदि शीर्षक में "डिप्रेक्टेड" शब्द शामिल है (सभी पूंजी पत्र) फिर डेटासेट को खोजों में कम रैंकिंग मिलेगी।
             
##### &lt; axisVariable & gt;{#axisvariable} 
* [ ** &lt; axisVariable &gt; ** ] (#axisvariable) एक आयाम का वर्णन करने के लिए प्रयोग किया जाता है (इसे "अक्ष" भी कहा जाता है) ।
के लिए EDDGrid डेटासेट, एक या अधिक axisVariable टैग की आवश्यकता है, और सभी [ dataVariable s](#datavariable) हमेशा सभी अक्ष चर को साझा/उपयोग करते हैं। ( [क्यों?](#why-just-two-basic-data-structures)   [क्या होगा?](#dimensions) )   
वहाँ MUST डेटा चर के प्रत्येक आयाम के लिए एक अक्ष चर हो।
एक्सिस वेरिएबल्स MUST को इस क्रम में निर्दिष्ट किया जाएगा कि डेटा वेरिएबल्स उनका उपयोग करते हैं।
(EDDTable Datasets)&lt; axisVariable &gt; टैग।
एक मांसल उदाहरण है:

>&nbsp;&nbsp;&lt;axisVariable>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;[sourceName](#sourcename)\\>MT&lt;/sourceName>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;[destinationName](#destinationname)\\>time&lt;/destinationName>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;addAttributes>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;att name="[units](#units)">days since 1902-01-01T12:00:00Z&lt;/att>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/addAttributes>  
>&nbsp;&nbsp;&lt;/axisVariable>  

&lt; axisVariable &gt; निम्नलिखित सबटैग का समर्थन करता है:
###### &lt; sourceName \\&gt;{#sourcename} 
* [&lt; sourceName \\&gt; (#sourcename) -- परिवर्तनीय के लिए डेटा स्रोत का नाम। यह नाम है कि ERDDAP™ डेटा स्रोत से डेटा का अनुरोध करते समय उपयोग करेगा। यह नाम है कि ERDDAP™ जब डेटा डेटा स्रोत से वापस आ जाता है तो देखेंगे। यह मामला संवेदनशील है। यह आवश्यक है।
###### &lt; destinationName \\&gt;{#destinationname} 
* [&lt; destinationName \\&gt; (#Destinationname) वेरिएबल का नाम है जिसे दिखाया जाएगा और उसके द्वारा इस्तेमाल किया जाएगा। ERDDAP™ उपयोगकर्ता
    * यह वैकल्पिक है। यदि अनुपस्थित हो तो, sourceName प्रयोग किया जाता है।
    * यह उपयोगी है क्योंकि यह आपको एक क्रिप्टिक या अजीब बदलने की अनुमति देता है sourceName ।
    *    destinationName मामला संवेदनशील है।
    *    destinationName To start with a letter. (A-Z, a-z) और MUST 0 या अधिक अक्षरों का पालन किया जा सकता है (A-Z, a-z, 0-9, and \\_) । (पहले '-' की अनुमति दी गई थी ERDDAP™ संस्करण 1.10.) यह प्रतिबंध अक्ष परिवर्तनीय नामों को समान होने की अनुमति देता है ERDDAP™ , प्रतिक्रिया फ़ाइलों में, और सभी सॉफ्टवेयर में जहां उन फ़ाइलों का उपयोग किया जाएगा, प्रोग्रामिंग भाषाओं सहित (लाइक Python , Matlab , और Java स्क्रिप्ट) जहां चर नामों पर समान प्रतिबंध हैं।
    * में EDDGrid डाटासेट [अक्षांश, ऊंचाई, गहराई और समय](#destinationname) अक्ष चर विशेष हैं।
         
######  axisVariable  &lt;addAttributes&gt; {#axisvariable-addattributes} 
* [&lt; addAttributes &gt; (#variable-addattributes) विशेषताओं के एक OPTIONAL सेट को परिभाषित करता है ( *नाम* = *मूल्य* ) जो एक चर के लिए स्रोत की विशेषताओं में जोड़ा जाता है, ताकि एक चर के लिए संयुक्त गुण बनाया जा सके।
यदि परिवर्तनशील [स्रोतAttributes](#variable-addattributes) या&lt; addAttributes &gt; शामिल [ scale\\_factor और/or add\\_offset ](#scale_factor) गुण, उनके मूल्यों का उपयोग ग्राहक को वितरण से पहले स्रोत से डेटा को अनपैक करने के लिए किया जाएगा।
     (परिणाम मूल्य = स्रोत मान scale\\_factor + add\\_offset ) । अनपैक्ड वेरिएबल समान डेटा प्रकार का होगा (उदाहरण के लिए, फ्लोट) जैसा scale\\_factor और add\\_offset मान
         
##### &lt; dataVariable & gt;{#datavariable} 
* [ ** &lt; dataVariable &gt; ** ] (#datavariable) आवश्यक है (लगभग सभी डेटासेट के लिए) भीतर टैग&lt;डेटासेट&gt; टैग जिसका उपयोग डेटा चर का वर्णन करने के लिए किया जाता है। इस टैग के 1 या अधिक उदाहरण हैं। एक मांसल उदाहरण है:

>&nbsp;&nbsp;&lt;dataVariable>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;[sourceName](#sourcename)\\>waterTemperature&lt;/sourceName>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;[destinationName](#destinationname)\\>sea\\_water\\_temperature&lt;/destinationName>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;dataType>](#datatype)float&lt;/dataType>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;addAttributes>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;att name="[ioos\\_category](#ioos_category)">Temperature&lt;/att>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;att name="[long\\_name](#long_name)">Sea Water Temperature&lt;/att>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;att name="[standard\\_name](#standard_name)">sea\\_water\\_temperature&lt;/att>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;att name="[units](#units)">degree\\_C&lt;/att>  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/addAttributes>  
>&nbsp;&nbsp;&lt;/dataVariable>  

&lt; dataVariable &gt; निम्नलिखित सबटैग का समर्थन करता है:
###### &lt; sourceName & gt;{#sourcename-1} 
* [&lt; sourceName &gt; (#sourcename) -- परिवर्तनीय के लिए डेटा स्रोत का नाम। यह नाम है कि ERDDAP™ डेटा स्रोत से डेटा का अनुरोध करते समय उपयोग करेगा। यह नाम है कि ERDDAP™ जब डेटा डेटा स्रोत से वापस आ जाता है तो देखेंगे। यह मामला संवेदनशील है। यह आवश्यक है।
###### समूह{#groups} 
CF ने CF v1.8 के साथ समूहों के लिए समर्थन जोड़ा। ~2020 में शुरू NetCDF उपकरण एक समूह में चर डालने का समर्थन करते हैं .nc फ़ाइल व्यवहार में, इसका मतलब यह है कि चर का एक लंबा नाम है जो समूह की पहचान करता है (s) उदाहरण के लिए, समूह 1a/group2c/varName. ERDDAP™ "/" को परिवर्तनीय में परिवर्तित करके समूहों का समर्थन करता है&lt; sourceName &gt; "\\_" में चर में&lt; destinationName उदाहरण के लिए, Group1a \\_group2c \\_varName। (जब आप देखते हैं कि आपको पता होना चाहिए कि समूह एक वाक्यविन्यास से ज्यादा नहीं हैं।) जब चर में सूचीबद्ध होते हैं ERDDAP™ एक समूह में सभी चर एक साथ दिखाई देंगे, अंतर्निहित समूह की नकल करेंगे। \\[ अगर ERDDAP™ विशेष रूप से जेनरेटडाटासेट Xml, प्रदर्शन नहीं करता है और यह स्रोत फ़ाइलों के साथ भी हो सकता है जिसमें समूह हैं, कृपया क्रिस को एक नमूना फ़ाइल ईमेल करें। जॉन at noaa.gov. \\] 

EDDTableFromFiles Datasets कुछ विशेष रूप से एन्कोडेड, छद्म इस्तेमाल कर सकते हैं sourceName नए डेटा चर को परिभाषित करने के लिए, उदाहरण के लिए, एक डेटा चर होने के लिए वैश्विक विशेषता को बढ़ावा देने के लिए। देखें [यह दस्तावेज़ीकरण](#pseudo-sourcenames) ।
######  HDF संरचनाएं{#hdf-structures} 
शुरू ERDDAP™ v2.12, EDDGrid FromNcFiles and fromNcFiles. EDDGrid FromNcFiles अनपैक्ड में "संरचना" से डेटा पढ़ सकते हैं .nc 4 और 4 .hdf 4 फाइलें। एक चर की पहचान करने के लिए जो एक संरचना से है,&lt; sourceName &gt; प्रारूप का उपयोग करना चाहिए: *पूर्ण संरचनानाम*  |  *सदस्यनाम* , उदाहरण के लिए समूह1/myStruct | मेरा सदस्य

###### फिक्स्ड वैल्यू सोर्सनाम{#fixed-value-sourcenames} 
एक EDDTable Dataset में, यदि आप एक चर बनाने के लिए चाहते हैं (एक एकल, निश्चित मूल्य के साथ) यह स्रोत डेटासेट में नहीं है, इसका उपयोग करें:
```
    <sourceName>=*fixedValue*</sourceName>  
```
प्रारंभिक बराबर संकेत बताता है ERDDAP™ एक निश्चित मूल्य का पालन करेगा।

* संख्यात्मक चर के लिए, निश्चित मूल्य एक एकल परिमित मान या NaN होना चाहिए (मामले असंवेदनशील, उदाहरण के लिए, \\=NaN) ।
* स्ट्रिंग चर के लिए, निश्चित मूल्य एकल होना चाहिए, [JSON-style स्ट्रिंग](https://www.json.org/json-en.html)   (विशेष पात्रों के साथ बच) , उदाहरण के लिए, \\="My \\"विशेष \" स्ट्रिंग"।
* एक टाइमस्टैम्प चर के लिए, निर्धारित मान को एक नंबर के रूप में निर्दिष्ट करें "seconds since 1970-01-01T00:00:00Z" उपयोग
1970-01-01T00:00:00Z से यूनिट = सेकंड।
    
अन्य टैग&lt; dataVariable इस तरह के रूप में काम करते हैं कि यह एक नियमित चर था।
उदाहरण के लिए, 0.0 के एक निश्चित मूल्य के साथ एक चर बुलाया ऊंचाई बनाने के लिए (फ्लोट) उपयोग:

>        &lt;sourceName>=0&lt;/sourceName>  
>        [&lt;destinationName\\>](#destinationname)altitude&lt;/destinationName>  
>        [&lt;dataType>float&lt;/dataType>](#datatype)  

असामान्य स्थितियों के लिए, आप एक भी निर्दिष्ट कर सकते हैं actual\\_range AddAttribute, जो गंतव्य मिन और गंतव्य मैक्स के अपेक्षित मूल्यों को ओवरराइड करेगा (जो अन्यथा निर्धारित बराबर होगा मूल्य) ।
 
###### स्क्रिप्ट SourceNames/Derived Variables{#script-sourcenamesderived-variables} 
शुरू ERDDAP™ v2.10, एक में [EDDTableFromFiles](#eddtablefromfiles) , [EDDTableFromDatabase](#eddtablefromdatabase) या [EDDTableFromFileNames](#eddtablefromfilenames) डेटासेट&lt; sourceName &gt; हो सकता है
अभिव्यक्ति (एक समीकरण जो एकल मान का मूल्यांकन करता है) , प्रारूप का उपयोग करना
```
    <sourceName>=*expression*</sourceName>  
```
या एक स्क्रिप्ट (बयानों की एक श्रृंखला जो एक एकल मूल्य लौटाती है) , प्रारूप का उपयोग करना
```
    <sourceName>=*script*</sourceName>  
```
 ERDDAP™ पर निर्भर [अपाचे परियोजना](https://www.apache.org/)   [ Java अभिव्यक्ति भाषा (JEXL) ](https://commons.apache.org/proper/commons-jexl/)   (लाइसेंस: [अपाचे](https://www.apache.org/licenses/LICENSE-2.0) ) अभिव्यक्तियों का मूल्यांकन और स्क्रिप्ट चलाने के लिए।
किसी दिए गए नए चर के लिए गणना परिणामों की एक पंक्ति के भीतर की जाती है, बार-बार सभी पंक्तियों के लिए।
अभिव्यक्ति और स्क्रिप्ट एक का उपयोग करते हैं Java - और Java स्क्रिप्ट-जैसे वाक्यविन्यास और किसी भी तरह का उपयोग कर सकते हैं
 [ऑपरेटरों और तरीकों जो JEXL में बनाया गया है](https://commons.apache.org/proper/commons-jexl/reference/syntax.html) ।
स्क्रिप्ट भी विधियों का उपयोग कर सकते हैं (कार्य) इन कक्षाओं से:
*    [कैलेंडर2](/docs/dokka/-e-r-d-d-a-p/com.cohort.util/-script-calendar2) , जो कॉम.cohort.util.Calendar2 में स्थिर, समय और कैलेंडर से संबंधित विधियों में से कुछ के लिए एक रैपर है। ( [लाइसेंस](/acknowledgements#cohort-software) ) । उदाहरण के लिए,
Calendar2.parseToEpochSeconds ( *सोर्सटाइम, तारीख टाइमफॉर्मैट* ) स्रोत को पार करेगा डेटटाइमफॉर्मैट स्ट्रिंग के माध्यम से टाइम स्ट्रिंग और एक वापस लौटें "seconds since 1970-01-01T00:00:00Z"   (EepochSeconds) डबल मान।
*    [गणित](/docs/dokka/-e-r-d-d-a-p/com.cohort.util/-script-math) , जो लगभग सभी स्थैतिक, गणित से संबंधित विधियों के लिए एक रैपर है [java.lang. गणित](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html) । उदाहरण के लिए, Math.atan2 ( *y, x* ) आयताकार निर्देशांक में लेता है (y, x) और रिटर्न ध्रुवीय निर्देशांक (डबल्स की एक सरणी के साथ \\[ r, theta \\] ) ।
*    [गणित2](/docs/dokka/-e-r-d-d-a-p/com.cohort.util/-script-math2) , जो com.cohort.util में लगभग सभी स्थैतिक, गणित से संबंधित विधियों के लिए एक रैपर है। गणित2 ( [लाइसेंस](/acknowledgements#cohort-software) ) । उदाहरण के लिए,
Math2.roundTo ( *D, nPlaces* ) दशमलव बिंदु के दाईं ओर अंकों की निर्दिष्ट संख्या को राउंड डी होगा।
* स्ट्रिंग, जो आपको सभी स्थैतिक, स्ट्रिंग से संबंधित विधियों तक पहुंच प्रदान करता है [java.lang. स्ट्रिंग](https://docs.oracle.com/javase/8/docs/api/java/lang/String) । स्ट्रिंग ऑब्जेक्ट ERDDAP™ अभिव्यक्ति और स्क्रिप्ट उनके संबद्ध में से किसी का उपयोग कर सकते हैं Java विधियाँ, जैसा कि जावा.लैंग में वर्णित है। स्ट्रिंग प्रलेखन। उदाहरण के लिए, स्ट्रिंग.valueOf (D) डबल मान को एक स्ट्रिंग में बदल देगा (हालांकि आप "+d" का भी उपयोग कर सकते हैं) ।
*    [स्ट्रिंग2](/docs/dokka/-e-r-d-d-a-p/com.cohort.util/-script-string2) , जो कॉम.cohort.util.String2 में स्थिर, स्ट्रिंग और सरणी से संबंधित विधियों में से अधिकांश के लिए एक रैपर है। ( [लाइसेंस](/acknowledgements#cohort-software) ) । उदाहरण के लिए, स्ट्रिंग2 .z eroPad ( *संख्या, nDigits* ) संख्या स्ट्रिंग के बाईं ओर 0's जोड़ देगा ताकि अंकों की कुल संख्या nDigit है (उदाहरण के लिए, स्ट्रिंग2 .z eroPad ("6", 2) "06" लौटेगा) ।
*    [पंक्ति](/docs/dokka/-e-r-d-d-a-p/com.cohort.util/-script-row) , जिसमें स्रोत डेटा तालिका की वर्तमान पंक्ति में विभिन्न स्तंभों से डेटा तक पहुंचने के लिए गैर-स्थिर तरीके हैं। उदाहरण के लिए, row.columnString ("वर्ष") एक स्ट्रिंग के रूप में "वर्ष" कॉलम से मूल्य पढ़ता है, जबकि, row.column Int ("वर्ष") एक पूर्णांक के रूप में "वर्ष" कॉलम से मूल्य पढ़ता है।

सुरक्षा कारणों के लिए, अभिव्यक्ति और स्क्रिप्ट उन 6 के अलावा अन्य वर्गों का उपयोग नहीं कर सकते हैं। ERDDAP™ डिफ़ॉल्ट ब्लैकलिस्ट बनाकर इस सीमा को लागू करता है (जो सभी कक्षाओं को ब्लैकलिस्ट करता है) और फिर एक श्वेतसूची (जो विशेष रूप से ऊपर वर्णित 6 कक्षाओं की अनुमति देता है) । यदि आपको अन्य तरीकों और/या अन्य वर्गों की आवश्यकता है तो कृपया अपने अनुरोधों को क्रिस पर ईमेल करें। जॉन at noaa.gov.
    
###### दक्षता
EDDTableFromFiles डेटासेट के लिए, केवल बहुत कम है (शायद ध्यान नहीं देना) इन चरों से डेटा के अनुरोध के लिए मंदी। EDDTableFromDatabase के लिए, उन अनुरोधों के लिए भारी गति का जुर्माना है जिनमें इन चरों पर बाधाएं शामिल हैं (उदाहरण के लिए, (&longitude0360&gt; 30&longitude0360)&lt;40) क्योंकि बाधाओं को डेटाबेस के माध्यम से पारित नहीं किया जा सकता है, इसलिए डेटाबेस को अधिक डेटा वापस करना पड़ता है। ERDDAP™   (जो बहुत समय लगता है) इतना ERDDAP™ नए चर बना सकते हैं और बाधा लागू कर सकते हैं। सबसे खराब मामले से बचने के लिए (जहां डेटाबेस में कोई बाधा नहीं होती है) , ERDDAP™ एक त्रुटि संदेश फेंकता है ताकि डेटाबेस को टेबल की पूरी सामग्री वापस नहीं करना पड़े। (यदि आप इसे बायपास करना चाहते हैं, तो एक गैर-script कॉलम में एक बाधा जोड़ें जो हमेशा सच होगा, उदाहरण के लिए, और समय&lt;3000-01-01 इस कारण से, EDDTableFromDatabase के साथ, उपयोग के बजाय डेटाबेस में एक व्युत्पन्न कॉलम बनाने के लिए शायद बेहतर होता है। sourceName =script in ERDDAP ।

###### कैसे एक अभिव्यक्ति का अवलोकन (या स्क्रिप्ट) प्रयोग किया जाता है:
सारणीबद्ध डेटा के लिए उपयोगकर्ता के अनुरोध के जवाब में, ERDDAP™ स्रोत फ़ाइलों की एक श्रृंखला से डेटा प्राप्त होता है। प्रत्येक स्रोत फ़ाइल कच्चे की एक तालिका उत्पन्न करेगा (स्रोत से सीधे) डेटा ERDDAP™ फिर कच्चे डेटा की तालिका के माध्यम से जाना होगा, पंक्ति द्वारा पंक्ति और प्रत्येक पंक्ति के लिए एक बार अभिव्यक्ति या स्क्रिप्ट का मूल्यांकन करना, ताकि एक नया स्तंभ बनाया जा सके जिसमें उस अभिव्यक्ति या स्क्रिप्ट को एक नया स्तंभ के रूप में बनाया जा सके। sourceName ।
    
###### जनरेट DatasetXml
ध्यान दें कि GenerateDatasets Xml पूरी तरह से अनजान है जब एक चर बनाने की आवश्यकता होती है&lt; sourceName &gt;= *अभिव्यक्ति* &lt;/ sourceName &gt; आप में चर बनाने के लिए है datasets.xml हाथ से।

###### अभिव्यक्ति उदाहरण:
यहां डेटा चर के कुछ पूर्ण उदाहरण हैं जो डेटा के एक नए कॉलम बनाने के लिए एक अभिव्यक्ति का उपयोग करते हैं। हम उम्मीद करते हैं कि ये उदाहरण (और उनके रूपों) सभी अभिव्यक्ति-व्युत्पन्न के उपयोग के बारे में 95% कवर करेगा sourceName S.

###### अलग-अलग "डेट" और संयोजन "time" एक एकीकृत समय स्तंभ में स्तंभ:
```
    <dataVariable>
        <sourceName>=Calendar2.parseToEpochSeconds(row.columnString("date") + "T" + 
            row.columnString("time") + "Z", "yyyy-MM-dd'T'HH:mm:ss'Z'")</sourceName> 
        <destinationName>time</destinationName>
        <dataType>double</dataType>
        <addAttributes>
            <att name="units">seconds since 1970-01-01</att>
        </addAttributes>
    </dataVariable>
```
कि sourceName अभिव्यक्ति एक नया बनाता है "time" "date" से स्ट्रिंग मूल्यों को जोड़कर स्तंभ ( yyyy-MM-dd ) और "time"   (HH:mm:s) स्रोत फ़ाइल की प्रत्येक पंक्ति पर कॉलम, और उस स्ट्रिंग को एक में बदलकर "seconds since 1970-01-01"   (EepochSeconds) डबल मान।

या निश्चित रूप से, आपको प्रत्येक डेटासेट के स्रोत दिनांक और समय कॉलम में विशिष्ट प्रारूप से निपटने के लिए समय प्रारूप स्ट्रिंग को अनुकूलित करना होगा, देखें
 [समय इकाइयों प्रलेखन](#string-time-units) ।

तकनीकी रूप से, आपको उपयोग करने की आवश्यकता नहीं है Calendar2.parseToEpochSeconds () संयुक्त तारीख + समय को epochSeconds में परिवर्तित करने के लिए। आप सिर्फ तारीख + समय स्ट्रिंग को पास कर सकते हैं ERDDAP™ और प्रारूप निर्दिष्ट (उदाहरण के लिए,)
 yyyy-MM-dd 'T'H:mm:s'Z') इकाइयों विशेषता के माध्यम से। लेकिन epochSeconds में परिवर्तित करने के लिए महत्वपूर्ण फायदे हैं - विशेष रूप से, EDDTableFromFiles तब आसानी से प्रत्येक फ़ाइल में समय मानों की सीमा को ट्रैक रख सकते हैं और इसलिए जल्दी से यह तय कर सकते हैं कि किसी अनुरोध के जवाब में दिए गए फ़ाइल को देखने के लिए कि क्या समय की कमी है।

संबंधित समस्या अलग साल, महीने, तारीख, घंटे, मिनट, दूसरे के साथ एक स्रोत से एक एकीकृत तारीख + समय स्तंभ बनाने की आवश्यकता है। समाधान बहुत समान है, लेकिन आपको अक्सर कई क्षेत्रों में शून्य-पैड की आवश्यकता होगी, ताकि उदाहरण के लिए, महीने (1 - 12) तारीख (1 - 31) हमेशा 2 अंक होते हैं। यहाँ साल, महीने, तारीख के साथ एक उदाहरण है:
```
    <sourceName>=Calendar2.parseToEpochSeconds(row.columnString("year") + 
        String2.zeroPad(row.columnString("month"), 2) + 
        String2.zeroPad(row.columnString("date"), 2), "yyyyMMdd")</sourceName>
```
संबंधित समस्या यह है कि स्रोत तालिका की अलग-अलग डिग्री, मिनट और सेकंड कॉलम में डेटा को जोड़कर एक एकीकृत अक्षांश या देशांतर स्तंभ बनाने की आवश्यकता है, प्रत्येक को पूर्णांक के रूप में संग्रहीत किया जाता है। उदाहरण के लिए,
```
    <sourceName>=row.columnInt("deg") + row.columnInt("min")/60.0 + 
        row.columnInt("sec")/3660.0</sourceName>
```
###### 0-60 ° से - 180 ° - 180 ° से - 180 ° के मूल्यों के साथ "लंबाई" नामक स्तंभ में लम्बाई मान के साथ एक स्तंभ को परिवर्तित करना
```
    <dataVariable>
        <sourceName>=Math2.anglePM180(row.columnDouble("lon"))</sourceName> 
        <destinationName>longitude</destinationName>
        <dataType>double</dataType>
        <addAttributes>
            <att name="units">degrees\\_east</att>
        </addAttributes>
    </dataVariable>
```
कि sourceName अभिव्यक्ति स्रोत फ़ाइल की प्रत्येक पंक्ति पर "लोन" कॉलम से डबल वैल्यू को परिवर्तित करके एक नया "लंबाई" कॉलम बनाता है (संभवतः 0 - 360 मानों के साथ) , और यह है कि एक -180 से 180 डबल मान में परिवर्तित करके।

यदि आप इसके बजाय -180 के स्रोत देशांतर मान को परिवर्तित करना चाहते हैं - 180 ° 0 - 360 °, उपयोग
```
    <sourceName>=Math2.angle0360(row.columnDouble("lon"))</sourceName>
```
दो अक्षांश चर नाम:
यदि डेटासेट में 2 देशांतर चर होंगे, तो हम अनुशंसा करते हैं कि उपयोग करना destinationName -180 - 180 डिग्री चर और destinationName = देशांतर0360 (और LongName = \\"लंबाई 0-360°") 0-60 ° चर के लिए। यह महत्वपूर्ण है क्योंकि उपयोगकर्ता कभी-कभी एक विशिष्ट लम्बाई सीमा के भीतर डेटा की खोज के लिए एडवांस्ड सर्च का उपयोग करते हैं। यदि लंबे समय तक लगातार -180 - सभी डेटासेट के लिए 180 डिग्री मान होते हैं तो यह खोज बेहतर काम करेगी। इसके अलावा, डेटासेट के भू-स्थानिक \\_lon\\_min, भू-स्थानिक \\lon\\_max, Westernmost \\_Easting और Eastmost \\_Eastings वैश्विक विशेषताओं को तब एक सुसंगत तरीके से सेट किया जाएगा (लम्बाई मान -180 से 180 डिग्री) ;
    
###### डिग्री \\_ में तापमान मान के साथ "टेम्प्फ़" नामक स्तंभ को परिवर्तित करना F में एक कॉलम जिसका नाम "टेम्पसी" है, जिसमें डिग्री \\_ C:
```
    <dataVariable>
        <sourceName>=(row.columnFloat("tempF")-32)\\*5/9</sourceName> 
        <destinationName>tempC</destinationName>
        <dataType>float</dataType>
        <addAttributes>
            <att name="units">degrees\\_C</att>
        </addAttributes>
    </dataVariable>
```
कि sourceName अभिव्यक्ति फ्लोट डिग्री को परिवर्तित करके एक नया "टेम्पसी" कॉलम बनाती है स्रोत फ़ाइल की प्रत्येक पंक्ति पर फ्लोट डिग्री \\_ में "टेम्प्फ़" कॉलम से F मान C मान

ध्यान दें कि आपके डेटासेट में मूल अस्थायी दोनों हो सकते हैं F चर और नया अस्थायी C चर द्वारा एक अन्य चर के साथ
```
    <sourceName>tempF</sourceName>
```
###### पवन "गति" और "दिशा" स्तंभों को यू, वी घटकों के साथ दो स्तंभों में परिवर्तित करना
* यू चर बनाने के लिए, उपयोग करें
```
    <sourceName>=row.columnFloat("speed") \\* Math.cos(row.columnFloat("direction"))</sourceName>
```
* एक वी चर बनाने के लिए, उपयोग करें
```
    <sourceName>=row.columnFloat("speed") \\* Math.sin(row.columnFloat("direction"))</sourceName>
```
या, यू, वी:
* एक गति चर बनाने के लिए, उपयोग करें
```
    <sourceName>=Math.atan2(row.columnDouble("v"), row.columnDouble("u"))\\[0\\]</sourceName>
```
* एक दिशा चर बनाने के लिए, उपयोग करें
```
    <sourceName>=Math.toDegrees(Math.atan2(row.columnDouble("v"), row.columnDouble("u"))\\[1\\])</sourceName>
```
    
###### स्क्रिप्ट उदाहरण:
यहां एक स्क्रिप्ट का उपयोग करने का एक उदाहरण है, न केवल एक अभिव्यक्ति, एक के रूप में sourceName । हम उम्मीद करते हैं कि अभिव्यक्ति के विपरीत स्क्रिप्ट अक्सर आवश्यक नहीं होगी। इस मामले में लक्ष्य एक गैर-NaN लापता मूल्य वापस करने के लिए है (-99) किसी विशिष्ट श्रेणी के बाहर तापमान मूल्यों के लिए। ध्यान दें कि स्क्रिप्ट "" के बाद हिस्सा है।
```
    <dataVariable>
        <sourceName>=var tc=row.columnFloat("tempC"); return tc&gt;35 || tc&lt;-5? -99.0f : tc\\*9/5+32;</sourceName> 
        <destinationName>tempF</destinationName>
        <dataType>float</dataType>
        <addAttributes>
            <att name="units">degrees\\_F</att>
        </addAttributes>
    </dataVariable>
```
###### हार्ड फ्लैग
यदि आप अभिव्यक्ति या स्क्रिप्ट को एक में परिभाषित करते हैं sourceName , आपको एक सेट करना होगा [कठोर झंडा](/docs/server-admin/additional-information#hard-flag) इसलिए डेटासेट के लिए ERDDAP™ डेटासेट के लिए सभी कैश्ड जानकारी को हटा देता है और प्रत्येक डेटा फ़ाइल को फिर से पढ़ता है (नई अभिव्यक्ति या स्क्रिप्ट का उपयोग करना) अगली बार यह डेटासेट लोड करता है। वैकल्पिक रूप से, आप उपयोग कर सकते हैं [दास](#dasdds) जो एक हार्ड फ्लैग सेट करने के बराबर है।

###### Percent Encode
यह केवल शायद ही कभी प्रासंगिक है: क्योंकि अभिव्यक्ति और स्क्रिप्ट में लिखे गए हैं datasets.xml , जो एक XML दस्तावेज़ है, आपको किसी भी कोड को प्रतिशत करना होगा&lt;अभिव्यक्तियों और लिपियों में \\&gt; और वर्ण&lt;, &gt; और &amp; .

###### सामान्य समस्याएं
एक आम समस्या यह है कि आप के साथ एक चर बनाने sourceName = *अभिव्यक्ति* लेकिन डेटा का परिणामी स्तंभ सिर्फ लापता मान है। वैकल्पिक रूप से, नए स्तंभ की कुछ पंक्तियों में लापता मान होते हैं और आपको लगता है कि उन्हें नहीं करना चाहिए। अंतर्निहित समस्या यह है कि अभिव्यक्ति के साथ कुछ गलत है और ERDDAP उस त्रुटि को एक लापता मान में बदल रहा है। समस्या को हल करने के लिए,

* यह देखने के लिए अभिव्यक्ति को देखें कि समस्या क्या हो सकती है।
* देखो [लॉग-इन](/docs/server-admin/additional-information#log) , जो प्रत्येक नए स्तंभ के निर्माण के दौरान उत्पन्न पहली त्रुटि संदेश दिखाएगा।

सामान्य कारण हैं:

* आपने गलत मामले का इस्तेमाल किया। अभिव्यक्ति और स्क्रिप्ट मामले संवेदनशील हैं।
* आपने कक्षा का नाम छोड़ दिया। उदाहरण के लिए, आपको Math.abs का उपयोग करना होगा। () नहीं () ।
* आपने रूपांतरण नहीं किया था। उदाहरण के लिए, यदि एक पैरामीटर मान का डेटा प्रकार स्ट्रिंग है और आपके पास एक दोहरा मान है, तो आपको एक डबल को ""+d के माध्यम से स्ट्रिंग में बदलने की आवश्यकता है।
* अभिव्यक्ति में कॉलम का नाम वास्तव में फ़ाइल में कॉलम नाम से मेल नहीं खाता है (या नाम कुछ फ़ाइलों में अलग हो सकता है) ।
* अभिव्यक्ति में एक वाक्यविन्यास त्रुटि है (उदाहरण के लिए, एक लापता या अतिरिक्त ') ').

यदि आप अटक जाते हैं या मदद की आवश्यकता होती है, तो क्या आप अटक जाते हैं?
कृपया विवरण शामिल करें और हमारे देखें [अतिरिक्त समर्थन प्राप्त करने पर अनुभाग](/docs/intro#support) ।
        
###### &lt; destinationName & gt;{#destinationname-1} 
* [&lt; destinationName &gt; (#Destinationname) - उस चर के लिए नाम जिसे दिखाया जाएगा और उसके द्वारा इस्तेमाल किया जाएगा ERDDAP™ उपयोगकर्ता
    * यह वैकल्पिक है। यदि अनुपस्थित हो तो, [ sourceName ](#sourcename) प्रयोग किया जाता है।
    * यह उपयोगी है क्योंकि यह आपको एक क्रिप्टिक या अजीब बदलने की अनुमति देता है sourceName ।
    *    destinationName मामला संवेदनशील है।
    *    destinationName To start with a letter. (A-Z, a-z) और MUST 0 या अधिक अक्षरों का पालन किया जा सकता है (A-Z, a-z, 0-9, and \\_) । (पहले '-' की अनुमति दी गई थी ERDDAP™ संस्करण 1.10.) यह प्रतिबंध डेटा परिवर्तनीय नामों को समान होने की अनुमति देता है ERDDAP™ , प्रतिक्रिया फ़ाइलों में, और सभी सॉफ्टवेयर में जहां उन फ़ाइलों का उपयोग किया जाएगा, प्रोग्रामिंग भाषाओं सहित (लाइक Python , Matlab , और Java स्क्रिप्ट) जहां चर नामों पर समान प्रतिबंध हैं।
    * EDDTable Datasets में, [अक्षांश, ऊंचाई (या गहराई) समय](#destinationname) डेटा चर विशेष हैं।
             
###### &lt;डेटा प्रकार&gt;{#datatype} 
* [&lt;Datatype&gt; (#datatype) -- स्रोत से आने वाले डेटा प्रकार को निर्दिष्ट करता है। (कुछ मामलों में, उदाहरण के लिए, जब ASCII फ़ाइलों से डेटा पढ़ने के लिए, यह निर्दिष्ट करता है कि स्रोत से आने वाले डेटा को कैसे संग्रहीत किया जाना चाहिए।) 
    * यह कुछ डेटासेट प्रकारों द्वारा आवश्यक है और दूसरों द्वारा IGNORED। डेटासेट प्रकार जिन्हें उनके लिए इसकी आवश्यकता होती है dataVariable एस हैं: EDDGrid fromXxxFiles, EDDTableFromXxxFiles, EDDTableFromM WFS , EDDTableFromNOS, EDDTableFrom SOS । अन्य डेटासेट प्रकार इस टैग को अनदेखा करते हैं क्योंकि उन्हें स्रोत से जानकारी मिलती है।
         
    * मान्य मान मानक में से कोई हैं [ ERDDAP™ डेटा प्रकार](#data-types) प्लस बोरान (नीचे देखें) । डेटाटाइप नाम केस-संवेदनशील होते हैं।
         
###### बोरान डेटा{#boolean-data} 
*    ["बोला"](#boolean-data) एक विशेष मामला है।
    * आंतरिक रूप से ERDDAP™ एक boolean प्रकार का समर्थन नहीं करता क्योंकि booleans लापता मूल्यों को स्टोर नहीं कर सकते हैं और अधिकांश फ़ाइल प्रकार booleans का समर्थन नहीं करते हैं। इसके अलावा, DAP बोओलान का समर्थन नहीं करता है, इसलिए बोओलान चर को क्वेरी करने का कोई मानक तरीका नहीं होगा।
    * डेटा के लिए "boolean" निर्दिष्ट करना में टाइप datasets.xml बोओलेन मूल्यों को संग्रहित करने और बाइट्स के रूप में प्रतिनिधित्व करने का कारण होगा: 0=false, 1=true, 127= missing\\_value ।
    * उपयोगकर्ता संख्यात्मक मूल्यों का उपयोग करके बाधाओं को निर्दिष्ट कर सकते हैं (उदाहरण के लिए, "isAlive = 1") ।
    *    ERDDAP™ प्रशासकों को कभी-कभी "boolean" डेटा का उपयोग करने की आवश्यकता होती है में टाइप datasets.xml बताने के लिए ERDDAP™ डेटा स्रोत के साथ बातचीत कैसे करें (उदाहरण के लिए, एक रिलेशनल डेटाबेस से बोलान मूल्यों को पढ़ने और उन्हें 0, 1, या 127 में परिवर्तित करने के लिए।) ।
         
* यदि आप स्रोत फ़ाइलों में डेटाटाइप से डेटा चर को बदलना चाहते हैं (उदाहरण के लिए, लघु) कुछ अन्य डेटा में डेटासेट में टाइप करें (उदाहरण के लिए, int) नहीं&lt;आप क्या चाहते हैं निर्दिष्ट करने के लिए datatype&gt;। (यह कुछ प्रकार के डेटासेट के लिए काम करता है, लेकिन अन्य नहीं।) इसके बजाय:
    * उपयोग&lt;datatype&gt; को निर्दिष्ट करने के लिए क्या फ़ाइलों में है (उदाहरण के लिए, लघु) ।
    * में&lt; addAttributes &gt; चर के लिए, एक जोड़ें [ scale\\_factor ](#scale_factor) नए डेटा के साथ विशेषता प्रकार (उदाहरण के लिए, int) उदाहरण के लिए, 1 का मान,
```
            <att name="scale\\_factor" type="int">1</att>  
```
######  dataVariable  &lt;addAttributes&gt; {#datavariable-addattributes} 
* [&lt; addAttributes &gt; (#variable-addattributes) - विशेषताओं के एक सेट को परिभाषित करता है ( *नाम* = *मूल्य* ) जो एक चर के लिए स्रोत की विशेषताओं में जोड़ा जाता है, ताकि एक चर के लिए संयुक्त गुण बनाया जा सके। यह वैकल्पिक है।
यदि परिवर्तनशील [स्रोतAttributes](#variable-addattributes) या&lt; addAttributes &gt; शामिल [ scale\\_factor और/or add\\_offset ](#scale_factor) विशेषताएँ, उनके मूल्यों का उपयोग क्लाइंट को वितरण से पहले स्रोत से डेटा को अनपैक करने के लिए किया जाएगा। अनपैक्ड वेरिएबल समान डेटा प्रकार का होगा (उदाहरण के लिए, फ्लोट) जैसा scale\\_factor और add\\_offset मान
        
###### चर&lt;addAttributes&gt; {#variable-addattributes} 
* [ ** परिवर्तनीय विशेषता / चर&lt; addAttributes &gt; ** ] (#variable-addattributes) --&lt; addAttributes &gt; एक के भीतर एक वैकल्पिक टैग है&lt; axisVariable &gt;&lt; dataVariable &gt; टैग जिसका उपयोग चर की विशेषताओं को बदलने के लिए किया जाता है।
    
    *    ** एक चर का उपयोग करें&lt; addAttributes &gt; परिवर्तनीय विशेषताओं को बदलने के लिए। **  ERDDAP™ डेटासेट के स्रोत से एक चर की विशेषताओं को जोड़ती है ()** स्रोतAttributes **) और चर**  addAttributes  **जिसे आप परिभाषित करते हैं datasets.xml   (जो प्राथमिकता है) चर बनाने के लिए "** संयुक्त एथलीट ** क्या है ERDDAP™ उपयोगकर्ता देखते हैं। इस प्रकार, आप उपयोग कर सकते हैं addAttributes SourceAttributes के मूल्यों को फिर से परिभाषित करने के लिए, नई विशेषताओं को जोड़ें, या विशेषताओं को हटा दें।
    * [] ** &lt; addAttributes &gt; **सूचना (#addattributs) जो वैश्विक और परिवर्तनीय पर लागू होता है** &lt; addAttributes &gt; ** ।
    *    ERDDAP™ विभिन्न तरीकों से इन विशेषताओं में से कई का उपयोग करता है। उदाहरण के लिए, colorBar मूल्यों के माध्यम से उपलब्ध एक चर बनाने के लिए आवश्यक हैं WMS , ताकि मैप्स को सुसंगत रंगबारों के साथ बनाया जा सके।
    *    [देशांतर, अक्षांश, ऊंचाई (या गहराई) , और समय चर](#destinationname) स्वचालित रूप से बहुत सारे उपयुक्त मेटाडाटा प्राप्त करें (उदाहरण के लिए, [यूनिट](#units) ) ।
    * एक नमूना&lt; addAttributes &gt; डेटा चर के लिए है:

    >&nbsp;&nbsp;&nbsp;&nbsp;&lt;addAttributes>  
    >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;att name="actual\\_range" type="doubleList">10.34 23.91&lt;/att>  
    >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;att name="colorBarMinimum" type="double">0&lt;/att>  
    >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;att name="colorBarMaximum" type="double">32&lt;/att>  
    >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;att name="[ioos\\_category](#ioos_category)">Temperature&lt;/att>  
    >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;att name="[long\\_name](#long_name)">Sea Surface Temperature&lt;/att>  
    >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;att name="numberOfObservations" />  
    >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;att name="[units](#units)">degree\\_C&lt;/att>  
    >&nbsp;&nbsp;&nbsp;&nbsp;&lt;/addAttributes>  

खाली संख्या अवलोकन विशेषता स्रोत संख्या अवलोकन विशेषता का कारण बनता है (यदि कोई हो) अंतिम, विशेषताओं की संयुक्त सूची से हटाया जाना चाहिए।
    * इस जानकारी की आपूर्ति करने में मदद करता है ERDDAP™ बेहतर काम करते हैं और उपयोगकर्ता डेटासेट को समझने में मदद करते हैं।
अच्छा मेटाडाटा एक डाटासेट प्रयोग करने योग्य बनाता है।
अपर्याप्त मेटाडाटा एक डेटासेट बेकार बनाता है।
कृपया मेटाडाटा विशेषताओं के साथ अच्छा काम करने का समय लें।
    
###### उन चर विशेषताओं के बारे में टिप्पणियां जो विशेष हैं ERDDAP :

######  actual\\_range  {#actual_range} 
*    [ ** actual\\_range ** ](#actual_range) एक Recommended चर विशेषता है। उदाहरण के लिए,

>    &lt;att name="actual\\_range" [type="floatList"](#attributetype)\\>0.17 23.58&lt;/att>

* यह विशेषता से है [सीडीसी COARDS ](https://ferret.pmel.noaa.gov/noaa_coop/coop_cdf_profile.html) और [CF 1.7+](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) मेटाडाटा मानकों।
* यदि वर्तमान में, यह एक ही डेटा प्रकार के दो मानों की एक सरणी है जो परिवर्तनीय के गंतव्य डेटा प्रकार के रूप में है, तो वास्तविक निर्दिष्ट करना (सैद्धांतिक या अनुमत नहीं) उस चर के लिए डेटा के न्यूनतम और अधिकतम मान।
* यदि डेटा के साथ पैक किया जाता है [ scale\\_factor और/or add\\_offset ](#scale_factor) , actual\\_range इसमें अनपैक्ड मान होना चाहिए और एक ही डेटा प्रकार का अनपैक्ड मान होना चाहिए।
* कुछ डेटा स्रोतों के लिए (उदाहरण के लिए, सभी EDDTableFrom ... फ़ाइलें) , ERDDAP™ निर्धारित करता है actual\\_range प्रत्येक चर की और सेट actual\\_range विशेषता। अन्य डेटा स्रोतों के साथ (उदाहरण के लिए, संबंधिक डेटाबेस, Cassandra, DAP प्रति Hyrax ) , यह सीमा की गणना करने के लिए स्रोत के लिए परेशानी या बोझिल हो सकता है, इसलिए ERDDAP™ यह अनुरोध नहीं करता है। इस मामले में, यदि आप सेट कर सकते हैं तो यह सबसे अच्छा है actual\\_range   (विशेष रूप से देशांतर, अक्षांश, ऊंचाई, गहराई और समय चर के लिए) जोड़कर actual\\_range प्रत्येक चर के लिए विशेषता [&lt; addAttributes &gt; (#addattributs) इस डेटासेट के लिए datasets.xml उदाहरण के लिए,

>    &lt;att name="actual\\_range" [type="doubleList"](#attributetype)\\>-180 180&lt;/att>

* संख्यात्मक के लिए [समय और समय-समय परिवर्तनशील](#time-units) निर्दिष्ट मूल्य प्रासंगिक स्रोत होना चाहिए (गंतव्य नहीं) संख्यात्मक मान। उदाहरण के लिए, यदि स्रोत समय मान को 1985-01-01 के बाद से "दिन" के रूप में संग्रहीत किया जाता है, तो उसके बाद स्रोत समय मान को " 1985-01-01-01-01 के बाद से दिन" के रूप में संग्रहीत किया जाता है। actual\\_range 1985-01-01 के बाद से "दिन" में निर्दिष्ट होना चाहिए। यदि आप अभी तक निकट-वास्तविक समय के डेटा के लिए दूसरे मूल्य के रूप में जाना चाहते हैं, तो आपको NAN का उपयोग करना चाहिए। उदाहरण के लिए, 1985-01-17 की डेटा रेंज को अब तक निर्दिष्ट करने के लिए, उपयोग करें

>    &lt;att name="actual\\_range" [type="doubleList"](#attributetype)\\>16 NaN&lt;/att>

* अगर actual\\_range ज्ञात है ERDDAP™ इसे कैलकुलेट करके या आप इसे जोड़ने के माध्यम से&lt; addAttributes &gt; ERDDAP™ डेटा एक्सेस फॉर्म पर उपयोगकर्ता को प्रदर्शित करेगा ( * datasetID * एचटीएमएल) और बनाना A Graph वेब पृष्ठों ( * datasetID * ग्राफ़) उस डेटासेट के लिए और एफजीडीसी और आईएसओ 19115 मेटाडाटा उत्पन्न करते समय इसका उपयोग करें। इसके अलावा, पिछले 7 दिनों के समय actual\\_range डिफ़ॉल्ट समय सबसेट के रूप में उपयोग किया जाता है।
* अगर actual\\_range ज्ञात है, उपयोगकर्ता उपयोग कर सकते हैं [मिनट () अधिकतम () कार्य](https://coastwatch.pfeg.noaa.gov/erddap/tabledap/documentation.html#min) अक्सर बहुत उपयोगी होता है।
* सभी EDDTable के लिए... डेटासेट, अगर actual\\_range ज्ञात है (आपके द्वारा निर्दिष्ट या इसके द्वारा ERDDAP™ इसे गणना करना) , ERDDAP™ उस रेंज के बाहर डेटा के लिए किसी भी अनुरोध को तुरंत अस्वीकार करने में सक्षम होगा। उदाहरण के लिए, यदि डेटासेट का न्यूनतम समय मान 1985-01-17 से मेल खाता है, तो 1985-01-01 से 1985-01-16 तक सभी डेटा के लिए एक अनुरोध तुरंत त्रुटि संदेश के साथ खारिज कर दिया जाएगा "आपका क्वेरी ने कोई मिलान परिणाम उत्पन्न नहीं किया। यह बनाता है actual\\_range मेटाडाटा का एक बहुत ही महत्वपूर्ण टुकड़ा, क्योंकि यह बचा सकता है ERDDAP™ बहुत सारे प्रयास और उपयोगकर्ता को बहुत समय बचाने के लिए। और यह हाइलाइट्स कि actual\\_range मान डेटा की वास्तविक सीमा से अधिक संकीर्ण नहीं होना चाहिए; अन्यथा, ERDDAP™ हमेशा कह सकते हैं जब वास्तव में प्रासंगिक डेटा होता है तो "कोई मिलान डेटा नहीं है"।
* जब कोई उपयोगकर्ता डेटा की एक सबसेट का चयन करता है और एक फ़ाइल प्रकार का अनुरोध करता है जिसमें मेटाडाटा शामिल है (उदाहरण के लिए, .nc ) , ERDDAP™ संशोधित करना actual\\_range प्रतिक्रिया फ़ाइल में सबसेट की सीमा को प्रतिबिंबित करने के लिए।
* भी देखें [ data\\_min और data\\_max ](#data_min-and-data_max) , जो निर्दिष्ट करने का एक वैकल्पिक तरीका है actual\\_range । हालांकि, अब इनकी व्याख्या की जाती है कि actual\\_range CF 1.7+ द्वारा परिभाषित किया गया है।
         
###### कलर बार एट्रिब्यूट्स{#color-bar-attributes} 
कई वैकल्पिक चर गुण हैं जो एक रंग बार के लिए सुझाए गए डिफ़ॉल्ट विशेषताओं को निर्दिष्ट करते हैं (छवियों पर रंगों में डेटा मूल्यों को परिवर्तित करने के लिए उपयोग किया जाता है) इस चर के लिए।
* यदि वर्तमान में, इस जानकारी का उपयोग ग्रिडडैप द्वारा डिफ़ॉल्ट जानकारी के रूप में किया जाता है और tabledap जब भी आप एक छवि का अनुरोध करते हैं जो रंग बार का उपयोग करता है।
* उदाहरण के लिए, जब अक्षांश-लंबाई ग्रिड डेटा को मानचित्र पर कवरेज के रूप में प्लॉट किया जाता है, तो रंग बार निर्दिष्ट करता है कि डेटा मूल्यों को रंगों में कैसे परिवर्तित किया जाता है।
* इन मूल्यों की अनुमति ERDDAP™ छवियों को बनाने के लिए जो विभिन्न अनुरोधों में एक सुसंगत रंग बार का उपयोग करते हैं, यहां तक कि जब समय या अन्य आयाम मान भिन्न होते हैं।
* इन विशेषताओं में उपयोग के लिए बनाया गया था ERDDAP । वे मेटाडाटा मानक से नहीं हैं।
* रंग बार से संबंधित विशेषताएं हैं:
    *    ** colorBarMinimum ** कलरबार पर न्यूनतम मान निर्दिष्ट करता है। उदाहरण के लिए,

    >    &lt;att name="colorBarMinimum" [type="double"](#attributetype)\\>-5&lt;/att>  

    * यदि डेटा के साथ पैक किया जाता है [ scale\\_factor और/or add\\_offset ](#scale_factor) , निर्दिष्ट करें colorBarMinimum एक अनपैक मूल्य के रूप में।
    * से कम डेटा मान colorBarMinimum उसी रंग के अनुसार प्रतिनिधित्व किया जाता है colorBarMinimum मान
    * विशेषता होना चाहिए [प्रकार="डबल"](#attributetype) , डेटा चर के प्रकार की परवाह किए बिना।
    * मूल्य आमतौर पर एक अच्छा राउंड नंबर होता है।
    * सर्वश्रेष्ठ अभ्यास: हम न्यूनतम डेटा मान से थोड़ा अधिक मूल्य की सिफारिश करते हैं।
    * कोई डिफ़ॉल्ट मान नहीं है।
*    ** colorBarMaximum ** कलरबार पर अधिकतम मान निर्दिष्ट करता है। उदाहरण के लिए,

    >    &lt;att name="colorBarMaximum" [type="double"](#attributetype)\\>5&lt;/att>  

    * यदि डेटा के साथ पैक किया जाता है [ scale\\_factor और/or add\\_offset ](#scale_factor) , निर्दिष्ट करें colorBarMinimum एक अनपैक मूल्य के रूप में।
    * डेटा मान तुलना में अधिक colorBarMaximum उसी रंग के अनुसार प्रतिनिधित्व किया जाता है colorBarMaximum मान
    * विशेषता होना चाहिए [प्रकार="डबल"](#attributetype) , डेटा चर के प्रकार की परवाह किए बिना।
    * मूल्य आमतौर पर एक अच्छा राउंड नंबर होता है।
    * सर्वश्रेष्ठ अभ्यास: हम अधिकतम डेटा मान से थोड़ा कम मूल्य की सिफारिश करते हैं।
    * कोई डिफ़ॉल्ट मान नहीं है।
*    **रंग बारपैलेट** रंगबार के लिए पैलेट निर्दिष्ट करता है। उदाहरण के लिए,
    ```
            <att name="colorBarPalette">WhiteRedBlack</att>
    ```
    * सब ERDDAP™ स्थापना इन मानक पैलेटों का समर्थन करती है: BlackBlueWhite, BlackRedWhite, BlackWhite, BlueWhiteRed, LightRainbow, महासागर, OceanDepth, इंद्रधनुष, RedWhiteBlue, रिवर्सRainbow, स्थलाकृति, TopographyDepth \\[ v1.74 में जोड़ा गया \\] , व्हाइटब्लैक, व्हाइटब्लूब्लैक और व्हाइट रेडब्लैक।
    * यदि आपने स्थापित किया है [अतिरिक्त पैलेट](/docs/server-admin/additional-information#palettes) आप उनमें से एक का उल्लेख कर सकते हैं।
    * यदि यह विशेषता मौजूद नहीं है, तो डिफ़ॉल्ट ब्लू व्हाईट रेड है यदि \\-1\\* colorBarMinimum = colorBarMaximum अन्यथा डिफ़ॉल्ट इंद्रधनुष है।
*    **रंगबारस्केल** रंगबार के लिए पैमाने निर्दिष्ट करता है। उदाहरण के लिए,
    ``` 
            <att name="colorBarScale">Log</att>
    ```
    * वैध मान रैखिक और लॉग हैं।
    * यदि मूल्य लॉग है, colorBarMinimum 0 से अधिक होना चाहिए।
    * यदि यह विशेषता मौजूद नहीं है, तो डिफ़ॉल्ट रैखिक है।
*    **रंग BarContinuous** निर्दिष्ट करता है कि कलरबार में रंगों का निरंतर पैलेट है या क्या कलरबार में कुछ असतत रंग हैं। उदाहरण के लिए,
    ```
            <att name="colorBarContinuous">false</att>
    ```
    * वैध मान वास्तविक और झूठे तार हैं।
    * यदि यह विशेषता मौजूद नहीं है, तो डिफ़ॉल्ट सही है।
*    **रंगबारनेक्शन** रंगबार पर खंडों की डिफ़ॉल्ट संख्या निर्दिष्ट करता है। उदाहरण के लिए,
    ```
            <att name="colorBarNSections" type="int">6</att>
    ```
    * वैध मान सकारात्मक पूर्णांक हैं।
    * यदि यह विशेषता मौजूद नहीं है, तो डिफ़ॉल्ट \\-1 है, जो बताता है ERDDAP™ रंगबार की सीमा के आधार पर वर्गों की संख्या चुनने के लिए।
######  WMS  {#wms} 
एक चर के लिए मुख्य आवश्यकताओं के माध्यम से सुलभ होना ERDDAP ' WMS सर्वर हैं:
* डेटासेट होना चाहिए EDDGrid ... डेटासेट।
* डेटा चर MUST एक ग्रिड चर हो सकता है।
* डेटा चर MUST में देशांतर और अक्षांश अक्ष चर है। (अन्य अक्ष चर वैकल्पिक हैं।) 
* वहाँ -180 और 180 के बीच कुछ देशांतर मान हो सकता है।
* The The most of the colorBarMinimum और colorBarMaximum गुण MUST निर्दिष्ट किया जाना चाहिए। (अन्य रंग बार गुण वैकल्पिक हैं।) 

######  data\\_min और data\\_max  {#data_min-and-data_max} 
*    [ ** data\\_min ** और ** data\\_max ** ](#data_min-and-data_max) -- ये विश्व महासागर परिसंचरण प्रयोग में परिभाषित वैरिएबल विशेषताओं की व्याख्या कर रहे हैं (WOCE) मेटाडाटा विवरण। उदाहरण के लिए,

    >    &lt;att name="data\\_min" [type="float"](#attributetype)\\>0.17&lt;/att>  
    >    &lt;att name="data\\_max" [type="float"](#attributetype)\\>23.58&lt;/att>

    * हम अनुशंसा करते हैं कि आप उपयोग करें [ actual\\_range ](#actual_range) इसके बजाय data\\_min और data\\_max क्योंकि actual\\_range अब CF विनिर्देश द्वारा परिभाषित किया गया है।
    * यदि वर्तमान में, उन्हें वैरिएबल के गंतव्य डेटा प्रकार के समान डेटा टाइप होना चाहिए और वास्तविक निर्दिष्ट करना चाहिए (सैद्धांतिक या अनुमत नहीं) उस चर के लिए डेटा के न्यूनतम और अधिकतम मान।
    * यदि डेटा के साथ पैक किया जाता है [ scale\\_factor और/or add\\_offset ](#scale_factor) , data\\_min और data\\_max अनपैक्ड डेटा प्रकार का उपयोग करके अनपैक्ड मान होना चाहिए।
         
###### चर drawLandMask  {#variable-drawlandmask} 
*    [ ** drawLandMask ** ](#variable-drawlandmask) -- यह एक वैकल्पिक परिवर्तनीय विशेषता है जिसका उपयोग करके किया जाता है ERDDAP™   (कोई मेटाडाटा मानकों) जो डेटासेट के मेक ए ग्राफ फॉर्म पर "ड्रॉ लैंड मास्क" विकल्प के लिए डिफ़ॉल्ट मान निर्दिष्ट करता है ( * datasetID * ग्राफ़) और एक URL में &.land पैरामीटर के लिए डेटा के नक्शे का अनुरोध करता है। उदाहरण के लिए,
    ```
        <att name="drawLandMask">under</att>  
    ```
देखें [ drawLandMask अवलोकन](#drawlandmask) ।
###### एन्कोडिंग{#encoding} 
*    [ **हिन्दी** ](#encoding) 
    * यह विशेषता केवल स्ट्रिंग चर के साथ इस्तेमाल किया जा सकता है।
    * इस विशेषता की दृढ़ता से अनुशंसा की जाती है।
    * यह विशेषता से है [ NetCDF उपयोगकर्ता गाइड (एनयूजी) ](https://docs.unidata.ucar.edu/netcdf-java/current/userguide/index.html) ।
    * आंतरिक रूप से ERDDAP™ स्ट्रिंग 2-बाइट वर्णों का एक अनुक्रम है जो 2-बाइट वर्णों का उपयोग करते हैं [यूनिकोड UCS-2 वर्ण सेट](https://en.wikipedia.org/wiki/UTF-16) ।
    * कई फ़ाइल प्रकार केवल स्ट्रिंग्स में 1-बाइट वर्णों का समर्थन करते हैं और इस प्रकार इस विशेषता को एक संबद्ध की पहचान करने की आवश्यकता होती है।
         [Charset (AKA code page) ](https://en.wikipedia.org/wiki/Code_page) जो परिभाषित करता है कि कैसे 256 संभावित मूल्यों को UCS-2 चरित्र सेट और/या एन्कोडिंग सिस्टम से खींचे गए 256 वर्णों के एक सेट के लिए, उदाहरण के लिए, [UTF-8](https://en.wikipedia.org/wiki/UTF-8)   (जिसकी आवश्यकता 1 और 4 बाइट्स प्रति चरित्र के बीच है) ।
    * \\_Encoding के लिए मान केस-असंवेदनशील हैं।
    * सिद्धांत में, ERDDAP™ \\_Encoding पहचानकर्ता का समर्थन कर सकता है [इस आईएएनए सूची](https://www.iana.org/assignments/character-sets/character-sets.xhtml) लेकिन व्यवहार में, ERDDAP™ वर्तमान में सिर्फ समर्थन
        * ISO-8859-1 (ध्यान दें कि इसमें डैश है, अंडरस्कोर नहीं है) इसका लाभ यह है कि यह यूनिकोड के पहले 256 अक्षरों के समान है, और
        * UTF-8
    * जब स्रोत फ़ाइलों को पढ़ने के लिए, डिफ़ॉल्ट मान ISO-8859-1 है, Netcdf-4 फ़ाइलों को छोड़कर जहां डिफ़ॉल्ट UTF-8 है।
    * यह एक चल समस्याग्रस्त मुद्दा है क्योंकि कई स्रोत फाइलें charsets या encodings का उपयोग करती हैं जो ISO-8859-1 से अलग हैं, लेकिन charset या encoding की पहचान नहीं करते हैं। उदाहरण के लिए, कई स्रोत डेटा फ़ाइलों में Windows पर Microsoft Word से कॉपी और चिपकाए गए कुछ मेटाडाटा है और इस प्रकार ASCII hyphens और apostrophes के बजाय Windows-विशिष्ट charset से फैंसी hyphens और apostrophes हैं। इसके बाद ये वर्ण अजीब अक्षरों या '?' के रूप में दिखाई देते हैं? ERDDAP ।
         
###### फ़ाइल AccessBaseUrl{#fileaccessbaseurl} 
*    ** [फ़ाइल AccessBaseUrl](#fileaccessbaseurl) फ़ाइल** शायद ही कभी उपयोग किए जाने वाले गुण हैं जो किसी भी मानक से नहीं हैं। यदि एक EDDTable कॉलम में वेब सुलभ फ़ाइलों के नाम हैं (उदाहरण के लिए, छवि, वीडियो, या ऑडियो फ़ाइलों) , आप जोड़ सकते हैं
```
    <att name="fileAccessBaseUrl">*someBaseURL*</a>  
```
आधार URL निर्दिष्ट करने के लिए (के साथ समाप्त /) फ़ाइल नाम को पूर्ण यूआरएल में बनाने की आवश्यकता है। असामान्य मामलों में, जैसे कि जब कॉलम में .png फ़ाइलों का संदर्भ होता है लेकिन मानों में ".png" की कमी होती है, तो आप जोड़ सकते हैं।
```
    <att name="fileAccessSuffix">*someSuffix*</a>  
```
(उदाहरण के लिए)&lt;att name="fileAccessSuffix"&gt;.png&lt;/a&gt;
फ़ाइल नाम को पूर्ण यूआरएल में बनाने के लिए एक प्रत्यय को जोड़ने के लिए निर्दिष्ट करने के लिए। फिर .htmlTable जवाब, ERDDAP™ पूर्ण यूआरएल के लिए एक लिंक के रूप में फ़ाइल नाम दिखाएंगे (आधार Url प्लस फाइल नाम प्लस प्रत्यय) ।

यदि आप चाहते हैं ERDDAP™ संबंधित फ़ाइलों की सेवा करने के लिए, एक अलग बनाएं [EDDTableFromFileNames](#eddtablefromfilenames) उन फ़ाइलों के लिए डेटासेट (यह एक निजी डेटासेट हो सकता है) ।
    
###### फ़ाइल Url{#fileaccessarchiveurl} 
*    [ **फ़ाइल Url** ](#fileaccessarchiveurl) शायद ही कभी इस्तेमाल किया जाने वाला गुण है जो किसी भी मानक से नहीं है। यदि एक EDDTable कॉलम में वेब सुलभ फ़ाइलों के नाम हैं (उदाहरण के लिए, छवि, वीडियो, या ऑडियो फ़ाइलों) जो एक संग्रह के माध्यम से सुलभ हैं (उदाहरण के लिए .zip फ़ाइल) यूआरएल के माध्यम से सुलभ, उपयोग&lt;att name="fileAccessArchiveUrl"&gt; *यूआरएल* &lt;/att&gt; संग्रह के लिए यूआरएल निर्दिष्ट करने के लिए।
    
यदि आप चाहते हैं ERDDAP™ संग्रह फ़ाइल की सेवा करने के लिए, एक अलग बनाएं [EDDTableFromFileNames](#eddtablefromfilenames) उस फ़ाइल के लिए डेटासेट (यह एक निजी डेटासेट हो सकता है) ।
    
######  ioos\\_category  {#ioos_category} 
*    [ ** ioos\\_category ** ](#ioos_category) -- यह एक नियमित परिवर्तनीय विशेषता है यदि&lt;चर MustHaveIoosCategory&gt; को सही करने के लिए सेट किया गया है (डिफ़ॉल्ट) में [साइटमैप](/docs/server-admin/deploy-install#setupxml) अन्यथा, यह वैकल्पिक है।
उदाहरण के लिए,&lt;att name ioos\\_category &gt;सैलिनिटी&lt;/att&gt;
श्रेणियों से हैं [ NOAA एकीकृत महासागर अवलोकन प्रणाली (आईओएस) ](https://ioos.noaa.gov/) ।
    
    *    (इसे लिखने के रूप में) हम इन नामों की औपचारिक परिभाषाओं के बारे में नहीं जानते हैं।
    * मुख्य नाम Zdenka Willis's.ppt "Integrated Ocean अवलोकन प्रणाली" से हैं (आईओएस)   NOAA एक प्रारंभिक ऑपरेटिंग क्षमता के निर्माण के लिए दृष्टिकोण [यूएस आईओएस ब्लूप्रिंट](https://www.iooc.us/wp-content/uploads/2010/11/US-IOOS-Blueprint-for-Full-Capability-Version-1.0.pdf)   (पृष्ठ 1-5) ।
    * यह संभावना है कि इस सूची को भविष्य में संशोधित किया जाएगा। यदि आपके पास अनुरोध है, तो कृपया क्रिस को ईमेल करें। जॉन at noaa.gov.
    *    ERDDAP™ IOOS की तुलना में श्रेणियों की एक बड़ी सूची का समर्थन करता है क्योंकि बॉब सिमोन ने अतिरिक्त नाम जोड़े (ज्यादातर वैज्ञानिक क्षेत्रों के नामों पर आधारित, उदाहरण के लिए, जीवविज्ञान, पारिस्थितिकी, मौसम विज्ञान, सांख्यिकी, वर्गीकरण) अन्य प्रकार के डेटा के लिए।
    * वर्तमान में मान्य मान ERDDAP™ बाथीमेट्री, बायोलॉजी, बॉटम कैरेक्टर, CO2, रंगीन भंग कार्बनिक पदार्थ, दूषित पदार्थ, धाराएं, भंग पोषक तत्व, भंग O2, पारिस्थितिकी, मछली बहुतायत, मछली प्रजातियां, फ्लक्स, जल विज्ञान, बर्फ वितरण, पहचानकर्ता, स्थान, मौसम विज्ञान, महासागर रंग, ऑप्टिकल गुण, अन्य, रोगजनक, Phytoplankton प्रजातियां, दबाव, उत्पादकता, गुणवत्ता, लवणता, सागर स्तर, सांख्यिकी, स्ट्रीम प्रवाह, सतह लहरें, वर्गीकरण, समय, कुल निलंबित पदार्थ, अज्ञात, हवा, Zooplanktonies, Abundtons and Zooplanktons।
    * विभिन्न शब्दों के बीच कुछ ओवरलैप और अस्पष्टता है - अपना सर्वश्रेष्ठ कार्य करें।
    * यदि आप जोड़ते हैं ioos\\_category सूची&lt; categoryAttributes &gt; में ERDDAP ' [साइटमैप](/docs/server-admin/deploy-install#setupxml) फ़ाइल, उपयोगकर्ता आसानी से डेटासेट को समान डेटा के माध्यम से ढूंढ सकते हैं ERDDAP होम पेज पर "वर्ग द्वारा डेटासेट के लिए खोज"।
         [प्रयोग ioos\\_category ब्याज के डेटासेट की खोज करने के लिए।](https://coastwatch.pfeg.noaa.gov/erddap/categorize/ioos_category/index.html?page=1&itemsPerPage=1000) 
    * वहाँ था [चर्चा ERDDAP™ और ioos\\_category में ERDDAP™ गूगल ग्रुप](https://groups.google.com/forum/#!topic/erddap/TnwbgzpSS0w) 
    
आपको सेट करने के लिए लुभाया जा सकता है&lt;चर MustHaveIoosCategory&gt; झूठी है ताकि इस विशेषता की आवश्यकता नहीं है। ("Pfft&#33; मुझे क्या है?) कुछ कारणों से यह सच करने के लिए सेट करने के लिए (डिफ़ॉल्ट) उपयोग ioos\\_category हैं:
    
    * अगर सेटअप.xml है&lt;चर MustHaveIoosCategory&gt; सही करने के लिए सेट है, [जनरेट DatasetXml](#generatedatasetsxml) हमेशा एक बनाता है / बनाता है ioos\\_category प्रत्येक नए डेटासेट में प्रत्येक चर के लिए विशेषता। क्यों न केवल इसे छोड़ें?
    *    ERDDAP™ उपयोगकर्ताओं को श्रेणी के आधार पर ब्याज के डेटासेट की खोज करने देता है। ioos\\_category एक बहुत ही उपयोगी खोज श्रेणी है क्योंकि ioos \\_categories (उदाहरण के लिए, तापमान) काफी व्यापक हैं। यह बनाता है ioos\\_category इस उद्देश्य के लिए बेहतर, उदाहरण के लिए, बहुत ज्यादा बारीक सीएफ standard\\_name s (जो इस उद्देश्य के लिए इतना अच्छा नहीं है क्योंकि सभी समानार्थक शब्द और मामूली विविधताओं के कारण, उदाहरण के लिए, समुद्र \\_surface \\_temperature बनाम समुद्र तट) ।
(Using) ioos\\_category इस उद्देश्य के लिए नियंत्रित किया जाता है&lt; categoryAttributes &gt; अपने सेटअप.xml फ़ाइल में।
         [प्रयोग ioos\\_category ब्याज के डेटासेट की खोज करने के लिए।](https://coastwatch.pfeg.noaa.gov/erddap/categorize/ioos_category/index.html?page=1&itemsPerPage=1000) 
    * ये श्रेणियां हैं [ NOAA एकीकृत महासागर अवलोकन प्रणाली (आईओएस) ](https://ioos.noaa.gov/) । ये श्रेणियां आईओओएस के मिशन के आईओओएस के विवरण के लिए मौलिक हैं। यदि आप NOAA समर्थन ioos\\_category अच्छा है एक NOAA क्या करना है। (इसे देखें [एक NOAA वीडियो](https://www.youtube.com/watch?v=nBnCsMYm2yQ) और प्रेरित होना&#33;) यदि आप कुछ अन्य अमेरिकी या अंतर्राष्ट्रीय एजेंसी में हैं, या सरकारी एजेंसियों के साथ काम करते हैं, या कुछ अन्य महासागर अवलोकन प्रणाली के साथ काम करते हैं, तो क्या यह अमेरिकी IOOS कार्यालय के साथ सहयोग करने का एक अच्छा विचार नहीं है?
    * जल्द ही, आप कुछ अन्य चाहते हैं ERDDAP™ अपने डेटासेट के माध्यम से लिंक करने के लिए [ EDDGrid सेंध](#eddfromerddap) और [EDDTableFromErddap](#eddfromerddap) । यदि अन्य ERDDAP™ आवश्यकता ioos\\_category अपने डेटासेट होना चाहिए ioos\\_category आदेश EDDGrid Erddap और EDDTableFromErddap से काम करने के लिए।
    * इसमें शामिल होना मनोवैज्ञानिक रूप से बहुत आसान है ioos\\_category जब आप डेटासेट बनाते हैं (यह सिर्फ एक और चीज है कि ERDDAP™ डेटासेट को जोड़ने की आवश्यकता है ERDDAP ) इस तथ्य के बाद इसे जोड़ने की तुलना में (यदि आप भविष्य में इसका उपयोग करने का फैसला करते हैं) ।
         
######  long\\_name  {#long_name} 
*    [ ** long\\_name ** ](#long_name)   ( [ COARDS ](https://ferret.pmel.noaa.gov/noaa_coop/coop_cdf_profile.html) , [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) और [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानकों) में एक RECOMMENDED चर विशेषता है ERDDAP । उदाहरण के लिए,
    ```
        <att name="long\\_name">Eastward Sea Water Velocity</att>
    ```
    *    ERDDAP™ उपयोग long\\_name ग्राफ़ पर अक्षों को लेबल करने के लिए।
    * सर्वश्रेष्ठ अभ्यास: शब्दों में कैपिटल करें long\\_name जैसा कि यह एक शीर्षक था (पहले शब्द और सभी गैर-आर्टिकल शब्दों को कैपिटल करें) । में इकाइयों को शामिल न करें long\\_name । लंबे नाम को बहुत लंबा नहीं होना चाहिए (आमतौर पर)&lt;20 वर्ण), लेकिन अधिक वर्णनात्मक होना चाहिए [ destinationName ](#destinationname) , जो अक्सर बहुत संक्षिप्त होता है।
    * यदि long\\_name " चर में परिभाषित नहीं है [स्रोतAttributes](#variable-addattributes) या&lt; addAttributes &gt; ERDDAP™ इसे सफाई करके उत्पन्न करेगा [ standard\\_name ](#standard_name)   (यदि) या destinationName ।
         
######  missing\\_value  {#missing_value} 
*    [ ** missing\\_value ** ](#missing_value) और **\\_Fill मूल्य**   ( [ COARDS ](https://ferret.pmel.noaa.gov/noaa_coop/coop_cdf_profile.html) और [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) ) वेरिएबल गुण हैं जो एक संख्या का वर्णन करते हैं (उदाहरण के लिए, -9999) जिसका उपयोग लापता मूल्य का प्रतिनिधित्व करने के लिए किया जाता है। उदाहरण के लिए,

>  &lt;att name="missing\\_value" [type="double"](#attributetype)\\>-9999&lt;/att>  

स्ट्रिंग चर के लिए, दोनों के लिए डिफ़ॉल्ट "" है (खाली स्ट्रिंग) ।
संख्यात्मक चर के लिए, दोनों के लिए डिफ़ॉल्ट NaN है।
*    ERDDAP™ दोनों का समर्थन missing\\_value \\_FillValue, चूंकि कुछ डेटा स्रोत उन्हें थोड़ा अलग अर्थ देते हैं।
* यदि वर्तमान में, वे चर के रूप में एक ही डेटा प्रकार का होना चाहिए।
* यदि डेटा के साथ पैक किया जाता है [ scale\\_factor और/or add\\_offset ](#scale_factor) , missing\\_value \\_FillValue मूल्यों को इसी तरह पैक किया जाना चाहिए। इसी तरह, स्ट्रिंग डेट / टाइम वैल्यू वाले कॉलम के लिए जो स्थानीय लोगों का उपयोग करते हैं [ time\\_zone ](#time_zone) , missing\\_value और \\_FillValue मान स्थानीय समय क्षेत्र का उपयोग करना चाहिए।
* यदि कोई परिवर्तनीय इन विशेष मूल्यों का उपयोग करता है, तो वह इन विशेष मूल्यों का उपयोग करता है। missing\\_value and/or \\FillValue विशेषताएँ आवश्यक हैं।
* के लिए [समय और समय-समय परिवर्तनशील](#time-units)   (क्या स्रोत स्ट्रिंग्स या संख्यात्मक है) , missing\\_value S and \\FillValues "" के रूप में दिखाई देते हैं (खाली स्ट्रिंग) जब समय एक स्ट्रिंग के रूप में लिखा जाता है और जब समय एक डबल के रूप में लिखा जाता है तो नैन के रूप में। के लिए स्रोत मान missing\\_value \\_FillValue चर के मेटाडाटा में दिखाई नहीं देगा।
* स्ट्रिंग चर के लिए, ERDDAP™ हमेशा किसी भी रूप में परिवर्तित missing\\_value S or \\FillValue डेटा मान "" में (खाली स्ट्रिंग) । के लिए स्रोत मान missing\\_value \\_FillValue चर के मेटाडाटा में दिखाई नहीं देगा।
* संख्यात्मक चर के लिए:
The The most of the missing\\_value और \\_FillValue चर के मेटाडाटा में दिखाई देगा।
कुछ आउटपुट डेटा प्रारूपों के लिए, ERDDAP™ इन विशेष संख्याओं को बरकरार रखेगा, उदाहरण के लिए, आप -9999 देखेंगे।
अन्य आउटपुट डेटा प्रारूपों के लिए (विशेष रूप से टेक्स्ट-जैसे प्रारूपों जैसे .csv और .htmlTable ) , ERDDAP™ इन विशेष संख्याओं को नान या " के साथ बदल देगा।
* कुछ डेटा प्रकारों में अंतर्निहित लापता मान मार्कर होते हैं जिन्हें स्पष्ट रूप से पहचान करने की आवश्यकता नहीं है missing\\_value या \\_FillValue विशेषताएँ: फ्लोट और डबल वेरिएबल में NaN है (नहीं) , स्ट्रिंग मान खाली स्ट्रिंग का उपयोग करते हैं, और चार मूल्यों में चरित्र होता है \\uffff   (चरित्र #65535, जो यूनिकोड का मूल्य नहीं है चरित्र) । पूर्णांक डेटा प्रकारों में अंतर्निहित लापता मान मार्कर नहीं होते हैं।
* यदि एक पूर्णांक चर में एक लापता मान होता है (उदाहरण के लिए, एक .csv फ़ाइल में खाली स्थान) , ERDDAP™ परिभाषित मान की व्याख्या करेगा missing\\_value उस परिवर्तनीय के लिए \\_FillValue। यदि कोई परिभाषित नहीं है, ERDDAP™ उस डेटा प्रकार के लिए डिफ़ॉल्ट लापता मान के रूप में मूल्य की व्याख्या करेगा, जो हमेशा अधिकतम मान होता है जो उस डेटा प्रकार द्वारा आयोजित किया जा सकता है:
127 बाइट वेरिएबल, 32767 शॉर्ट के लिए, 2147483647 int के लिए, 9223372036854775807 लंबे समय तक
Ubyte के लिए 255, ushort के लिए 65535, Uint के लिए 4294967295, और 18446744073709551615 ulong के लिए।
######  ADD \\_FillValue ATTRIBUTES ?{#add-_fillvalue-attributes} 
*    [ ADD \\_FillValue ATTRIBUTES ?](#add-_fillvalue-attributes)   
हर बार ERDDAP™ डेटासेट लोड करता है, यह जांचता है कि अगर पूर्णांक स्रोत डेटा प्रकारों के साथ चर में एक परिभाषित होता है missing\\_value या \\_FillValue विशेषता। यदि कोई परिवर्तनीय नहीं है, तो फिर ERDDAP™ लॉग फ़ाइल में एक संदेश प्रिंट करता है ("Add \\_FillValue Attribute" के साथ शुरू?) यह सिफारिश करते हुए कि ERDDAP™ व्यवस्थापक \\Fill जोड़ें में इस चर के लिए मूल्य विशेषता datasets.xml । यह हर परिवर्तनीय के लिए एक \\FillValue या होना बहुत उपयोगी है missing\\_value क्योंकि लापता मान हमेशा संभव होते हैं, उदाहरण के लिए, यदि किसी डेटासेट में दी गई फ़ाइल में कोई परिवर्तनीय नहीं होता है, ERDDAP™ उस चर के लिए सभी लापता मूल्यों के रूप में उस चर को पेश करने में सक्षम होना चाहिए। यदि आप एक चर का निर्णय लेते हैं तो उसे \\FillValue विशेषता नहीं होनी चाहिए, तो आप जोड़ सकते हैं
    &lt;att name="\\_FillValue"&gt; null&lt;इसके बजाय /att&gt;, जो उस संदेश को दबा देगा datasetID भविष्य में परिवर्तनीय संयोजन।
    
हर बार ERDDAP™ शुरू होता है, यह उन सभी सिफारिशों को एक संदेश में एकत्र करता है जो लॉग फ़ाइल में लिखा जाता है (शुरू ADD \\_FillValue ATTRIBUTES क्या?) ईमेल ERDDAP™ व्यवस्थापक और एक CSV डेटा फ़ाइल में लिखा \\[ बड़ाParentDirectory \\] /logs/ निर्देशिका। यदि आप चाहते हैं, तो आप GenerateDatasetsXml प्रोग्राम का उपयोग कर सकते हैं (और AddFillValueAttributes विकल्प) CSV फ़ाइल में सभी सुझावों को लागू करने के लिए datasets.xml फ़ाइल किसी के लिए datasetID उस फ़ाइल में परिवर्तनीय संयोजन, यदि आप निर्णय लेते हैं तो जिम्मेदार जोड़ने की कोई आवश्यकता नहीं है, तो आप विशेषता को बदल सकते हैं&lt;att name="\\_FillValue"&gt; null&lt;उसके लिए सिफारिश को दबाने के लिए /att&gt; datasetID भविष्य में परिवर्तनीय संयोजन।
    
यह महत्वपूर्ण है&#33;
जैसा कि बॉब ने अक्सर कहा है: यह बुरा होगा (शर्मनाक) यदि वैश्विक वार्मिंग के कुछ सबूत डेटा में अज्ञात लापता मूल्यों के कारण हुए थे (उदाहरण के लिए, 99 या 127 डिग्री के तापमान मान C जिसे लापता मान के रूप में चिह्नित किया जाना चाहिए और इस प्रकार मध्य और / या मध्यकालीन आँकड़ों को उच्चतर बताया गया है।) ।

* \\_FillValue और missing\\_value विभिन्न स्रोत फ़ाइलों में दिए गए चर के लिए मान सुसंगत होना चाहिए; अन्यथा, ERDDAP™ फ़ाइलों को मानों के एक सेट के साथ स्वीकार करेगा और अन्य सभी फाइलों को "Bad Files" के रूप में अस्वीकार करेगा। समस्या को हल करने के लिए,
    * यदि फ़ाइलों को ग्रिड किया जाता है .nc फ़ाइलें, आप उपयोग कर सकते हैं [ EDDGrid से NcFilesUnpacked](#eddgridfromncfilesunpacked) ।
    * यदि फाइलें सारणीबद्ध डेटा फाइलें हैं, तो आप EDDTableFrom का उपयोग कर सकते हैं। ' [मानकीकरण क्या](#standardizewhat) बताने के लिए ERDDAP स्रोत फ़ाइलों को मानकीकृत करने के लिए क्योंकि उन्हें पढ़ा जाता है ERDDAP ।
    * कठिन समस्याओं के लिए, आप उपयोग कर सकते हैं [एनसीएमएल](#ncml-files) या [ NCO ](#netcdf-operators-nco) समस्या को हल करने के लिए।
             
######  scale\\_factor  {#scale_factor} 
*    [ ** scale\\_factor ** ](#scale_factor)   (डिफ़ॉल्ट = 1) और ** add\\_offset **   (डिफ़ॉल्ट = 0)   ( [ COARDS ](https://ferret.pmel.noaa.gov/noaa_coop/coop_cdf_profile.html) और [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) ) वैकल्पिक चर गुण हैं जो डेटा का वर्णन करते हैं जो एक सरल रूपांतरण के माध्यम से एक सरल डेटा प्रकार में पैक किया जाता है।
    * यदि वर्तमान में, उनका डेटा प्रकार स्रोत डेटा प्रकार से अलग है और गंतव्य मूल्यों के डेटा प्रकार का वर्णन करता है।
उदाहरण के लिए, एक डेटा स्रोत ने फ्लोट डेटा मानों को एक दशमलव अंक के साथ संग्रहीत किया हो सकता है जो शॉर्ट इंट्स के रूप में पैक किया गया है (int16) उपयोग scale\\_factor = 0.1 और add\\_offset = 0. उदाहरण के लिए,

    >    &lt;att name="scale\\_factor" [type="float"](#attributetype)\\>0.1&lt;/att>  
    >    &lt;att name="add\\_offset" [type="float"](#attributetype)\\>0&lt;/att>  

इस उदाहरण में, ERDDAP™ डेटा को अनपैक करेगा और इसे उपयोगकर्ता को फ्लोट डेटा मान के रूप में पेश करेगा।
    * यदि उपस्थित हो, ERDDAP™ इन विशेषताओं से मूल्यों को निकालेगा, विशेषताओं को हटा देगा और उपयोगकर्ता के लिए डेटा को स्वचालित रूप से अनपैक करेगा:
गंतव्य मूल्य = स्रोत मान scale\\_factor + add\\_offset   
या, दूसरे तरीके से कहा:
UnpackedValue = पैक मान scale\\_factor + add\\_offset 
    * The The most of the scale\\_factor और add\\_offset विभिन्न स्रोत फ़ाइलों में दिए गए चर के लिए मान सुसंगत होना चाहिए; अन्यथा, ERDDAP™ फ़ाइलों को मानों के एक सेट के साथ स्वीकार करेगा और अन्य सभी फाइलों को "Bad Files" के रूप में अस्वीकार करेगा। समस्या को हल करने के लिए,
        * यदि फ़ाइलों को ग्रिड किया जाता है .nc फ़ाइलें, आप उपयोग कर सकते हैं [ EDDGrid से NcFilesUnpacked](#eddgridfromncfilesunpacked) ।
        * यदि फाइलें सारणीबद्ध डेटा फाइलें हैं, तो आप EDDTableFrom का उपयोग कर सकते हैं। ' [मानकीकरण क्या](#standardizewhat) बताने के लिए ERDDAP स्रोत फ़ाइलों को मानकीकृत करने के लिए क्योंकि उन्हें पढ़ा जाता है ERDDAP ।
        * कठिन समस्याओं के लिए, आप उपयोग कर सकते हैं [एनसीएमएल](#ncml-files) या [ NCO ](#netcdf-operators-nco) समस्या को हल करने के लिए।
             
######  standard\\_name  {#standard_name} 
*    [ ** standard\\_name ** ](#standard_name)   (से [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) मेटाडाटा मानक) में एक RECOMMENDED चर विशेषता है ERDDAP । CF अनुमति की सूची बनाए रखता है [CF मानक नाम](https://cfconventions.org/Data/cf-standard-names/current/build/cf-standard-name-table.html) । उदाहरण के लिए,
    ```
        <att name="standard\\_name">eastward\\_sea\\_water\\_velocity</att>
    ```
    * यदि आप जोड़ते हैं standard\\_name चर' विशेषताओं के लिए और जोड़ें standard\\_name सूची&lt; categoryAttributes &gt; में ERDDAP ' [साइटमैप](/docs/server-admin/deploy-install#setupxml) फ़ाइल, उपयोगकर्ता आसानी से डेटासेट को समान डेटा के माध्यम से ढूंढ सकते हैं ERDDAP होम पेज पर "वर्ग द्वारा डेटासेट के लिए खोज"।
    * यदि आप एक CF निर्दिष्ट करते हैं standard\\_name एक चर के लिए, वेरिएबल के लिए यूनिट विशेषता को सीएफ स्टैंडर्ड नेम टेबल में मानक नाम के लिए निर्दिष्ट कैनोनिकल यूनिट्स के समान नहीं होना चाहिए, लेकिन यूनिट MUST कैनोनिकल यूनिट्स के लिए परिवर्तनीय हो सकती है। उदाहरण के लिए, सभी तापमान से संबंधित CF standard\\_name एस "K" है (केल्विन) कैनोनिकल इकाइयों के रूप में। तो तापमान से संबंधित एक चर standard\\_name MUST में K, डिग्री \\_C, डिग्री \\_F, या उन नामों के कुछ UDUnits संस्करण की इकाइयां हैं, क्योंकि वे सभी परिवर्तनीय हैं।
    * सर्वश्रेष्ठ अभ्यास: शक्ति का हिस्सा [नियंत्रित शब्दावली](https://en.wikipedia.org/wiki/Controlled_vocabulary) सूची में केवल शर्तों का उपयोग करने से आता है। इसलिए हम नियंत्रित शब्दावली में परिभाषित शर्तों से चिपके रहने की सलाह देते हैं, और यदि सूची में कोई उपयुक्त नहीं है तो हम एक शब्द बनाने के खिलाफ सलाह देते हैं। यदि आपको अतिरिक्त शर्तों की आवश्यकता है, तो देखें कि मानक समिति उन्हें नियंत्रित शब्दावली में जोड़ देगी।
    *    standard\\_name मान केवल CF विशेषता मान हैं जो मामले संवेदनशील हैं। वे हमेशा सभी लोअरकेस होते हैं। शुरू ERDDAP™ v1.82, जेनरेटडाटासेट ऊपरी केस अक्षरों को लोअरकेस अक्षरों में बदल देगा। जब डेटासेट में लोड हो जाता है ERDDAP , अपरकेस अक्षरों को चुपचाप लोअरकेस अक्षरों में बदल दिया जाता है।
         
######  time\\_precision  {#time_precision} 
*    time\\_precision द्वारा उपयोग की जाने वाली एक वैकल्पिक विशेषता है ERDDAP™   (कोई मेटाडाटा मानकों) के लिए [समय और समय-समय परिवर्तनशील](#time-units) , जो ग्रिड डेटासेट या सारणीबद्ध डेटासेट में हो सकता है, और इसमें axisVariable या dataVariable S. उदाहरण के लिए,
    ```
        <att name="time\\_precision">1970-01-01</att>  
    ```
     time\\_precision जब भी इस्तेमाल किया जा करने के लिए परिशुद्धता निर्दिष्ट ERDDAP™ उस परिवर्तनीय से समय मूल्यों को वेब पृष्ठों पर स्ट्रिंग के रूप में प्रारूपित करता है, जिसमें शामिल हैं .htmlTable प्रतिक्रियाएं। जहां फ़ाइल स्वरूपों में ERDDAP™ तार के रूप में प्रारूपों का समय (उदाहरण के लिए, .csv और .json ) , ERDDAP™ केवल उपयोग करता है time\\_precision - निर्दिष्ट प्रारूप यदि इसमें आंशिक सेकंड शामिल है; अन्यथा, ERDDAP™ 1970-01-01T00:00:00 Z प्रारूप।
* मान्य मान 1970-01, 1970-01-01, 1970-01-01T00Z, 1970-01-01T00:00Z, 1970-01-01T00:00:00Z (डिफ़ॉल्ट) , 1970-01-01T00:00:00.0Z, 1970-01-01T00:00:00:00:00.00Z, 1970-01-01T00:00:00.000Z. \\[ 1970 एक विकल्प नहीं है क्योंकि यह एक एकल संख्या है, इसलिए ERDDAP™ यह नहीं जानता कि यह एक स्वरूपित समय स्ट्रिंग है (साल) या यदि यह 1970-01-01T00:00:00Z के बाद से कुछ सेकंड है। \\] 
* अगर time\\_precision निर्दिष्ट नहीं है या मूल्य मिलान नहीं है, डिफ़ॉल्ट मान का उपयोग किया जाएगा।
* यहां के अन्य हिस्सों में ERDDAP™ , स्वरूपित समय कि प्रदर्शित नहीं कर रहे हैं के किसी भी क्षेत्र न्यूनतम मूल्य माना जाता है। उदाहरण के लिए, 1985-07, 1985-07-01, 1985-07-01T00Z, 1985-07-01T00:00Z, और 1985-07-01T00:00:00 Z सभी को समतुल्य माना जाता है, हालांकि परिशुद्धता के विभिन्न स्तरों में निहित है। यह मैच [आईएसओ 8601:2004 "extended" समय प्रारूप विनिर्देश](https://www.iso.org/iso/date_and_time_format) ।
*    **चेतावनी:** आपको केवल सीमित उपयोग करना चाहिए time\\_precision अगर **सब** चर के लिए डेटा मानों का केवल उन सभी क्षेत्रों के लिए न्यूनतम मूल्य है जो छिपे हुए हैं।
    * उदाहरण के लिए, आप एक उपयोग कर सकते हैं time\\_precision 1970-01-01 यदि सभी डेटा मानों में घंटे = 0, मिनट = 0 और दूसरा = 0 है (उदाहरण के लिए 2005-03-04T00:00:00Z और 2005-03-05T00:00:00Z) ।
    * उदाहरण के लिए, उपयोग न करें time\\_precision 1970-01-01 अगर कोई 0 घंटे, मिनट, या सेकंड के मान हैं, (उदाहरण के लिए 2005-03-05T12:00Z) क्योंकि गैर-डिफ़ॉल्ट घंटे का मूल्य प्रदर्शित नहीं किया जाएगा। अन्यथा, यदि कोई उपयोगकर्ता समय = 2005-03-05 के साथ सभी डेटा के लिए पूछता है, तो अनुरोध अप्रत्याशित रूप से विफल हो जाएगा।
             
######  time\\_zone  {#time_zone} 
*    [ ** time\\_zone ** ](#time_zone) 
    *    time\\_zone द्वारा उपयोग की जाने वाली एक वैकल्पिक विशेषता है ERDDAP™   (कोई मेटाडाटा मानकों) के लिए [समय और समय-समय परिवर्तनशील](#time-units) , जो ग्रिड डेटासेट या सारणीबद्ध डेटासेट में हो सकता है।
    * डिफ़ॉल्ट " है Zulu " (जो GMT का आधुनिक समय क्षेत्र संस्करण है) ।
    * पृष्ठभूमि की जानकारी: "टाइम ऑफ़सेट" (उदाहरण के लिए, प्रशांत मानक समय, -08:00, GMT-8) निर्धारित, विशिष्ट, ऑफसेट के सापेक्ष हैं Zulu   (GMT) । इसके विपरीत, "टाइम जोन" डेलाइट सेविंग से प्रभावित होने वाली अधिक जटिल चीजें हैं (उदाहरण के लिए, "यूएस / प्रशांत") अलग-अलग स्थानों पर अलग-अलग नियमों का पालन किया जाता है। समय क्षेत्र हमेशा नाम होते हैं क्योंकि उन्हें एक सरल ऑफसेट मान द्वारा संक्षेपित नहीं किया जा सकता है (तालिका में "TZ डेटाबेस नाम" कॉलम देखें [https://en.wikipedia.org/wiki/List\\_of\\_tz\\_database\\_time\\_zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) ) । ERDDAP ' time\\_zone विशेषता आपको कुछ समय क्षेत्र से स्थानीय समय डेटा से निपटने में मदद करती है (उदाहरण के लिए, 1987-03-25T17:32:05 प्रशांत समय) । यदि आपके पास स्ट्रिंग या संख्यात्मक समय डेटा है, तो एक साथ (निर्धारित) टाइम ऑफ़सेट, आपको बस डेटा को समायोजित करना चाहिए Zulu   (क्या है ERDDAP™ करना) इकाई विशेषता में एक अलग आधार समय निर्दिष्ट करके (उदाहरण के लिए, " 1970-01-01T08:00:00Z के बाद से घंटे", टाइम ऑफ़सेट को निर्दिष्ट करने के लिए T08 को नोट करें) यह सुनिश्चित करने के लिए कि आप चाहते हैं कि परिणाम प्राप्त करें।
    * स्ट्रिंग्स से स्रोत डेटा के साथ टाइमस्टैम्प चर के लिए, यह विशेषता आपको एक समय क्षेत्र निर्दिष्ट करने देता है जो लीड करता है ERDDAP™ स्थानीय समय क्षेत्र के स्रोत समय को परिवर्तित करने के लिए (कुछ मानक समय में, कुछ डेलाइट सेविंग टाइम में) में Zulu बार (जो हमेशा मानक समय में होते हैं) । मान्य समय क्षेत्र नामों की सूची शायद TZ कॉलम में सूची के समान है। [https://en.wikipedia.org/wiki/List\\_of\\_tz\\_database\\_time\\_zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) । आम अमेरिकी समय क्षेत्र हैं: US / Hawaii, US / Alaska, US / Pacific, US / Mountain, US / Arizona, US / Central, US / Eastern.
    * न्यूमेरिक स्रोत डेटा के साथ टाइमस्टैम्प चर के लिए, आप निर्दिष्ट कर सकते हैं " time\\_zone " विशेषता, लेकिन मान होना चाहिए " Zulu यूटीसी यदि आपको अन्य समय क्षेत्रों के लिए समर्थन की आवश्यकता है, तो कृपया क्रिस को ईमेल करें। जॉन at noaa.gov.
         
###### legacy_time_adjust{#legacy_time_adjust} 
*    [ **legacy_time_adjust** ](#legacy_time_adjust) शुरू ERDDAP™ 2.29.0, समय चर थोड़ा अलग काम करते हैं। दुर्लभ मामलों में, उपयोग करते समय सबसे अधिक संभावना `दिनों के बाद` और एक साल पहले 1582 (इसलिए `0000-01-01 के बाद से` या `दिन 1-1-1 00:00 से:0.0` ) आपको डेट वेरिएबल के समायोजन के लिए संकेत देने की आवश्यकता होगी। इसका कारण है ERDDAP™ आंतरिक रूप से तारीखों का प्रबंधन करने के लिए जावा टाइम लाइब्रेरी का उपयोग करता है। कुछ डेटासेट हैं जिन्हें सही तिथियों को प्राप्त करने के लिए पुराने ग्रेगोरियनकैलेन्डर लाइब्रेरी का उपयोग करने की आवश्यकता होती है।

```
<axisVariable>
    <sourceName>time</sourceName>
    <destinationName>time</destinationName>
    <!-- sourceAttributes>
        ... removed several lines ...
        <att name="units">days since 1-1-1 00:00:0.0</att>
    </sourceAttributes -->
    <addAttributes>
        ... removed several lines ...
        <att name="legacy_time_adjust">true</att>
    </addAttributes>
</axisVariable>
```

###### यूनिट{#units} 
*    [ **यूनिट** ](#units)   ( [ COARDS ](https://ferret.pmel.noaa.gov/noaa_coop/coop_cdf_profile.html) , [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) और [एसीडी](https://wiki.esipfed.org/Attribute_Convention_for_Data_Discovery_1-3) मेटाडाटा मानक) डेटा मूल्यों की इकाइयों को परिभाषित करता है। उदाहरण के लिए,
    ```
        <att name="units">degree\\_C</att>
    ```
    * "इकाई" को एक स्रोत के रूप में जाना जाता हैAttribute या addAttribute के लिए "time" वेरिएबल और जब भी उचित हो तो अन्य चरों के लिए STRONGLY RECOMMENDED है। (जो हमेशा होता है) ।
    * सामान्य तौर पर, हम अनुशंसा करते हैं [UDUnits](https://www.unidata.ucar.edu/software/udunits/) \\ संगत इकाइयों जो द्वारा आवश्यक है [ COARDS ](https://ferret.pmel.noaa.gov/noaa_coop/coop_cdf_profile.html) और [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) मानकों।
    * एक अन्य सामान्य मानक है [UCUM](https://unitsofmeasure.org/ucum.html) -- यूनिट्स ऑफ मापन के लिए एकीकृत कोड। [ OGC ](https://www.ogc.org/) जैसे सेवाएं [ SOS ](https://www.ogc.org/standards/sos) , [ WCS ](https://www.ogc.org/standards/wcs) , और [ WMS ](https://www.ogc.org/standards/wms) यूयूएम की आवश्यकता होती है और अक्सर यूयूएम को यूओएम के रूप में संदर्भित करती है (माप की इकाई) ।
    * हम अनुशंसा करते हैं कि आप अपने सभी डेटासेट के लिए एक यूनिट मानक का उपयोग करें ERDDAP । आपको बताना चाहिए ERDDAP™ आप किस मानक के साथ उपयोग कर रहे हैं&lt;इकाइयों \\_standard&gt;, अपने में [साइटमैप](/docs/server-admin/deploy-install#setupxml) फ़ाइल
    * विभिन्न स्रोत फ़ाइलों में दिए गए परिवर्तनीय इकाइयों को सुसंगत होना चाहिए। यदि आपके पास डेटा फ़ाइलों का संग्रह है जहां फ़ाइलों का एक सबसेट फ़ाइलों के एक या एक से अधिक अन्य सबसेट की तुलना में विभिन्न इकाइयों मानों का उपयोग करता है (उदाहरण के लिए,)
"1985-01-01 के बाद से दिन" बनाम "2000-01-01 के बाद से दिन",
"degree \\_Celsius" बनाम "deg \\_C", या
"Knots" बनाम "m/s") आपको इकाइयों के मूल्यों को मानकीकृत करने का एक तरीका ढूंढना होगा, अन्यथा, ERDDAP™ केवल फ़ाइलों के एक उपसेट लोड होगा। इसके बारे में सोचें: यदि एक फ़ाइल में विंडस्पीड यूनिट = नॉट्स है और किसी अन्य में विंडस्पीड यूनिट = m/s है, तो दोनों फाइलों के मूल्यों को समान डेटासेट में शामिल नहीं किया जाना चाहिए।
        * यदि फ़ाइलों को ग्रिड किया जाता है .nc कई स्थितियों में आप उपयोग कर सकते हैं [ EDDGrid से NcFilesUnpacked](#eddgridfromncfilesunpacked) ।
        * यदि फाइलें सारणीबद्ध डेटा फाइलें हैं, तो कई स्थितियों में आप EDDTableFrom का उपयोग कर सकते हैं। ' [मानकीकरण क्या](#standardizewhat) बताने के लिए ERDDAP स्रोत फ़ाइलों को मानकीकृत करने के लिए क्योंकि उन्हें पढ़ा जाता है ERDDAP ।
        * कठिन समस्याओं के लिए, आप उपयोग कर सकते हैं [एनसीएमएल](#ncml-files) या [ NCO ](#netcdf-operators-nco) समस्या को हल करने के लिए।
    * CF मानक अनुभाग 8.1 का कहना है कि अगर एक चर डेटा के माध्यम से पैक किया जाता है [ scale\\_factor और/or add\\_offset ](#scale_factor) "एक चर की इकाइयां अनपैक्ड डेटा का प्रतिनिधि होना चाहिए।
    *    [समय और समय-समय पर चर के लिए,](#time-units) या तो चर [स्रोतAttributes](#variable-addattributes) या&lt; addAttributes &gt; (जो पूर्वाग्रह लेता है) MUST [यूनिट](#units) क्या है
        
        * संख्यात्मक डेटा के साथ समय अक्ष चर या समय डेटा चर के लिए: [UDUnits](https://www.unidata.ucar.edu/software/udunits/) \\ संगत स्ट्रिंग (प्रारूप के साथ *यूनिट* बाद में *बेसटाइम* ) स्रोत समय मूल्यों की व्याख्या कैसे करें (उदाहरण के लिए, 1970-01-01T00:00:00Z के बाद से सेकंड) ।
            
         *यूनिट* कोई भी हो सकता है:
        ```
            ms, msec, msecs, millis, millisec, millisecs, millisecond, milliseconds,  
            s, sec, secs, second, seconds, m, min, mins, minute, minutes, h, hr, hrs, hour, hours,  
            d, day, days, week, weeks, mon, mons, month, months, yr, yrs, year, or years.  
        ```
तकनीकी रूप से, ERDDAP™ नहीं UDUNITS जब परिवर्तित "years since" और "months since" समय मान "seconds since" । The The most of the UDUNITS मानक एक निश्चित, एकल मान के रूप में एक साल को परिभाषित करता है: 3.15569259747e7 सेकंड। और UDUNITS एक महीने को वर्ष / 12 के रूप में परिभाषित करता है। दुर्भाग्य से, अधिकांश / सभी डेटासेट जिन्हें हमने देखा है कि उपयोग "years since" या "months since" स्पष्ट रूप से कैलेंडर वर्ष या कैलेंडर महीनों के लिए मानों का इरादा रखता है। उदाहरण के लिए, 3 "months since 1970-01-01" आमतौर पर 1970-04-01 का मतलब होता है। तो, ERDDAP™ व्याख्या "years since" और "months since" साल और महीने के रूप में, और कड़ाई से पालन नहीं करता है UDUNITS मानक।
            
The The most of the *बेसटाइम* ISO 8601:2004 होना चाहिए (E) स्वरूपित तिथि समय स्ट्रिंग ( yyyy-MM-dd 'T'H:mm: ssZ, उदाहरण के लिए, 1970-01-01T00:00:00Z) , या उसके कुछ स्वरूप (उदाहरण के लिए, अंत में लापता भागों के साथ) । ERDDAP™ उस आदर्श प्रारूप की विविधताओं की एक विस्तृत श्रृंखला के साथ काम करने की कोशिश करता है, उदाहरण के लिए, "1970-1-1 0:0:0" समर्थित है। यदि समय क्षेत्र की जानकारी गायब हो जाती है, तो यह माना जाता है कि यह समय क्षेत्र की जानकारी गायब है। Zulu समय क्षेत्र (AKA GMT) । यहां तक कि अगर किसी अन्य समय ऑफसेट निर्दिष्ट है, ERDDAP™ कभी डेलाइट सेविंग टाइम का उपयोग नहीं करता। यदि आधारटाइम कुछ अन्य प्रारूपों का उपयोग करता है, तो आपको उपयोग करना चाहिए&lt; addAttributes &gt; एक नई इकाइयों स्ट्रिंग निर्दिष्ट करने के लिए जो ISO 8601:2004 की एक विविधता का उपयोग करता है (E) प्रारूप (उदाहरण के लिए, 1 जनवरी 1985 के बाद से 1985-01-01 के दिनों में परिवर्तन के दिन)।
        
आप परीक्षण कर सकते हैं ERDDAP एक विशिष्ट से निपटने की क्षमता *यूनिट* बाद में *बेसटाइम* साथ ERDDAP ' [टाइम कनवर्टर](https://coastwatch.pfeg.noaa.gov/erddap/convert/time.html) । उम्मीद है, आप एक नंबर में प्लग कर सकते हैं (डेटा स्रोत से पहली बार मूल्य?) एक इकाई स्ट्रिंग, कन्वर्ट पर क्लिक करें, और ERDDAP™ इसे आईएसओ 8601:2004 में परिवर्तित करने में सक्षम होगा (E) स्वरूपित तिथि समय स्ट्रिंग। अगर इकाई स्ट्रिंग पहचानने योग्य नहीं है तो कनवर्टर एक त्रुटि संदेश वापस कर देगा।

###### स्ट्रिंग टाइम यूनिट{#string-time-units} 
*    [इकाइयों के लिए स्ट्रिंग डेटा के साथ समय या टाइमस्टैम्प डेटा चर के लिए विशेषता,](#string-time-units) आपको निर्दिष्ट करना होगा [java.time.DateTimeFormatter](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html) पैटर्न (जो ज्यादातर जावा.टेक्स्ट के साथ संगत है। सरलDateFormat) जो स्ट्रिंग समय की व्याख्या करने का वर्णन करता है।
    
आमतौर पर इस्तेमाल किए जाने वाले समय प्रारूपों के लिए जो आईएसओ 8601: 2004 के भिन्नताएं हैं (E) मानक प्रारूप (उदाहरण के लिए, 2018-01-02T00:00Z) , आप विविधताओं को निर्दिष्ट कर सकते हैं yyyy-MM-dd 'T'H:mm: ssZ, उदाहरण के लिए, उपयोग करें yyyy-MM-dd यदि केवल स्ट्रिंग टाइम की तारीख है। किसी भी प्रारूप के लिए जो yyyy-M के साथ शुरू होता है, ERDDAP एक विशेष पार्सर का उपयोग करता है जो प्रारूप में मामूली विविधताओं का बहुत महत्व देता है। पार्सर प्रारूप 'Z', "UTC", "GMT", ± XX: XX, ± XXXX, और ± XX प्रारूपों में समय क्षेत्र को संभाल सकता है। यदि तारीख के कुछ हिस्सों को निर्दिष्ट नहीं किया जाता है (उदाहरण के लिए, मिनट और सेकंड) , ERDDAP™ उस क्षेत्र के लिए सबसे कम मान लेता है (उदाहरण के लिए, यदि सेकंड निर्दिष्ट नहीं हैं, तो सेकंड = 0 मान लिया जाता है) ।
    
अन्य सभी स्ट्रिंग टाइम प्रारूपों के लिए, आपको एक डेटटाइमफॉर्मेटर-संगत समय प्रारूप स्ट्रिंग को ठीक से निर्दिष्ट करने की आवश्यकता है। लाइक yyyy-MM-dd 'T'H:mm: ssZ, इन प्रारूप तारों को वर्णों से बनाया गया है जो समय स्ट्रिंग से एक विशिष्ट प्रकार की जानकारी की पहचान करते हैं, उदाहरण के लिए, मीटर का मतलब मिनट-ऑफ-घंटे होता है। यदि आप प्रारूप वर्ण को कुछ बार दोहराते हैं, तो यह अर्थ को और अधिक परिष्कृत करता है, उदाहरण के लिए, m का मतलब है कि मान किसी भी संख्या के अंकों द्वारा निर्दिष्ट किया जा सकता है, mm का मतलब है कि मान को 2 अंकों द्वारा निर्दिष्ट किया जाना चाहिए। The The most of the Java DateTimeFormatter के लिए प्रलेखन एक कच्चे अवलोकन है और इन विवरणों को स्पष्ट नहीं बनाता है। इसलिए यहां प्रारूप चरित्र विविधताओं और उनके अर्थ की सूची है ERDDAP™   (जो कभी-कभी थोड़ा अलग होता है Java DateTimeFormatter) :
    
     | वर्ण | उदाहरण | अर्थ | 
     | --- | --- | --- | 
     | यू, वाई, वाई | \\-4712, 0, 1, 10, 100, 2018 | एक साल की संख्या, अंकों की संख्या। ERDDAP™ Y (वर्ष का) Y (सप्ताह-आधारित वर्ष, क्योंकि यह अक्सर गलती से य के बजाय इस्तेमाल किया जाता है) जैसे [खगोलीय वर्ष संख्या](https://en.wikipedia.org/wiki/Astronomical_year_numbering) । खगोलशास्त्रीय वर्ष सकारात्मक या नकारात्मक पूर्णांक हैं जो बीसीई का उपयोग नहीं करते हैं (BC) सीई (विज्ञापन) युग Designator: 2018 = 2018CE, ..., 2 = 2CE, 1 = 1CE, 0 = 1BCE, -1 = 2BCE, -2 = 3BCE, ... | 
     | Uuuuu, yyyy, यमन | \\-4712, 0000, 0001, 0010, 0100, 2018 | 4 अंकीय खगोलीय वर्ष संख्या (किसी भी पूर्ववर्ती '-' की अनदेखी)   | 
     | एम | 1, 01, 12 | एक महीने की संख्या, अंकों की संख्या (1 = जनवरी)   | 
     | एमएम | 01, 12 | 2 अंक (शून्य गद्देदार) महीना | 
     | एमएम | Jan, Jan, JAN | एक 3 अक्षर अंग्रेजी महीने का नाम, केस असंवेदनशील | 
     | एमएमएमएम | जनवरी, जन, JAN, जनवरी, जनवरी, जनवरी, JANUARY | 3 अक्षर या पूर्ण अंग्रेजी माह का नाम, मामले असंवेदनशील | 
     | D | 1, 01, 31 | एक दिन के महीने संख्या, अंकों की किसी भी संख्या | 
     | dd | 01, 31 | 2 अंक (शून्य गद्देदार) दिन का महीना। पहला 'अंक' अंतरिक्ष हो सकता है। | 
     | D | 1, 001,366 | डे-ऑफ-वर्ष, किसी भी संख्या में अंक, 001=जनवरी 1 | 
     | डीडी | 001, 366 | दिन का वर्ष, 3 अंक, 001=जनवरी 1 | 
     | EEE | thu, THU, Thu | एक 3 अक्षर डे-ऑफ- week, मान को नजरअंदाज कर दिया जाता है जब पार्सिंग | 
     | EEE | thu, THU, Thu, thursday, THURSDAY, गुरुवार | एक 3 अक्षर या पूर्ण अंग्रेजी डे-ऑफ-सप्ताह, केस असंवेदनशील, मान को नजरअंदाज कर दिया जाता है जब पार्सिंग | 
     | एच | 0, 00, 23 | दिन (0-23) किसी भी संख्या में अंक | 
     | एच | 00, 23 | HH hour of day (00-23) 2 अंक। पहला 'अंक' अंतरिक्ष हो सकता है। | 
     | a | हूँ, AM, PM, PM | AM or PM, case-inसंवेदनशील | 
     | एच | 12, 1, 01, 11 | घड़ी-घंटे का हूँ-pm (12, 1, 2, ... 11) किसी भी संख्या में अंक | 
     | hh | 12, 01, 11 | घड़ी-घंटे का हूँ-pm (12, 1, 2, ... 11) 2 अंक। पहला 'अंक' अंतरिक्ष हो सकता है। | 
     | K | 0, 1, 11 | समय-समय पर (0, 1, ...11) किसी भी संख्या में अंक | 
     | KK | 00, 01, 11 | समय-समय पर, 2 अंक | 
     | मीटर | 0, 00, 59 | मिनट के घंटे, अंकों की किसी भी संख्या | 
     | मिमी | 00, 59 | मिनट के घंटे, 2 अंक | 
     | s | 0, 00, 59 | दूसरे मिनट, अंकों की किसी भी संख्या | 
     | एस | 00, 59 | दूसरा मिनट, 2 अंक | 
     | एस | 0, 000, 9,999 | भिन्न-भिन्न, जैसे कि एक दशमलव बिंदु का पालन करना, अंकों की किसी भी संख्या | 
     | एसएस | 00, 99 | एक दूसरे का सौवां, 2 अंक | 
     | एसएसएस | 000, 999 | एक दूसरे के हजारों, 3 अंक | 
     | A | 0, 000, 86399999 | मिलीसेकंड ऑफ डे, किसी भी संख्या में अंक | 
     | AAAAAAAAA | 00000000, 86399999 | मिलीसेकंड ऑफ डे, 8 अंक | 
     | एन | 0, 000000000000000000, 86399999999999999 | नैनोसेकंड ऑफ डे, किसी भी संख्या में अंक। में ERDDAP™ , यह nMillis के लिए truncated है। | 
     | एनएनएन | 00000000000000, 86399999999999999 | नैनोसेकंड ऑफ डे, 14 अंक। में ERDDAP™ यह nMillis के लिए truncated है। | 
     | n | 0000000000000000, 59999999999 | नैनोसेकंड-ऑफ-सेकेंड, किसी भी संख्या में अंक। में ERDDAP™ यह nMillis के लिए truncated है। | 
     | nina | 00000000000, 59999999999999 | नैनोसेकंड का दूसरा, 11 अंक। में ERDDAP™ यह nMillis के लिए truncated है। | 
     | XXX, ZZZ | Z,-08:00, +01:00 | प्रारूप 'Z' या ± के साथ एक समय क्षेत्र (2 अंक घंटे ऑफसेट) : (2 अंक मिनट ऑफसेट) । यह व्यवहार *अंतरिक्ष* + (गैर मानक) । ZZZ समर्थन 'Z' गैर मानक है लेकिन एक आम उपयोगकर्ता त्रुटि के साथ सौदा करता है। | 
     | XX, ZZ | Z -0800, +0100 | प्रारूप 'Z' या ± के साथ एक समय क्षेत्र (2 अंक घंटे ऑफसेट) : (2 अंक मिनट ऑफसेट) । यह व्यवहार *अंतरिक्ष* + (गैर मानक) । ZZ समर्थन 'Z' गैर मानक है लेकिन एक आम उपयोगकर्ता त्रुटि के साथ सौदा करता है। | 
     | X, Z | Z,-08, +01 | प्रारूप 'Z' या ± के साथ एक समय क्षेत्र (2 अंक घंटे ऑफसेट) : (2 अंक मिनट ऑफसेट) । यह व्यवहार *अंतरिक्ष* + (गैर मानक) । Z समर्थन 'Z' गैर मानक है लेकिन एक आम उपयोगकर्ता त्रुटि के साथ सौदों। | 
     | xxx | \\-08:00, +01:00 | प्रारूप के साथ एक समय क्षेत्र ± (2 अंक घंटे ऑफसेट) : (2 अंक मिनट ऑफसेट) । यह व्यवहार *अंतरिक्ष* + (गैर मानक) । | 
     | xx | \\-0800, +0100 | प्रारूप के साथ एक समय क्षेत्र ± (2 अंक घंटे ऑफसेट)  (2 अंक मिनट ऑफसेट) । यह व्यवहार *अंतरिक्ष* + (गैर मानक) । | 
     | x | \\-08, +01 | प्रारूप के साथ एक समय क्षेत्र ± (2 अंक घंटे ऑफसेट) । यह व्यवहार *अंतरिक्ष* + (गैर मानक) । | 
     | ' | 'टी', 'जेड', 'जीएमटी' | वर्णों की एक श्रृंखला की शुरुआत और अंत | 
     | ' ' (दो एकल उद्धरण)   | ' ' | दो एकल उद्धरण एक शाब्दिक एकल उद्धरण को दर्शाता है | 
     |   \\[  \\]   |   \\[   \\]   | प्रारंभ (" \\[ ") अंत (" \\] ") एक वैकल्पिक अनुभाग का। यह नोटेशन केवल साक्षर पात्रों और प्रारूप स्ट्रिंग के अंत में समर्थित है। | 
     | # 123;#125; | # 123;#125; | भविष्य के उपयोग के लिए आरक्षित | 
     | जी, एल, क्यू, ई, सी, वी, जेड, ओ, पी |       | इन स्वरूपण वर्णों द्वारा समर्थित हैं Java DateTimeFormatter, लेकिन वर्तमान में समर्थित नहीं है ERDDAP । यदि आपको उनके लिए समर्थन की आवश्यकता है, तो ईमेल क्रिस। जॉन at noaa.gov. | 
    
नोट्स:
    
    * punctuation के साथ एक तारीख समय में, संख्यात्मक मूल्यों में अंकों की एक परिवर्तनीय संख्या हो सकती है (उदाहरण के लिए, यूएस स्लैश डेट प्रारूप "1/2/1985" में महीने और तारीख 1 या 2 अंक हो सकती है।) इसलिए प्रारूप 1-लेटर टोकन का उपयोग करना चाहिए, उदाहरण के लिए, M/d/yyyyy, जो महीने और तारीख के लिए किसी भी संख्या में अंकों को स्वीकार करते हैं।
    * यदि किसी आइटम के लिए अंकों की संख्या स्थिर है, उदाहरण के लिए, 01/02/1985, तो प्रारूप में अंकों की संख्या निर्दिष्ट करें, उदाहरण के लिए, MM/dd/yyyyyyyy, 2-digit तारीख और 4 अंक वर्ष के लिए।
    * इन प्रारूपों के साथ काम करने के लिए मुश्किल है। एक दिए गए प्रारूप अधिकांश के लिए काम कर सकते हैं, लेकिन सभी नहीं, दिए गए चर के लिए समय स्ट्रिंग। हमेशा जांचें कि आपके द्वारा निर्दिष्ट प्रारूप में उम्मीद के रूप में काम कर रहा है ERDDAP सभी के लिए एक चर समय तार।
    * जब संभव हो, जनरेटडेटासेटएक्सएमएल टाइम प्रारूप स्ट्रिंग्स का सुझाव देगा।
    * यदि आपको एक प्रारूप स्ट्रिंग बनाने में मदद की आवश्यकता है, तो कृपया क्रिस को ईमेल करें। जॉन at noaa.gov.

मुख्य समय डेटा चर (सारणीबद्ध डेटासेट के लिए) और मुख्य समय अक्ष चर (ग्रिड डेटासेट के लिए) द्वारा मान्यता प्राप्त हैं [ destinationName ](#destinationname) समय। उनकी इकाइयों मेटाडाटा संख्यात्मक समय मूल्यों के लिए एक UDUnits-संगत इकाइयों स्ट्रिंग होना चाहिए, उदाहरण के लिए, " 1970-01-01 के बाद से दिन" (सारणीबद्ध या ग्रिड डेटासेट के लिए) या [स्ट्रिंग समय के लिए उपयुक्त इकाइयों](#string-time-units) , उदाहरण के लिए, "M/d/yyyyy" (सारणीबद्ध डेटासेट के लिए) ।

विभिन्न ग्रिड में विभिन्न समय इकाइयों .nc फ़ाइल - यदि आपके पास ग्रिड का संग्रह है .nc जहां, समय चर के लिए, फ़ाइलों का एक सबसेट फ़ाइलों के एक या एक से अधिक अन्य सबसेट की तुलना में अलग समय इकाइयों का उपयोग करता है, आप उपयोग कर सकते हैं [ EDDGrid से NcFilesUnpacked](#eddgridfromncfilesunpacked) । यह समय मान को परिवर्तित करता है "seconds since 1970-01-01T00:00:00Z" निम्न स्तर पर, इस प्रकार मतभेदों को छिपाते हुए, ताकि आप विषम फ़ाइलों के संग्रह से एक डेटासेट बना सकें।

###### टाइमस्टैम्प चर{#timestamp-variables} 
 [टाइमस्टैम्प चर](#timestamp-variables) -- कोई अन्य परिवर्तनीय ( axisVariable या dataVariable एक में EDDGrid या EDDTable Dataset) एक टाइमस्टैम्प चर हो सकता है। टाइमस्टैम्प चर वेरिएबल हैं जिनके पास समय से संबंधित इकाइयां और समय डेटा हैं, लेकिन इसमें एक समय से संबंधित इकाइयां हैं।&lt; destinationName &gt; समय के अलावा टाइमस्टैम्प चर मुख्य समय चर की तरह व्यवहार करते हैं जिसमें वे स्रोत के समय स्वरूप को परिवर्तित करते हैं। "seconds since 1970-01-01T00:00:00Z" ISO 8601:2004 (E) प्रारूप). ERDDAP™ समय पहचानता है उनके समय से संबंधित द्वारा मुद्रा चर " [यूनिट](#units) " मेटाडाटा" जो इस नियमित अभिव्यक्ति से मेल खाती है " \\[ A-ZA \\] + \\[ 0-9 \\] + (संख्यात्मक तिथि के लिए उदाहरण के लिए, टाइम्स "seconds since 1970-01-01T00:00:00Z" ) या तारीख होना टाइम प्रारूप स्ट्रिंग जिसमें "uuu", "yyyyy" या "YYYYY" शामिल हैं। (उदाहरण के लिए, " yyyy-MM-dd 'T'H:mm: ssZ") । लेकिन अभी भी उपयोग करें destinationName   "time" मुख्य तारीख के लिए समय चर।

 **हमेशा यह सुनिश्चित करने के लिए अपने काम की जांच करें कि जिस समय डेटा में दिखाया गया है, उस समय डेटा को प्रदर्शित करता है। ERDDAP™ सही समय डेटा है।** समय डेटा के साथ काम करना हमेशा मुश्किल होता है और गलती होती है।

देखें [समय चर के बारे में अधिक जानकारी](#destinationname) ।
 ERDDAP™ इसमें उपयोगिता है [एक न्यूमेरिक कनवर्ट करें समय-समय पर स्ट्रिंग टाइम से](https://coastwatch.pfeg.noaa.gov/erddap/convert/time.html) ।
देखें [कैसे ERDDAP™ समय के साथ सौदे](https://coastwatch.pfeg.noaa.gov/erddap/convert/time.html#erddap) ।
         
        
######  valid\\_range  {#valid_range} 
*    [ ** valid\\_range ** या ** valid\\_min ** और ** valid\\_max ** ](#valid_range) -- ये वैकल्पिक चर गुण हैं जिन्हें परिभाषित किया गया है [CF](https://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html) मेटाडाटा सम्मेलन। उदाहरण के लिए,

    >    &lt;att name="valid\\_range" [type="floatList"](#attributetype)\\>0.0 40.0&lt;/att>  

या

    >    &lt;att name="valid\\_min" [type="float"](#attributetype)\\>0.0&lt;/att>  
    >    &lt;att name="valid\\_max" [type="float"](#attributetype)\\>40.0&lt;/att>  

    * यदि वर्तमान में, उन्हें वैरिएबल के समान डेटा टाइप होना चाहिए और उस परिवर्तनीय के लिए डेटा के वैध न्यूनतम और अधिकतम मान निर्दिष्ट करना चाहिए। उपयोगकर्ताओं को इस श्रेणी के बाहर मूल्यों पर विचार करना चाहिए।
    *    ERDDAP™ लागू नहीं होता valid\\_range । एक और तरीका कहा: ERDDAP™ डेटा मूल्यों को बाहर नहीं बदलता है valid\\_range \\_Fill मूल्य या मूल्य missing\\_value । ERDDAP™ बस इस मेटाडाटा पर गुजरता है और एप्लिकेशन को आप तक छोड़ देता है।
क्यों? यही कारण है कि यह मेटाडाटा क्या है। यदि डेटा प्रदाता चाहता था, तो डेटा प्रदाता ने डेटा मूल्यों को बाहर कर दिया है। valid\\_range \\_FillValues होना चाहिए। ERDDAP™ डेटा प्रदाता का दूसरा अनुमान नहीं है। यह दृष्टिकोण सुरक्षित है: अगर यह बाद में दिखाया गया है कि valid\\_range बहुत संकीर्ण या अन्यथा गलत था, ERDDAP™ डेटा को obliterated नहीं होगा।
    * यदि डेटा के साथ पैक किया जाता है [ scale\\_factor और/or add\\_offset ](#scale_factor) , valid\\_range , valid\\_min और valid\\_max पैक किए गए डेटा प्रकार और मान होना चाहिए। चूंकि ERDDAP™ लागू scale\\_factor और add\\_offset जब यह डेटासेट लोड करता है, ERDDAP™ unpacking होगा valid\\_range , valid\\_min और valid\\_max मान इतना है कि गंतव्य मेटाडाटा (उपयोगकर्ताओं को दिखाया गया) अनपैक्ड डेटा प्रकार और रेंज को इंगित करेगा।
या, अगर एक unpacked \\_ valid\\_range विशेषता मौजूद है, इसका नाम बदल दिया जाएगा valid\\_range जब ERDDAP™ डेटासेट लोड करता है।
##### &lt;MVRows&gt;{#removemvrows} 
* [ ** &lt;MVRows ** ] (#removemvrows) में एक टैग के भीतर एक OPTIONAL टैग है datasets.xml EDDTableFromFiles (सभी वर्गों सहित) हालांकि इसका उपयोग केवल EDDTableFromMultidimNcFiles के लिए किया जाता है। यह सच या झूठ का मान हो सकता है। उदाहरण के लिए, सच
यह एक समूह के अंत में पंक्तियों के किसी भी ब्लॉक को हटा देता है जहां सभी मान हैं missing\\_value , \\_FillValue, या CoHort ...Array देशी लापता मान (या Chararrays के लिए # 32) । यह CF DSG बहुआयामी सरणी फ़ाइल प्रकार और समान फ़ाइलों के लिए है। यदि सही है तो यह उचित परीक्षण करता है और इसलिए हमेशा सभी अधिकतम मंद चर को लोड करता है, इसलिए यह अतिरिक्त समय ले सकता है।
का डिफ़ॉल्ट मान गलत है।
सिफारिश -- यदि आपके डेटासेट के लिए संभव हो, तो हम अनुशंसा करते हैं कि MVRows को गलत तरीके से हटा दें। हटाने की सेटिंगMVRows को सच करने के लिए अनुरोध को धीमा कर सकते हैं, हालांकि कुछ डेटासेट के लिए आवश्यकता हो सकती है।
