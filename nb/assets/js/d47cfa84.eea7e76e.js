"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[9462],{28453(e,t,a){a.d(t,{R:()=>i,x:()=>r});var s=a(96540);const n={},o=s.createContext(n);function i(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(o.Provider,{value:t},e.children)}},43717(e,t,a){a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"user/user-tips/xarray_erddap","title":"xarray_erddap","description":"Thanks to Roy Mendelssohn for this write up.","source":"@site/docs/user/user-tips/xarray_erddap.md","sourceDirName":"user/user-tips","slug":"/user/user-tips/xarray_erddap","permalink":"/nb/docs/user/user-tips/xarray_erddap","draft":false,"unlisted":false,"editUrl":"https://github.com/erddap/erddap.github.io/tree/main/docs/user/user-tips/xarray_erddap.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docSidebar","previous":{"title":"accessing_private_datasets","permalink":"/nb/docs/user/user-tips/accessing_private_datasets"},"next":{"title":"Access to Private Datasets","permalink":"/nb/docs/user/AccessToPrivateDatasets"}}');var n=a(74848),o=a(28453);const i={},r=void 0,d={},l=[];function h(e){const t={a:"a",code:"code",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Thanks to Roy Mendelssohn for this write up."}),"\n",(0,n.jsxs)(t.p,{children:["The Python package 'xarray' has become very popular for accessing, subsetting and visualizing gridded data in a variety of formats. Note that 'xarray' works fine with ERDDAP\u2122's OPenDAP response for both tabledap and griddap protocols using xarray's OPenDAP engines like netcdf4 or pydap. What is an OPeNDAP response? It is any ERDDAP URL without slicing or filters, just the datasetID. When using slices of filters however, or even OPeNDAP itself, one can use the erddapy (",(0,n.jsx)(t.a,{href:"https://github.com/ioos/erddapy",children:"https://github.com/ioos/erddapy"}),") as an xarray engine. The example below shows how to load a 'griddap' dataset."]}),"\n",(0,n.jsxs)(t.p,{children:["One of my favorite datasets is the JPL MURv4.1 SST data available at ",(0,n.jsx)(t.a,{href:"https://coastwatch.pfeg.noaa.gov/erddap/griddap/jplMURSST41.html",children:"https://coastwatch.pfeg.noaa.gov/erddap/griddap/jplMURSST41.html"}),".  If I want to do a subset of the data for say January 28, 2026, latitdues (20,50)  and longitudes (-140, -105), and download a netcdf file,  the ERDDAP\u2122 URL for this would be  ",(0,n.jsx)(t.a,{href:"https://coastwatch.pfeg.noaa.gov/erddap/griddap/jplMURSST41.nc?analysed_sst%5B(2026-01-28T09:00:00Z):1:(2026-01-28T09:00:00Z)",children:"https://coastwatch.pfeg.noaa.gov/erddap/griddap/jplMURSST41.nc?analysed_sst[(2026-01-28T09:00:00Z):1:(2026-01-28T09:00:00Z)"}),"][(20):1:(50)][(-140):1:(-105)]"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'import xarray as xr\n\n\nurl = "https://coastwatch.pfeg.noaa.gov/erddap/griddap/jplMURSST41.nc?analysed_sst[(2026-01-28T09:00:00Z):1:(2026-01-28T09:00:00Z)][(20):1:(50)][(-140):1:(-105)]"\n\nds = xr.open_dataset(url, engine="erddapy")\n'})}),"\n",(0,n.jsx)(t.p,{children:"One can achieve the same using just the OPeNDAP URL. If we think of the steps to access a local NetCDF file in 'xarray' we would do the following steps:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Open the file by pointing at the full path to the file"}),"\n",(0,n.jsx)(t.li,{children:"Look at the coordinate information from the first step"}),"\n",(0,n.jsx)(t.li,{children:'Use one of the various "select" methods to subset the data'}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["In the above you open the file first,  then do the subsetting.  To use 'xarray' with an ERDDAP\u2122 dataset you do the same, once you realize,  as explained in the ERDDAP\u2122 documentation,  that the \"path to the file\" is the URL without any return format and without any contraints,  in the case of the MUR dataset that is ",(0,n.jsx)(t.a,{href:"https://coastwatch.pfeg.noaa.gov/erddap/griddap/jplMURSST41",children:"https://coastwatch.pfeg.noaa.gov/erddap/griddap/jplMURSST41"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"As a concrete example using the MUR dataset,  first I need to import the packages that will be used:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:"import matplotlib.pyplot as plt\nimport xarray as xr\n"})}),"\n",(0,n.jsx)(t.p,{children:'Then,  as descibed above I set the URL to the dataset "name" and open the "file" (not that it is actually an aggregation of files) using "xr.open_dataset"'}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'mur_url = "https://coastwatch.pfeg.noaa.gov/erddap/griddap/jplMURSST41"\nds = xr.open_dataset(mur_url, decode_times=True)\n\n\n'})}),"\n",(0,n.jsx)(t.p,{children:'This produces the following (partial) results in "ds":'}),"\n",(0,n.jsx)(t.p,{children:"Dimensions:"}),"\n",(0,n.jsx)(t.p,{children:"time: 8641l atitude: 17999 longitude: 36000"}),"\n",(0,n.jsx)(t.p,{children:"Coordinates:"}),"\n",(0,n.jsx)(t.p,{children:"time(time) datetime64[ns] 2002-06-01T09:00:00 ... 2026-01-...\nlatitude(latitude) float32 -89.99 -89.98 ... 89.98 89.99\nlongitude(longitude) float32 -180.0 -180.0 ... 180.0 180.0"}),"\n",(0,n.jsx)(t.p,{children:"Indexes:"}),"\n",(0,n.jsx)(t.p,{children:"time PandasIndex\nlatitude PandasIndex\nlongitude PandasIndex"}),"\n",(0,n.jsx)(t.p,{children:"At this point you proceed just as you would had it been a local file.  I give two examples below,  one that takes the last two times using array indexing and one that gets the values of the last two times and uses that to make the subset, but in either case this is identical to what you would do for a local file."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'lat_min, lat_max = 20, 50\nlon_min, lon_max = -140, -105\nsub_isel = ds.isel(time=slice(-2, None)).sel(\n    latitude=slice(lat_min, lat_max),\n    longitude=slice(lon_min, lon_max),\n)\n# plot the result\n#sub_isel["analysed_sst"].isel(time=0).plot()\n'})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'last2 = ds["time"].values[-2:]\nsub_sel = ds.sel(time=last2).sel(\n    latitude=slice(lat_min, lat_max),\n    longitude=slice(lon_min, lon_max),\n)\n# plot the result\n#sub_sel["analysed_sst"].isel(time=0).plot()\n\n\n'})}),"\n",(0,n.jsx)(t.p,{children:"So the take home message is that 'xarray' works great for data on an ERDDAP\u2122 server if you pass to 'xr.open_dataset()' the ERDDAP\u2122 URL without a file type and without constraints, or use the erddapy engine."})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}}}]);